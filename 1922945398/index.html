<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/dinosaur.png"><link rel="icon" href="/img/dinosaur.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Noah Lee"><meta name="keywords" content=""><meta name="description" content="Java SPI概述在面向对象的设计原则中，一般推荐模块之间基于接口编程，通常情况下调用方模块是不会感知到被调用方模块的内部具体实现。一旦代码里面涉及具体实现类，就违反了开闭原则。如果需要替换一种实现，就需要修改代码。 为了实现在模块装配的时候不用在程序里面动态指明，这就需要一种服务发现机制。Java SPI 就是提供了这样一个机制：为某个接口寻找服务实现的机制。这有点类似 IoC 的思想，将装配"><meta property="og:type" content="article"><meta property="og:title" content="SPI机制总结"><meta property="og:url" content="https://beingku.github.io/1922945398/index.html"><meta property="og:site_name" content="Youzi"><meta property="og:description" content="Java SPI概述在面向对象的设计原则中，一般推荐模块之间基于接口编程，通常情况下调用方模块是不会感知到被调用方模块的内部具体实现。一旦代码里面涉及具体实现类，就违反了开闭原则。如果需要替换一种实现，就需要修改代码。 为了实现在模块装配的时候不用在程序里面动态指明，这就需要一种服务发现机制。Java SPI 就是提供了这样一个机制：为某个接口寻找服务实现的机制。这有点类似 IoC 的思想，将装配"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://beingku.github.io/img/code03.jpeg"><meta property="article:published_time" content="2023-04-19T08:27:20.000Z"><meta property="article:modified_time" content="2023-04-21T09:08:20.384Z"><meta property="article:author" content="Noah Lee"><meta property="article:tag" content="基础"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://beingku.github.io/img/code03.jpeg"><meta name="referrer" content="no-referrer-when-downgrade"><title>SPI机制总结 - Youzi</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"beingku.github.io",root:"/",version:"1.9.4",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!1,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:80vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Youzi</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/bk02.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="SPI机制总结"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-04-19 16:27" pubdate>2023年4月19日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 20k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 167 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div><div class="scroll-down-bar"><i class="iconfont icon-arrowdown"></i></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">SPI机制总结</h1><div class="markdown-body"><h1 id="Java-SPI"><a href="#Java-SPI" class="headerlink" title="Java SPI"></a>Java SPI</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在面向对象的设计原则中，一般推荐模块之间基于接口编程，通常情况下调用方模块是不会感知到被调用方模块的内部具体实现。一旦代码里面涉及具体实现类，就违反了开闭原则。如果需要替换一种实现，就需要修改代码。</p><p>为了实现在模块装配的时候不用在程序里面动态指明，这就需要一种<code>服务发现机制</code>。Java SPI 就是提供了这样一个机制：<strong>为某个接口寻找服务实现的机制。这有点类似 IoC 的思想，将装配的控制权移交到了程序之外。</strong></p><h2 id="什么是SPI？"><a href="#什么是SPI？" class="headerlink" title="什么是SPI？"></a>什么是SPI？</h2><p>SPI 即 <code>Service Provider Interface</code> ，字面意思就是：“服务提供者的接口”，我的理解是：专门提供给服务提供者或者扩展框架功能的开发者去使用的一个接口。</p><p>SPI 将服务接口和具体的服务实现分离开来，将服务调用方和服务实现者解耦，能够提升程序的扩展性、可维护性。修改或者替换服务实现并不需要修改调用方。</p><p>很多框架都使用了 Java 的 SPI 机制，比如：Spring 框架、数据库加载驱动(JDBC)、日志接口、以及 Dubbo 的扩展实现等等。</p><h3 id="SPI-和-API-有什么区别？"><a href="#SPI-和-API-有什么区别？" class="headerlink" title="SPI 和 API 有什么区别？"></a>SPI 和 API 有什么区别？</h3><p>从广义上来说它们都属于接口</p><img src="https://s2.loli.net/2023/04/20/rUVINRGfwnXz3Dl.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><p>一般模块之间都是通过通过接口进行通讯，那我们在服务调用方和服务实现方（也称服务提供者）之间引入一个“接口”。</p><p>当<code>实现方提供了接口</code>和实现，我们可以通过调用实现方的接口从而拥有实现方给我们提供的能力，这就是 API ，这种接口和实现都是放在实现方的。</p><p>当接口存在于调用方这边时，就是 SPI ，由接口<code>调用方确定接口规则</code>，然后由不同的厂商去根据这个规则对这个接口进行实现，从而提供服务。</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><p>SLF4J （Simple Logging Facade for Java）是 Java 的一个日志门面（接口），其具体实现有几种，比如：Logback、Log4j、Log4j2 等等，而且还可以切换，在切换日志具体实现的时候我们是不需要更改项目代码的，只需要在 Maven 依赖里面修改一些 pom 依赖就好了</p><img src="https://s2.loli.net/2023/04/19/X2YDMVO8oUQKESN.png" srcset="/img/loading.gif" lazyload style="zoom:80%"><h3 id="Service-Provider-Interface"><a href="#Service-Provider-Interface" class="headerlink" title="Service Provider Interface"></a>Service Provider Interface</h3><p>新建一个 Java 项目 <code>service-provider-interface</code> 目录结构如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus">│  service-provider-interface<span class="hljs-selector-class">.iml</span><br>│<br>│<br>└─<span class="hljs-attribute">src</span><br>    ├─cn<br>    │   └─bgroot<br>    │       └─up<br>    │           └─spi<br>    │                Logger<span class="hljs-selector-class">.java</span><br>    │                LoggerService<span class="hljs-selector-class">.java</span><br>    └─Main<span class="hljs-selector-class">.java</span>               <br></code></pre></td></tr></table></figure><p>新建 <code>Logger</code> 接口，这个就是 SPI ， 服务提供者接口，后面的服务提供者就要针对这个接口进行实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.bgroot.up.spi;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">(String msg)</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来就是 <code>LoggerService</code> 类，这个主要是为服务使用者（调用方）提供特定功能的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.bgroot.up.spi;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.ServiceLoader;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggerService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">LoggerService</span> <span class="hljs-variable">SERVICE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggerService</span>();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Logger logger;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Logger&gt; loggerList;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">LoggerService</span><span class="hljs-params">()</span> &#123;<br>        ServiceLoader&lt;Logger&gt; loader = ServiceLoader.load(Logger.class);<br>        List&lt;Logger&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Logger log : loader) &#123;<br>            list.add(log);<br>        &#125;<br>        <span class="hljs-comment">// LoggerList 是所有 ServiceProvider</span><br>        loggerList = list;<br>        <span class="hljs-keyword">if</span> (!list.isEmpty()) &#123;<br>            <span class="hljs-comment">// Logger 只取一个</span><br>            logger = list.get(<span class="hljs-number">0</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            logger = <span class="hljs-literal">null</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LoggerService <span class="hljs-title function_">getService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> SERVICE;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">(String msg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (logger == <span class="hljs-literal">null</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;info 中没有发现 Logger 服务提供者&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            logger.info(msg);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String msg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (loggerList.isEmpty()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;debug 中没有发现 Logger 服务提供者&quot;</span>);<br>        &#125;<br>        loggerList.forEach(log -&gt; log.debug(msg));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>新建 <code>Main</code> 类（服务使用者，调用方），启动程序查看结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.bgroot.up.spi.LoggerService;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LoggerService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> LoggerService.getService();<br><br>        service.info(<span class="hljs-string">&quot;Hello SPI&quot;</span>);<br>        service.debug(<span class="hljs-string">&quot;Hello SPI&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">info</span> 中没有发现 Logger 服务提供者<br><span class="hljs-built_in">debug</span> 中没有发现 Logger 服务提供者<br></code></pre></td></tr></table></figure><p>此时我们只是空有接口，并没有为 <code>Logger</code> 接口提供任何的实现，所以输出结果中没有按照预期打印相应的结果。</p><p>你可以使用命令或者直接使用 IDEA 将整个程序直接打包成 jar 包。</p><h3 id="Service-Provider"><a href="#Service-Provider" class="headerlink" title="Service Provider"></a>Service Provider</h3><p>接下来新建一个项目用来实现 <code>Logger</code> 接口</p><p>新建项目 <code>service-provider</code> 目录结构如下：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs vim">│  service-provider.iml<br>│<br>│<br>├─lib<br>│      service-provider-interface.jar<br>|<br>└─src<br>    ├─<span class="hljs-keyword">cn</span><br>    │  └─bgroot<br>    │      └─<span class="hljs-keyword">up</span><br>    │          └─spi<br>    │              └─service<br>    │                      Logback.java<br>    │<br>    └─META-INF<br>        └─services<br>                <span class="hljs-keyword">cn</span>.bgroot.<span class="hljs-keyword">up</span>.spi.Logger<br></code></pre></td></tr></table></figure><p>新建 <code>Logback</code> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> cn.bgroot.up.spi.service;<br><br><span class="hljs-keyword">import</span> cn.bgroot.up.spi.Logger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Logback</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Logger</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">info</span><span class="hljs-params">(String s)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Logback info 打印日志：&quot;</span> + s);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">debug</span><span class="hljs-params">(String s)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Logback debug 打印日志：&quot;</span> + s);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>将 <code>service-provider-interface</code> 的 jar 导入项目中。</p><p>实现 <code>Logger</code> 接口，在 <code>src</code> 目录下新建 <code>META-INF/services</code> 文件夹，然后新建文件 <code>cn.bgroot.up.spi.Logger</code> （SPI 的全类名），文件里面的内容是：<code>cn.bgroot.up.spi.service.Logback</code> （Logback 的全类名，即 SPI 的实现类的包名 + 类名）。</p><h3 id="结果展示"><a href="#结果展示" class="headerlink" title="结果展示"></a>结果展示</h3><p>为了更直观的展示效果，我这里再新建一个专门用来测试的工程项目：<code>java-spi-test</code></p><p>然后先导入 <code>Logger</code> 的接口 jar 包，再导入具体的实现类的 jar 包。</p><img src="https://s2.loli.net/2023/04/20/quYpAkBsiP7GdfO.jpg" srcset="/img/loading.gif" lazyload style="zoom:50%"><p>新建 Main 方法测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> cn.bgroot.up.spi.LoggerService;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestJavaSPI</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">LoggerService</span> <span class="hljs-variable">loggerService</span> <span class="hljs-operator">=</span> LoggerService.getService();<br>        loggerService.info(<span class="hljs-string">&quot;你好&quot;</span>);<br>        loggerService.debug(<span class="hljs-string">&quot;测试Java SPI 机制&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">Logback <span class="hljs-built_in">info</span> 打印日志：你好<br>Logback <span class="hljs-built_in">debug</span> 打印日志：测试Java SPI 机制<br></code></pre></td></tr></table></figure><p>通过使用 SPI 机制，可以看出服务（<code>LoggerService</code>）和 服务提供者两者之间的耦合度非常低，如果说我们想要换一种实现，那么其实只需要修改 <code>service-provider</code> 项目中针对 <code>Logger</code> 接口的具体实现就可以了，只需要换一个 jar 包即可，也可以有在一个项目里面有多个实现，这不就是 SLF4J 原理吗？</p><p>如果某一天需求变更了，此时需要将日志输出到消息队列，或者做一些别的操作，这个时候完全不需要更改 Logback 的实现，只需要新增一个服务实现（service-provider）可以通过在本项目里面新增实现也可以从外部引入新的服务实现 jar 包。我们可以在服务(LoggerService)中选择一个具体的 服务实现(service-provider) 来完成我们需要的操作。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="ServiceLoader-具体实现"><a href="#ServiceLoader-具体实现" class="headerlink" title="ServiceLoader 具体实现"></a>ServiceLoader 具体实现</h3><p>想要使用 Java 的 SPI 机制是需要依赖 <code>ServiceLoader</code> 来实现的，那么我们接下来看看 <code>ServiceLoader</code> 具体是怎么做的：</p><p><code>ServiceLoader</code> 是 JDK 提供的一个工具类， 位于<code>package java.util;</code>包下。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">//官方注释：一种加载服务实现的工具。<br>A facility to load implementations of a service.<br></code></pre></td></tr></table></figure><p>这个类是一个 <code>final</code> 类型的，所以是不可被继承修改，同时它实现了 <code>Iterable</code> 接口。之所以实现了迭代器，是为了方便后续我们能够通过迭代的方式得到对应的服务实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ServiceLoader</span>&lt;S&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Iterable</span>&lt;S&gt;&#123; xxx...&#125;<br></code></pre></td></tr></table></figure><p>可以看到一个熟悉的常量定义：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> PREFIX = <span class="hljs-string">&quot;META-INF/services/&quot;</span>;<br></code></pre></td></tr></table></figure><p>下面是 <code>load</code> 方法：可以发现 <code>load</code> 方法支持两种重载后的入参；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(Class&lt;S&gt; service)</span> &#123;<br>    <span class="hljs-type">ClassLoader</span> <span class="hljs-variable">cl</span> <span class="hljs-operator">=</span> Thread.currentThread().getContextClassLoader();<br>    <span class="hljs-keyword">return</span> ServiceLoader.load(service, cl);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(Class&lt;S&gt; service,</span><br><span class="hljs-params">                                        ClassLoader loader)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServiceLoader</span>&lt;&gt;(service, loader);<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-title function_">ServiceLoader</span><span class="hljs-params">(Class&lt;S&gt; svc, ClassLoader cl)</span> &#123;<br>    service = Objects.requireNonNull(svc, <span class="hljs-string">&quot;Service interface cannot be null&quot;</span>);<br>    loader = (cl == <span class="hljs-literal">null</span>) ? ClassLoader.getSystemClassLoader() : cl;<br>    acc = (System.getSecurityManager() != <span class="hljs-literal">null</span>) ? AccessController.getContext() : <span class="hljs-literal">null</span>;<br>    reload();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">reload</span><span class="hljs-params">()</span> &#123;<br>    providers.clear();<br>    lookupIterator = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LazyIterator</span>(service, loader);<br>&#125;<br></code></pre></td></tr></table></figure><p>根据代码的调用顺序，在 <code>reload()</code> 方法中是通过一个内部类 <code>LazyIterator</code> 实现的。先继续往下面看。</p><p><code>ServiceLoader</code> 实现了 <code>Iterable</code> 接口的方法后，具有了迭代的能力，在这个 <code>iterator</code> 方法被调用时，首先会在 <code>ServiceLoader</code> 的 <code>Provider</code> 缓存中进行查找，如果缓存中没有命中那么则在 <code>LazyIterator</code> 中进行查找。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Iterator&lt;S&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Iterator</span>&lt;S&gt;() &#123;<br><br>        Iterator&lt;Map.Entry&lt;String, S&gt;&gt; knownProviders<br>                = providers.entrySet().iterator();<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (knownProviders.hasNext())<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">return</span> lookupIterator.hasNext(); <span class="hljs-comment">// 调用 LazyIterator</span><br>        &#125;<br><br>        <span class="hljs-keyword">public</span> S <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (knownProviders.hasNext())<br>                <span class="hljs-keyword">return</span> knownProviders.next().getValue();<br>            <span class="hljs-keyword">return</span> lookupIterator.next(); <span class="hljs-comment">// 调用 LazyIterator</span><br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>        &#125;<br><br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>在调用 <code>LazyIterator</code> 时，具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNext</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (acc == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> hasNextService();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        PrivilegedAction&lt;Boolean&gt; action = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Boolean&gt;() &#123;<br>            <span class="hljs-keyword">public</span> Boolean <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> hasNextService();<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> AccessController.doPrivileged(action, acc);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasNextService</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (nextName != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (configs == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//通过PREFIX（META-INF/services/）和类名 获取对应的配置文件，得到具体的实现类</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">fullName</span> <span class="hljs-operator">=</span> PREFIX + service.getName();<br>            <span class="hljs-keyword">if</span> (loader == <span class="hljs-literal">null</span>)<br>                configs = ClassLoader.getSystemResources(fullName);<br>            <span class="hljs-keyword">else</span><br>                configs = loader.getResources(fullName);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException x) &#123;<br>            fail(service, <span class="hljs-string">&quot;Error locating configuration files&quot;</span>, x);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> ((pending == <span class="hljs-literal">null</span>) || !pending.hasNext()) &#123;<br>        <span class="hljs-keyword">if</span> (!configs.hasMoreElements()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        pending = parse(service, configs.nextElement());<br>    &#125;<br>    nextName = pending.next();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> S <span class="hljs-title function_">next</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (acc == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> nextService();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        PrivilegedAction&lt;S&gt; action = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;S&gt;() &#123;<br>            <span class="hljs-keyword">public</span> S <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">return</span> nextService();<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> AccessController.doPrivileged(action, acc);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> S <span class="hljs-title function_">nextService</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!hasNextService())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NoSuchElementException</span>();<br>    <span class="hljs-type">String</span> <span class="hljs-variable">cn</span> <span class="hljs-operator">=</span> nextName;<br>    nextName = <span class="hljs-literal">null</span>;<br>    Class&lt;?&gt; c = <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        c = Class.forName(cn, <span class="hljs-literal">false</span>, loader);<br>    &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException x) &#123;<br>        fail(service,<br>                <span class="hljs-string">&quot;Provider &quot;</span> + cn + <span class="hljs-string">&quot; not found&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!service.isAssignableFrom(c)) &#123;<br>        fail(service,<br>                <span class="hljs-string">&quot;Provider &quot;</span> + cn + <span class="hljs-string">&quot; not a subtype&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">S</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> service.cast(c.newInstance());<br>        providers.put(cn, p);<br>        <span class="hljs-keyword">return</span> p;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>        fail(service,<br>                <span class="hljs-string">&quot;Provider &quot;</span> + cn + <span class="hljs-string">&quot; could not be instantiated&quot;</span>,<br>                x);<br>    &#125;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>();          <span class="hljs-comment">// This cannot happen</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="自定义一个-ServiceLoader"><a href="#自定义一个-ServiceLoader" class="headerlink" title="自定义一个 ServiceLoader"></a>自定义一个 ServiceLoader</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.bingroot.service;<br><br><span class="hljs-keyword">import</span> java.io.BufferedReader;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><span class="hljs-keyword">import</span> java.io.InputStreamReader;<br><span class="hljs-keyword">import</span> java.lang.reflect.Constructor;<br><span class="hljs-keyword">import</span> java.net.URL;<br><span class="hljs-keyword">import</span> java.net.URLConnection;<br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Enumeration;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServiceLoader</span>&lt;S&gt; &#123;<br><br>    <span class="hljs-comment">// 对应的接口 Class 模板</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Class&lt;S&gt; service;<br><br>    <span class="hljs-comment">// 对应实现类的 可以有多个，用 List 进行封装</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;S&gt; providers = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br><br>    <span class="hljs-comment">// 类加载器</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader classLoader;<br><br>    <span class="hljs-comment">// 暴露给外部使用的方法，通过调用这个方法可以开始加载自己定制的实现流程。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;S&gt; MyServiceLoader&lt;S&gt; <span class="hljs-title function_">load</span><span class="hljs-params">(Class&lt;S&gt; service)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyServiceLoader</span>&lt;&gt;(service);<br>    &#125;<br><br>    <span class="hljs-comment">// 构造方法私有化</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MyServiceLoader</span><span class="hljs-params">(Class&lt;S&gt; service)</span> &#123;<br>        <span class="hljs-built_in">this</span>.service = service;<br>        <span class="hljs-built_in">this</span>.classLoader = Thread.currentThread().getContextClassLoader();<br>        doLoad();<br>    &#125;<br><br>    <span class="hljs-comment">// 关键方法，加载具体实现类的逻辑</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doLoad</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 读取所有 jar 包里面 META-INF/services 包下面的文件，这个文件名就是接口名，然后文件里面的内容就是具体的实现类的路径加全类名</span><br>            Enumeration&lt;URL&gt; urls = classLoader.getResources(<span class="hljs-string">&quot;META-INF/services/&quot;</span> + service.getName());<br>            <span class="hljs-comment">// 挨个遍历取到的文件</span><br>            <span class="hljs-keyword">while</span> (urls.hasMoreElements()) &#123;<br>                <span class="hljs-comment">// 取出当前的文件</span><br>                <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> urls.nextElement();<br>                System.out.println(<span class="hljs-string">&quot;File = &quot;</span> + url.getPath());<br>                <span class="hljs-comment">// 建立链接</span><br>                <span class="hljs-type">URLConnection</span> <span class="hljs-variable">urlConnection</span> <span class="hljs-operator">=</span> url.openConnection();<br>                urlConnection.setUseCaches(<span class="hljs-literal">false</span>);<br>                <span class="hljs-comment">// 获取文件输入流</span><br>                <span class="hljs-type">InputStream</span> <span class="hljs-variable">inputStream</span> <span class="hljs-operator">=</span> urlConnection.getInputStream();<br>                <span class="hljs-comment">// 从文件输入流获取缓存</span><br>                <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">bufferedReader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InputStreamReader</span>(inputStream));<br>                <span class="hljs-comment">// 从文件内容里面得到实现类的全类名</span><br>                <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> bufferedReader.readLine();<br><br>                <span class="hljs-keyword">while</span> (className != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 通过反射拿到实现类的实例</span><br>                    Class&lt;?&gt; clazz = Class.forName(className, <span class="hljs-literal">false</span>, classLoader);<br>                    <span class="hljs-comment">// 如果声明的接口跟这个具体的实现类是属于同一类型，（可以理解为Java的一种多态，接口跟实现类、父类和子类等等这种关系。）则构造实例</span><br>                    <span class="hljs-keyword">if</span> (service.isAssignableFrom(clazz)) &#123;<br>                        Constructor&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">S</span>&gt; constructor = (Constructor&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">S</span>&gt;) clazz.getConstructor();<br>                        <span class="hljs-type">S</span> <span class="hljs-variable">instance</span> <span class="hljs-operator">=</span> constructor.newInstance();<br>                        <span class="hljs-comment">// 把当前构造的实例对象添加到 Provider的列表里面</span><br>                        providers.add(instance);<br>                    &#125;<br>                    <span class="hljs-comment">// 继续读取下一行的实现类，可以有多个实现类，只需要换行就可以了。</span><br>                    className = bufferedReader.readLine();<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;读取文件异常。。。&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 返回spi接口对应的具体实现类列表</span><br>    <span class="hljs-keyword">public</span> List&lt;S&gt; <span class="hljs-title function_">getProviders</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> providers;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>关键信息基本已经通过代码注释描述出来了，</p><p>主要的流程就是：</p><ol><li>通过 URL 工具类从 jar 包的 <code>/META-INF/services</code> 目录下面找到对应的文件，</li><li>读取这个文件的名称找到对应的 spi 接口，</li><li>通过 <code>InputStream</code> 流将文件里面的具体实现类的全类名读取出来，</li><li>根据获取到的全类名，先判断跟 spi 接口是否为同一类型，如果是的，那么就通过反射的机制构造对应的实例对象，</li><li>将构造出来的实例对象添加到 <code>Providers</code> 的列表中。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>其实不难发现，SPI 机制的具体实现本质上还是通过反射完成的。即：<strong>我们按照规定将要暴露对外使用的具体实现类在 <code>META-INF/services/</code> 文件下声明。</strong></p><p>另外，SPI 机制在很多框架中都有应用：Spring 框架的基本原理也是类似的反射。还有 Dubbo 框架提供同样的 SPI 扩展机制，只不过 Dubbo 和 spring 框架中的 SPI 机制具体实现方式有些细微的区别，不过整体的原理都是一致的。</p><p>通过 SPI 机制能够大大地提高接口设计的灵活性，但是 SPI 机制也存在一些缺点，比如：</p><ol><li>遍历加载所有的实现类，这样效率还是相对较低的；</li><li>当多个 <code>ServiceLoader</code> 同时 <code>load</code> 时，会有并发问题。</li></ol><h1 id="Spring-SPI"><a href="#Spring-SPI" class="headerlink" title="Spring SPI"></a>Spring SPI</h1><p>Spring SPI沿用了Java SPI的设计思想，Spring采用的是spring.factories方式实现SPI机制，可以在不修改Spring源码的前提下，提供Spring框架的扩展性。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><h3 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">DataBaseSPI</span><br>&#123;<br>   <span class="hljs-keyword">void</span> <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="相关实现"><a href="#相关实现" class="headerlink" title="相关实现"></a>相关实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MysqlDataBase</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataBaseSPI</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;this database is Mysql&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OracleDataBase</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">DataBaseSPI</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">getConnection</span><span class="hljs-params">()</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;this database is Oracle&quot;</span>);<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><p>1.在项目的META-INF目录下，新增spring.factories文件</p><img src="https://s2.loli.net/2023/04/21/D51BEikfMSZqush.png" srcset="/img/loading.gif" lazyload alt="image-20230421131031522" style="zoom:50%"><p>2.填写相关的接口信息，内容如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">cn<span class="hljs-selector-class">.groot</span><span class="hljs-selector-class">.demo</span><span class="hljs-selector-class">.spi</span><span class="hljs-selector-class">.DataBaseSPI</span> = cn<span class="hljs-selector-class">.groot</span><span class="hljs-selector-class">.demo</span><span class="hljs-selector-class">.spi</span><span class="hljs-selector-class">.MysqlDataBase</span>, cn<span class="hljs-selector-class">.groot</span><span class="hljs-selector-class">.demo</span><span class="hljs-selector-class">.spi</span>.OracleDataBase<br></code></pre></td></tr></table></figure><p>多个实现采用逗号分隔</p><h3 id="相关测试类"><a href="#相关测试类" class="headerlink" title="相关测试类"></a>相关测试类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSpringSPI</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        List&lt;DataBaseSPI&gt; dataBaseSPIs =SpringFactoriesLoader.loadFactories(DataBaseSPI.class, <br>                 Thread.currentThread().getContextClassLoader());<br>         <br>         <span class="hljs-keyword">for</span>(DataBaseSPI datBaseSPI:dataBaseSPIs)&#123;<br>            datBaseSPI.getConnection();<br>         &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出结果"><a href="#输出结果" class="headerlink" title="输出结果"></a>输出结果</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span> database <span class="hljs-keyword">is</span> Mysql<br><span class="hljs-keyword">this</span> database <span class="hljs-keyword">is</span> Oracle<br></code></pre></td></tr></table></figure><p>从示例中我们看出，Spring 采用 <code>spring.factories</code> 实现SPI与java实现SPI非常相似，但是 spring 的 spi 方式针对 java 的 spi 进行的相关优化具体内容如下：</p><ul><li>Java SPI是一个服务提供接口对应一个配置文件，配置文件中存放当前接口的所有实现类，多个服务提供接口对应多个配置文件，所有配置都在services目录下；</li><li>Spring factories SPI是一个 spring.factories 配置文件存放多个接口及对应的实现类，以接口全限定名作为key，实现类作为value来配置，多个实现类用逗号隔开，仅spring.factories一个配置文件。</li></ul><p>那么 spring 是如何通过加载 spring.factories 来实现 SPI 的呢?我们可以通过源码来进一步分析。</p><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; List&lt;T&gt; <span class="hljs-title function_">loadFactories</span><span class="hljs-params">(Class&lt;T&gt; factoryType, <span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> &#123;<br>		Assert.notNull(factoryType, <span class="hljs-string">&quot;&#x27;factoryType&#x27; must not be null&quot;</span>);<br>		<span class="hljs-type">ClassLoader</span> <span class="hljs-variable">classLoaderToUse</span> <span class="hljs-operator">=</span> classLoader;<br>		<span class="hljs-keyword">if</span> (classLoaderToUse == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 确定类加载器</span><br>			classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();<br>		&#125;<br>    	<span class="hljs-comment">// 	核心逻辑 解析和加载META-INF下的文件</span><br>		List&lt;String&gt; factoryImplementationNames = loadFactoryNames(factoryType, classLoaderToUse);<br>		<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>			logger.trace(<span class="hljs-string">&quot;Loaded [&quot;</span> + factoryType.getName() + <span class="hljs-string">&quot;] names: &quot;</span> + factoryImplementationNames);<br>		&#125;<br>		List&lt;T&gt; result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(factoryImplementationNames.size());<br>		<span class="hljs-keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;<br>            <span class="hljs-comment">// 反射实例化对象</span><br>			result.add(instantiateFactory(factoryImplementationName, factoryType, classLoaderToUse));<br>		&#125;<br>		AnnotationAwareOrderComparator.sort(result);<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br></code></pre></td></tr></table></figure><p>说明:<code>loadFactoryNames</code>解析 spring.factories 文件中指定接口的实现类的全限定名，具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; <span class="hljs-title function_">loadSpringFactories</span><span class="hljs-params">(ClassLoader classLoader)</span> &#123;<br>	Map&lt;String, List&lt;String&gt;&gt; result = cache.get(classLoader);<br>	<span class="hljs-keyword">if</span> (result != <span class="hljs-literal">null</span>) &#123;<br>		<span class="hljs-keyword">return</span> result;<br>	&#125;<br><br>	result = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>	<span class="hljs-keyword">try</span> &#123;<br>           <span class="hljs-comment">//获取所有Jar包中META-INF/spring.factories文件路径，以枚举值返回</span><br>		Enumeration&lt;URL&gt; urls = classLoader.getResources(FACTORIES_RESOURCE_LOCATION);<br>		<span class="hljs-keyword">while</span> (urls.hasMoreElements()) &#123;<br>			<span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> urls.nextElement();<br>			<span class="hljs-type">UrlResource</span> <span class="hljs-variable">resource</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UrlResource</span>(url);<br>			<span class="hljs-type">Properties</span> <span class="hljs-variable">properties</span> <span class="hljs-operator">=</span> PropertiesLoaderUtils.loadProperties(resource);<br>			<span class="hljs-keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;<br>				<span class="hljs-type">String</span> <span class="hljs-variable">factoryTypeName</span> <span class="hljs-operator">=</span> ((String) entry.getKey()).trim();<br>				String[] factoryImplementationNames =<br>						StringUtils.commaDelimitedListToStringArray((String) entry.getValue());<br>				<span class="hljs-keyword">for</span> (String factoryImplementationName : factoryImplementationNames) &#123;<br>					result.computeIfAbsent(factoryTypeName, key -&gt; <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;())<br>							.add(factoryImplementationName.trim());<br>				&#125;<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-comment">// Replace all lists with unmodifiable lists containing unique elements</span><br>		result.replaceAll((factoryType, implementations) -&gt; implementations.stream().distinct()<br>				.collect(Collectors.collectingAndThen(Collectors.toList(), Collections::unmodifiableList)));<br>		cache.put(classLoader, result);<br>	&#125;<br>	<span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Unable to load factories from location [&quot;</span> +<br>				FACTORIES_RESOURCE_LOCATION + <span class="hljs-string">&quot;]&quot;</span>, ex);<br>	&#125;<br></code></pre></td></tr></table></figure><p>说明： 获取所有jar包中META-INF&#x2F;spring.factories文件路径，以枚举值返回。 遍历spring.factories文件路径，逐个加载解析，整合factoryClass类型的实现类名称，获取到实现类的全类名称后进行类的实例话操作，其相关源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>	<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; T <span class="hljs-title function_">instantiateFactory</span><span class="hljs-params">(String factoryImplementationName, Class&lt;T&gt; factoryType, ClassLoader classLoader)</span> &#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>			Class&lt;?&gt; factoryImplementationClass = ClassUtils.forName(factoryImplementationName, classLoader);<br>			<span class="hljs-keyword">if</span> (!factoryType.isAssignableFrom(factoryImplementationClass)) &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<br>						<span class="hljs-string">&quot;Class [&quot;</span> + factoryImplementationName + <span class="hljs-string">&quot;] is not assignable to factory type [&quot;</span> + factoryType.getName() + <span class="hljs-string">&quot;]&quot;</span>);<br>			&#125;<br>			<span class="hljs-keyword">return</span> (T) ReflectionUtils.accessibleConstructor(factoryImplementationClass).newInstance();<br>		&#125;<br>		<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<br>				<span class="hljs-string">&quot;Unable to instantiate factory class [&quot;</span> + factoryImplementationName + <span class="hljs-string">&quot;] for factory type [&quot;</span> + factoryType.getName() + <span class="hljs-string">&quot;]&quot;</span>,<br>				ex);<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure><p>说明：实例化是通过反射来实现对应的初始化。</p><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><p>Spring SPI通过 <code>loadFactoryNames</code>遍历spring.factories文件路径，找到接口的实现类（整合factoryClass类型的实现类名称，获取到实现类的全类名），最后通过反射实例化相应的实现类。</p><h1 id="Dubbo-SPI"><a href="#Dubbo-SPI" class="headerlink" title="Dubbo SPI"></a>Dubbo SPI</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>Dubbo良好的扩展性与两个方面是密不可分的，一是整个框架中针对不同的场景，恰到好处地使用了各种设计模式，二就是SPI加载机制。基于DubboSPI加载机制，让整个框架的接口和具体实现完全解耦，从而奠定了整个框架良好可扩展性的基础。</p><blockquote><p>Dubbo 改进了 JDK 标准的 SPI 的以下问题：</p><ul><li>JDK 标准的 SPI 会一次性实例化扩展点所有实现，如果有扩展实现初始化很耗时，但如果没用上也加载，会很浪费资源。</li><li>如果扩展点加载失败，连扩展点的名称都拿不到了。比如：JDK 标准的 ScriptEngine，通过 <code>getName()</code> 获取脚本类型的名称，但如果 RubyScriptEngine 因为所依赖的 jruby.jar 不存在，导致 RubyScriptEngine 类加载失败，这个失败原因被吃掉了，和 ruby 对应不起来，当用户执行 ruby 脚本时，会报不支持 ruby，而不是真正失败的原因。</li><li>增加了对扩展点 IoC 和 AOP 的支持，一个扩展点可以直接 setter 注入其它扩展点。</li></ul></blockquote><p><strong>约定</strong>：在扩展类的 jar 包内，放置扩展点配置文件 <code>META-INF/dubbo/接口全限定名</code>，内容为：<code>配置名=扩展实现类全限定名</code>，多个实现类用换行符分隔。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="自动包装"><a href="#自动包装" class="headerlink" title="自动包装"></a>自动包装</h3><p>自动包装扩展点的 Wrapper 类。<code>ExtensionLoader</code> 在加载扩展点时，如果加载到的扩展点有拷贝构造函数，则判定为扩展点 Wrapper 类。</p><p>Wrapper类内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.alibaba.xxx;<br> <br><span class="hljs-keyword">import</span> org.apache.dubbo.rpc.Protocol;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XxxProtocolWrapper</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Protocol</span> &#123;<br>    Protocol impl;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">XxxProtocolWrapper</span><span class="hljs-params">(Protocol protocol)</span> &#123; impl = protocol; &#125;<br> <br>    <span class="hljs-comment">// 接口方法做一个操作后，再调用extension的方法</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refer</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//... 一些操作</span><br>        impl.refer();<br>        <span class="hljs-comment">// ... 一些操作</span><br>    &#125;<br> <br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Wrapper 类同样实现了扩展点接口，但是 Wrapper 不是扩展点的真正实现。它的用途主要是用于从 <code>ExtensionLoader</code> 返回扩展点时，包装在真正的扩展点实现外。即从 <code>ExtensionLoader</code> 中返回的实际上是 Wrapper 类的实例，Wrapper 持有了实际的扩展点实现类。</p><p>扩展点的 Wrapper 类可以有多个，也可以根据需要新增。</p><p>通过 Wrapper 类可以把所有扩展点公共逻辑移至 Wrapper 中。新加的 Wrapper 在所有的扩展点上添加了逻辑，有些类似 AOP，即 Wrapper 代理了扩展点。</p><h3 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a>自动装配</h3><p>加载扩展点时，自动注入依赖的扩展点。加载扩展点时，扩展点实现类的成员如果为其它扩展点类型，<code>ExtensionLoader</code> 在会自动注入依赖的扩展点。<code>ExtensionLoader</code> 通过扫描扩展点实现类的所有 setter 方法来判定其成员。即 <code>ExtensionLoader</code> 会执行扩展点的拼装操作。</p><p>示例：有两个为扩展点 <code>CarMaker</code>（造车者）、<code>WheelMaker</code> (造轮者)</p><p>接口类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CarMaker</span> &#123;<br>    Car <span class="hljs-title function_">makeCar</span><span class="hljs-params">()</span>;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">WheelMaker</span> &#123;<br>    Wheel <span class="hljs-title function_">makeWheel</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CarMaker</code> 的一个实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RaceCarMaker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CarMaker</span> &#123;<br>    WheelMaker wheelMaker;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWheelMaker</span><span class="hljs-params">(WheelMaker wheelMaker)</span> &#123;<br>        <span class="hljs-built_in">this</span>.wheelMaker = wheelMaker;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> Car <span class="hljs-title function_">makeCar</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-type">Wheel</span> <span class="hljs-variable">wheel</span> <span class="hljs-operator">=</span> wheelMaker.makeWheel();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RaceCar</span>(wheel, ...);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ExtensionLoader</code> 加载 <code>CarMaker</code> 的扩展点实现 <code>RaceCarMaker</code> 时，<code>setWheelMaker</code> 方法的 <code>WheelMaker</code> 也是扩展点则会注入 <code>WheelMaker</code> 的实现。</p><p>这里带来另一个问题，<code>ExtensionLoader</code> 要注入依赖扩展点时，如何决定要注入依赖扩展点的哪个实现。在这个示例中，即是在多个<code>WheelMaker</code> 的实现中要注入哪个。</p><h3 id="自适应"><a href="#自适应" class="headerlink" title="自适应"></a>自适应</h3><p><code>ExtensionLoader</code> 注入的依赖扩展点是一个 <code>Adaptive</code> 实例，直到扩展点方法执行时才决定调用是哪一个扩展点实现。</p><p>Dubbo 使用 URL 对象（包含了Key-Value）传递配置信息。</p><p>扩展点方法调用会有URL参数（或是参数有URL成员）</p><p>这样依赖的扩展点也可以从URL拿到配置信息，所有的扩展点自己定好配置的Key后，配置信息从URL上从最外层传入。URL在配置传递上即是一条总线。</p><p>示例：有两个为扩展点 <code>CarMaker</code>、<code>WheelMaker</code></p><p>接口类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">CarMaker</span> &#123;<br>    Car <span class="hljs-title function_">makeCar</span><span class="hljs-params">(URL url)</span>;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">WheelMaker</span> &#123;<br>    Wheel <span class="hljs-title function_">makeWheel</span><span class="hljs-params">(URL url)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>CarMaker</code> 的一个实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RaceCarMaker</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CarMaker</span> &#123;<br>    WheelMaker wheelMaker;<br> <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setWheelMaker</span><span class="hljs-params">(WheelMaker wheelMaker)</span> &#123;<br>        <span class="hljs-built_in">this</span>.wheelMaker = wheelMaker;<br>    &#125;<br> <br>    <span class="hljs-keyword">public</span> Car <span class="hljs-title function_">makeCar</span><span class="hljs-params">(URL url)</span> &#123;<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-type">Wheel</span> <span class="hljs-variable">wheel</span> <span class="hljs-operator">=</span> wheelMaker.makeWheel(url);<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RaceCar</span>(wheel, ...);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当上面执行 <code>Wheel wheel = wheelMaker.makeWheel(url);</code>时，注入的 <code>Adaptive</code> 实例可以提取事先定义好的 Key 来决定使用哪个 <code>WheelMaker</code> 实现来调用对应实现的真正的 <code>makeWheel</code> 方法。如提取 <code>wheel.type</code> Key，即 <code>url.get(&quot;wheel.type&quot;)</code> 来决定 <code>WheelMaker</code> 实现。<code>Adaptive</code> 实例的逻辑是固定的，从 URL 中提取事先定义好的 Key，动态生成真正的实现并执行它。</p><p><code>ExtensionLoader</code> 里面的扩展点注入的 <code>Adaptive</code> 实现是在dubbo加载扩展点时动态生成的。Key是从URL中获取的，而URL中Key的值是在扩展点接口的方法定义上通过@Adaptive注解提供的。</p><p>下面是 Dubbo 的 Transporter 扩展点的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Transporter</span> &#123;<br>    <span class="hljs-meta">@Adaptive(&#123;&quot;server&quot;, &quot;transport&quot;&#125;)</span><br>    Server <span class="hljs-title function_">bind</span><span class="hljs-params">(URL url, ChannelHandler handler)</span> <span class="hljs-keyword">throws</span> RemotingException;<br> <br>    <span class="hljs-meta">@Adaptive(&#123;&quot;client&quot;, &quot;transport&quot;&#125;)</span><br>    Client <span class="hljs-title function_">connect</span><span class="hljs-params">(URL url, ChannelHandler handler)</span> <span class="hljs-keyword">throws</span> RemotingException;<br>&#125;<br></code></pre></td></tr></table></figure><p>对于 bind() 方法，Adaptive 实现先查找 <code>server</code> key，如果该 Key 没有值则找 <code>transport</code> key 值，来决定代理到哪个实际扩展点。</p><h3 id="自动激活"><a href="#自动激活" class="headerlink" title="自动激活"></a>自动激活</h3><p>对于集合类扩展点，比如：<code>Filter</code>, <code>InvokerListener</code>, <code>ExportListener</code>, <code>TelnetHandler</code>, <code>StatusChecker</code> 等，可以同时加载多个实现，此时，可以用自动激活来简化配置，如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.dubbo.common.extension.Activate;<br><span class="hljs-keyword">import</span> org.apache.dubbo.rpc.Filter;<br> <br><span class="hljs-meta">@Activate</span> <span class="hljs-comment">// 无条件自动激活</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XxxFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-meta">@Activate(&quot;xxx&quot;)</span> <span class="hljs-comment">// 当配置了xxx参数，并且参数为有效值时激活，比如配了cache=&quot;lru&quot;，自动激活CacheFilter。</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XxxFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br><br><span class="hljs-meta">@Activate(group = &quot;provider&quot;, value = &quot;xxx&quot;)</span> <span class="hljs-comment">// 只对提供方激活，group可选&quot;provider&quot;或&quot;consumer&quot;</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">XxxFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Filter</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>注意：这里的配置文件是放在你自己的 jar 包内，不是 dubbo 本身的 jar 包内，Dubbo 会全 ClassPath 扫描所有 jar 包内同名的这个文件，然后进行合并</li><li>注意：扩展点使用单一实例加载（请确保扩展实现的线程安全性），缓存在 <code>ExtensionLoader</code> 中</li></ol><blockquote><p>参考</p><p>https:&#x2F;&#x2F;<span></span>javaguide.cn&#x2F;java&#x2F;basis&#x2F;spi.html</p><p>https:&#x2F;&#x2F;<span></span>juejin.cn&#x2F;post&#x2F;7132742686099898398#heading-9</p><p>https:&#x2F;&#x2F;<span></span>cn.dubbo.apache.org&#x2F;zh-cn&#x2F;docsv2.7&#x2F;dev&#x2F;spi&#x2F;</p></blockquote></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%BC%80%E5%8F%91%E6%80%9D%E6%83%B3/" class="category-chain-item">开发思想</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%9F%BA%E7%A1%80/">#基础</a></div></div><div class="license-box my-3"><div class="license-title"><div>SPI机制总结</div><div>https://beingku.github.io/1922945398/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Noah Lee</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2450508050/" title="ThreadLocal源码"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">ThreadLocal源码</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/1091987553/" title="分布式理论"><span class="hidden-mobile">分布式理论</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,debug:!1,model:{jsonPath:"/live2dw/assets/wanko.model.json"},display:{position:"left",width:150,height:300},mobile:{show:!0},react:{opacity:.7},log:!1})</script></body></html>