<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="auto"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/dinosaur.png"><link rel="icon" href="/img/dinosaur.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#2f4154"><meta name="author" content="Noah Lee"><meta name="keywords" content=""><meta name="description" content="概述为什么要学习并发编程? Java是一种广泛使用的编程语言，常用于开发大型、分布式、高并发的应用程序。在这样的应用中，多个线程同时执行任务是很常见的情况。因此，学习并发编程可以帮助Java开发人员更好地理解和处理多线程环境下的并发问题，提高程序的性能和可靠性。 具体来说，以下是Java学习并发编程的一些重要原因：  提高程序性能：并发编程可以使多个线程同时执行任务，从而提高程序的处理能力和执行效"><meta property="og:type" content="article"><meta property="og:title" content="JUC"><meta property="og:url" content="https://youzi.netlify.app/2857723967/index.html"><meta property="og:site_name" content="Youzi"><meta property="og:description" content="概述为什么要学习并发编程? Java是一种广泛使用的编程语言，常用于开发大型、分布式、高并发的应用程序。在这样的应用中，多个线程同时执行任务是很常见的情况。因此，学习并发编程可以帮助Java开发人员更好地理解和处理多线程环境下的并发问题，提高程序的性能和可靠性。 具体来说，以下是Java学习并发编程的一些重要原因：  提高程序性能：并发编程可以使多个线程同时执行任务，从而提高程序的处理能力和执行效"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://youzi.netlify.app/img/java.png"><meta property="article:published_time" content="2023-04-09T08:17:35.000Z"><meta property="article:modified_time" content="2023-04-26T04:00:10.066Z"><meta property="article:author" content="Noah Lee"><meta property="article:tag" content="基础"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:image" content="https://youzi.netlify.app/img/java.png"><meta name="referrer" content="no-referrer-when-downgrade"><title>JUC - Youzi</title><link rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css"><link rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css"><link rel="stylesheet" href="/css/main.css"><link id="highlight-css" rel="stylesheet" href="/css/highlight.css"><link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css"><script id="fluid-configs">var Fluid=window.Fluid||{};Fluid.ctx=Object.assign({},Fluid.ctx);var dntVal,CONFIG={hostname:"youzi.netlify.app",root:"/",version:"1.9.4",typing:{enable:!0,typeSpeed:70,cursorChar:"_",loop:!1,scope:[]},anchorjs:{enable:!0,element:"h1,h2,h3,h4,h5,h6",placement:"left",visible:"hover",icon:""},progressbar:{enable:!0,height_px:3,color:"#29d",options:{showSpinner:!1,trickleSpeed:100}},code_language:{enable:!1,default:"TEXT"},copy_btn:!0,image_caption:{enable:!0},image_zoom:{enable:!0,img_url_replace:["",""]},toc:{enable:!0,placement:"right",headingSelector:"h1,h2,h3,h4,h5,h6",collapseDepth:0},lazyload:{enable:!0,loading_img:"/img/loading.gif",onlypost:!1,offset_factor:2},web_analytics:{enable:!1,follow_dnt:!0,baidu:null,google:null,gtag:null,tencent:{sid:null,cid:null},woyaola:null,cnzz:null,leancloud:{app_id:null,app_key:null,server_url:null,path:"window.location.pathname",ignore_local:!1}},search_path:"/local-search.xml"};CONFIG.web_analytics.follow_dnt&&(dntVal=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,Fluid.ctx.dnt=dntVal&&(dntVal.startsWith("1")||dntVal.startsWith("yes")||dntVal.startsWith("on")))</script><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 6.3.0"></head><body><header><div class="header-inner" style="height:80vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/"><strong>Youzi</strong> </a><button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> <span>首页</span></a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> <span>归档</span></a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> <span>分类</span></a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> <span>标签</span></a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> <span>关于</span></a></li><li class="nav-item" id="search-btn"><a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle"><i class="iconfont icon-dark" id="color-toggle-icon"></i></a></li></ul></div></div></nav><div id="banner" class="banner" parallax="true" style="background:url(/img/bk02.jpg) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="banner-text text-center fade-in-up"><div class="h2"><span id="subtitle" data-typed-text="JUC"></span></div><div class="mt-3"><span class="post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2023-04-09 16:17" pubdate>2023年4月9日 下午</time></span></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 8k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 67 分钟 </span><span id="busuanzi_container_page_pv" style="display:none"><i class="iconfont icon-eye" aria-hidden="true"></i> <span id="busuanzi_value_page_pv"></span> 次</span></div></div><div class="scroll-down-bar"><i class="iconfont icon-arrowdown"></i></div></div></div></div></div></header><main><div class="container-fluid nopadding-x"><div class="row nomargin-x"><div class="side-col d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-x-md"><div class="container nopadding-x-md" id="board-ctn"><div id="board"><article class="post-content mx-auto"><h1 style="display:none">JUC</h1><div class="markdown-body"><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p><strong>为什么要学习并发编程?</strong></p><p>Java是一种广泛使用的编程语言，常用于开发大型、分布式、高并发的应用程序。在这样的应用中，多个线程同时执行任务是很常见的情况。因此，学习并发编程可以帮助Java开发人员更好地理解和处理多线程环境下的并发问题，提高程序的性能和可靠性。</p><p>具体来说，以下是Java学习并发编程的一些重要原因：</p><ol><li>提高程序性能：并发编程可以使多个线程同时执行任务，从而提高程序的处理能力和执行效率。</li><li>充分利用多核CPU：现代计算机通常具有多个CPU核心，使用并发编程可以充分利用这些核心，提高程序的并行处理能力。</li><li>避免死锁和竞态条件：多线程环境下，由于资源的共享和竞争，可能会出现死锁和竞态条件等问题。学习并发编程可以帮助开发人员避免这些问题。</li><li>实现更复杂的应用程序：并发编程可以使应用程序支持更复杂的功能，如实时数据处理、多用户交互、分布式计算等</li></ol><h2 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析"></a>概念解析</h2><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><h4 id="乐观锁-x2F-悲观锁"><a href="#乐观锁-x2F-悲观锁" class="headerlink" title="乐观锁&#x2F;悲观锁"></a>乐观锁&#x2F;悲观锁</h4><p>乐观锁：乐观的认为共享资源是安全的，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源（也就是数据）是否被其它线程修改了（具体方法可以使用版本号机制或 CAS 算法）。</p><p>悲观锁：悲观的认为共享资源是不安全的，所以要把共享资源给保护起来。<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p><p>理论上：</p><ul><li><p>悲观锁通常多用于写比较多的情况下（多写场景，竞争激烈），这样可以避免频繁失败和重试影响性能，悲观锁的开销是固定的。不过，如果乐观锁解决了频繁失败和重试这个问题的话（比如<code>LongAdder</code>），也是可以考虑使用乐观锁的，要视实际情况而定。</p></li><li><p>乐观锁通常多于写比较少的情况下（多读场景，竞争较少），这样可以避免频繁加锁影响性能。不过，乐观锁主要针对的对象是单个共享变量（参考<code>java.util.concurrent.atomic</code>包下面的原子变量类）。</p></li></ul><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>可重入锁（Reentrant Lock）是一种线程同步机制，它允许同一个线程多次获得同一个锁。在可重入锁的机制下，当一个线程已经获得了该锁后，它可以再次请求该锁而不会被自己所拥有的锁所阻塞。这样可以避免在同一个线程中出现死锁的情况。</p><h4 id="公平锁-x2F-不公平锁"><a href="#公平锁-x2F-不公平锁" class="headerlink" title="公平锁&#x2F;不公平锁"></a>公平锁&#x2F;不公平锁</h4><ul><li>公平锁：获取公共资源按照等待队列的顺序</li><li>不公平锁：可以抢公共资源，失败了再去队列排队</li></ul><h4 id="独占锁-x2F-共享锁"><a href="#独占锁-x2F-共享锁" class="headerlink" title="独占锁&#x2F;共享锁"></a>独占锁&#x2F;共享锁</h4><h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><h4 id="邮戳锁"><a href="#邮戳锁" class="headerlink" title="邮戳锁"></a>邮戳锁</h4><p>解决CAS的ABA问题，1.8新增的锁，有读写锁的功能，同时提供了乐观读的能力，如果读失败了，可以代码转成悲观读，有点copyOnwrite的思想</p><h4 id="无锁，偏向锁，轻量级锁，重量级锁"><a href="#无锁，偏向锁，轻量级锁，重量级锁" class="headerlink" title="无锁，偏向锁，轻量级锁，重量级锁"></a>无锁，偏向锁，轻量级锁，重量级锁</h4><p>参见</p><h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><p><img src="https://s2.loli.net/2023/04/25/ybgwEkxzJCAqHSt.png" srcset="/img/loading.gif" lazyload></p><p>产生死锁的四个必要条件：</p><ol><li>互斥条件：该资源任意一个时刻只由一个线程占用。</li><li>请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件:线程已获得的资源在未使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li>循环等待条件:若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><h3 id="JMM（Java-内存模型）"><a href="#JMM（Java-内存模型）" class="headerlink" title="JMM（Java 内存模型）"></a>JMM（Java 内存模型）</h3><p>JMM(Java内存模型)主要定义了对于一个共享变量，当另一个线程对这个共享变量执行写操作后，这个线程对这个共享变量的可见性。</p><h4 id="CPU-缓存模型"><a href="#CPU-缓存模型" class="headerlink" title="CPU 缓存模型"></a>CPU 缓存模型</h4><p><strong>CPU 缓存则是为了解决 CPU 处理速度和内存处理速度不对等的问题。</strong></p><img src="https://s2.loli.net/2023/04/25/5FgJD2BMtHxWO4P.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><p>总共三级缓存：<br>L1 由 CPU 逻辑核心独占（超线程技术可以让一个cpu发挥出两核的作用）<br>L2 由 CPU 物理核心独占，逻辑核心共享<br>L3 所有 CPU 物理核心共享<br>速度上，越靠近 cpu 的缓存存取速度越快。引入了缓存同时就会出现不一致的问题。</p><h4 id="缓存一致性协议EMSI"><a href="#缓存一致性协议EMSI" class="headerlink" title="缓存一致性协议EMSI"></a><strong>缓存一致性协议EMSI</strong></h4><p><strong>CPU 为了解决内存缓存不一致性问题可以通过制定缓存一致协议（比如 <a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MESI%E5%8D%8F%E8%AE%AE">MESI 协议open in new window</a>）或者其他手段来解决。</strong></p><p>通常多核并行架构的CPU，每个核虽然都独自工作，但与外部存储器的交互依然是共用同一总线进行的。通过总线，每个核心都能够监听、接收到来自其它核心的消息通知，这一机制被称为总线侦听或是总线嗅探。</p><p>MESI协议便是基于总线侦听机制，采用回写法、写传播失效策略的高速缓存一致性协议，其另一个更精确的名称是四态缓存写回无效协议。</p><p>MESI：Modified（修改），Exclusive（独占），Shared（共享），Invalid（无效）由以上数据的四种状态的首字母而来。</p><table><thead><tr><th>M(Modified)</th><th>这行数据有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。</th></tr></thead><tbody><tr><td>E(Exclusive)</td><td>这行数据有效，数据和内存中的数据一致，数据只存在于本 Cache 中。</td></tr><tr><td>S(Shared)</td><td>这行数据有效，数据和内存中的数据一致，数据存在于很多 Cache 中。</td></tr><tr><td>I(Invalid)</td><td>这行数据无效。</td></tr></tbody></table><blockquote><p>单个CPU修改了缓存后，需要通过总线机制，通知别的CPU都让缓存失效，并返回ACK的标识，才能继续执行下一个指令。<br>想要了解更多参考：<a target="_blank" rel="noopener" href="https://www.bilibili.com/read/cv15906369">https://www.bilibili.com/read/cv15906369</a></p></blockquote><h4 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a><strong>指令重排序</strong></h4><p>早期引入的 MESI 一致性协议，是能够达到一致性的效果，但是也让 CPU 的执行变得非常的慢。</p><p>不进行优化的 MESI 协议在实际工作中效率会非常的低下，因此CPU的设计者们在实现 MESI 协议进行了优化</p><img src="https://s2.loli.net/2023/04/25/bvdylMAZ8mGWEHX.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><h5 id="存储缓存-Store-Bufferes"><a href="#存储缓存-Store-Bufferes" class="headerlink" title="存储缓存(Store Bufferes)"></a><code>存储缓存(Store Bufferes)</code></h5><p>针对本地写事件需要等待远端核心ACK确认，阻塞本地处理器的问题，引入了存储缓存机制。</p><p>存储缓存的引入将本地写事件—&gt;等待远程写通知确认消息并提交这一事务，从同步、强一致性变成了异步、最终一致性，提高了本地写事件的处理效率。</p><blockquote><p>本地处理器在进行本地读事件时，由于可能存储缓存中新修改的数据还未提交到本地缓存中，这就会造成一个核心内，对于同一缓存行其后续指令的读操作无法读取到之前写操作的最新值。为此，在进行本地读操作时，处理器会先在存储缓存中查询对应记录是否存在，如果存在则会从存储缓存中直接获取，这一机制被称为Store Fowarding。</p></blockquote><h5 id="失效队列-Invalid-Queue"><a href="#失效队列-Invalid-Queue" class="headerlink" title="失效队列(Invalid Queue)"></a><code>失效队列(Invalid Queue)</code></h5><p>针对上述远端核心响应远程写事件，实时的将对应缓存行设置为Invalid无效状态延迟高的问题，引入了失效队列机制。</p><h5 id="CPU指令重排的原因（运行时重排序）"><a href="#CPU指令重排的原因（运行时重排序）" class="headerlink" title="CPU指令重排的原因（运行时重排序）"></a>CPU指令重排的原因（运行时重排序）</h5><p>我们常说的指令重排，并不是编译器把代码的顺序打乱了。而是cpu执行一条指令后，可能需要等待其他cpu缓存失效的这段时间非常耗时，为了提高cpu的使用率，增加了存储缓存和失效队列后。cpu执行一个指令可以只执行一半，把结果扔到store buffer中，就去继续执行下一条，导致的指令执行顺序错乱。（运行时重排序）</p><h5 id="编译期重排序"><a href="#编译期重排序" class="headerlink" title="编译期重排序"></a>编译期重排序</h5><p>编译期重排序的典型就是通过调整指令顺序，在不改变程序语义的前提下，尽可能减少寄存器的读取、存储次数，充分复用寄存器的存储值。</p><h5 id="重排序对于流水线的意义"><a href="#重排序对于流水线的意义" class="headerlink" title="重排序对于流水线的意义"></a>重排序对于流水线的意义</h5><p>现代CPU几乎都采用流水线机制加快指令的处理速度，一般来说，一条指令需要若干个CPU时钟周期处理，而通过流水线并行执行，可以在同等的时钟周期内执行若干条指令。</p><blockquote><p>流水线架构决定了指令应该被并行执行，而不是在顺序化模型中所认为的那样。重排序有利于充分使用流水线，进而达到超标量的效果。</p></blockquote><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>原始的<code>MESI协议</code>保证了一致性，但是大大的影响了效率。因此引入了<code>store bufferes</code> 和<code>invalid queues</code>，由强一致性变成了最终一致性。并且还带来了指令重排的风险。</p><h4 id="内存屏障（Memory-Barrier）"><a href="#内存屏障（Memory-Barrier）" class="headerlink" title="内存屏障（Memory Barrier）"></a>内存屏障（Memory Barrier）</h4><p>上述内容中，我们发现了强一致性会极大的影响性能，但是上层又有一致性的需求。因此CPU将一致性的决定权交给了程序员，约束一致性的方式，就叫<strong>内存屏障</strong>，我们只会在需要的时候设置内存屏障。</p><blockquote><p>在java中这个加入内存屏障的命令就是volatile关键字。 澄清一点，volatile并不是仅仅加入内存屏障这么简单，加入内存屏障只是volatile内核指令级别的内存语义。 除此之外：volatile还可以禁止编译器的指令重排，因为JVM为了优化性能并且不违反happens-before原则的前提下也会进行指令重排。</p></blockquote><p>CPU提供的内存屏障分为读屏障和写屏障两种，内存屏障以机器指令的形式进行工作。</p><p>写屏障(Store Memory Barrier)</p><pre><code class="hljs">1. 写屏障用于保证高速缓存间写事务的强一致性。当CPU执行写屏障指令时，必须强制等待存储缓存中的写事务全部处理完再继续执行后面的指令。相当于将存储缓存中异步处理的本地写事务做了强一致的同步。
1. 写屏障指令执行完后，当前核心位于写屏障执行前的本地写事务全部处理完毕，其它的核心都已经接收到了当前所有的远程写事件的写无效通知。
</code></pre><p>读屏障(Load Memory Barrier)</p><ol><li><p>读屏障用于保证高速缓存间读事务的强一致性。当CPU执行读屏障指令时，必须先将当前处于失效队列中的写无效事务全部处理完，再继续的执行读屏障后面的指令。相当于将异步队列中异步处理的远程写事务做了强一致的同步。</p></li><li><p>读屏障指令执行完后，当前核心位于读屏障执行前的远程写无效事务全部处理完毕，对于读屏障之后的共享数据读取会得到最新的值。</p></li></ol><div class="note note-warning"><p>⚠️读前加读屏障，确保其他核心的最新改动我们都能知晓，写后加写屏障，确保我们修改的数据通知到其他核心</p></div><p>通过在指令中的适当位置加入读&#x2F;写内存屏障，虽然一定程度上降低了效率，但保证了并发程序在多核高速缓存条件下对于共享变量的可见性，是一个很好的折中解决方案。</p><h4 id="JMM-Java-Memory-Model"><a href="#JMM-Java-Memory-Model" class="headerlink" title="JMM(Java Memory Model)"></a>JMM(Java Memory Model)</h4><p>在没有内存屏障的情况下，cpu执行指令会出现不可见，顺序错乱等一系列问题，而这些问题CPU不会解决，而是开放了接口，让程序员或者编译器来解决。</p><p>为了让开发者能够更加专注于业务功能，屏蔽头疼的底层指令问题。因此有了JMM规范。</p><blockquote><p>该模型就是一套规范，对上，是JVM和开发者之间的协定，对下，是JVM和编译器以及CPU之间的协定。</p><p><code>happens-before</code> 原则的诞生是为了程序员和编译器、处理器之间的平衡。程序员追求的是易于理解和编程的强内存模型，遵守既定规则编码即可。编译器和处理器追求的是较少约束的弱内存模型，让它们尽己所能地去优化性能，让性能最大化。happens-before 原则的设计思想其实非常简单：</p><ul><li>为了对编译器和处理器的约束尽可能少，只要不改变程序的执行结果（单线程程序和正确执行的多线程程序），编译器和处理器怎么进行重排序优化都行。</li><li>对于会改变程序执行结果的重排序，JMM 要求编译器和处理器必须禁止这种重排序。</li></ul></blockquote><p>《Java 并发编程的艺术》这本书中的一张 JMM 设计思想的示意图</p><img src="https://s2.loli.net/2023/04/25/YHpysZdKFrgvea8.png" srcset="/img/loading.gif" lazyload style="zoom:80%"><p>JMM为了解决可见性，有序性，原子性等问题。有了 hapens before 规则。</p><ol><li><strong>程序顺序规则</strong> ：一个线程内，按照代码顺序，书写在前面的操作 happens-before 于书写在后面的操作；</li><li><strong>解锁规则</strong> ：解锁 happens-before 于加锁；</li><li><strong>volatile 变量规则</strong> ：对一个 volatile 变量的写操作 happens-before 于后面对这个 volatile 变量的读操作。说白了就是对 volatile 变量的写操作的结果对于发生于其后的任何操作都是可见的。</li><li><strong>传递规则</strong> ：如果 A happens-before B，且 B happens-before C，那么 A happens-before C；</li><li><strong>线程启动规则</strong> ：Thread 对象的 <code>start()</code>方法 happens-before 于此线程的每一个动作。</li></ol><p>如果两个操作不满足上述任意一个 happens-before 规则，那么这两个操作就没有顺序的保障，JVM 可以对这两个操作进行重排序。</p><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p><code>volatile</code> 关键字其实并非是 Java 语言特有的，在 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 <code>volatile</code> 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。<code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</p><ul><li>禁止指令进行重排序优化</li><li><code>volatile</code> 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。</li></ul><h2 id="Java的对象引用"><a href="#Java的对象引用" class="headerlink" title="Java的对象引用"></a>Java的对象引用</h2><p>• 强引用：new 出来的一般对象，只要引用在就不会被回收</p><p>• 软引用: 将要发生内存溢出之前回收</p><p>• 弱引用: 生存到下一次垃圾收集发生之前</p><p>• 虚引用：目的是对象被收集器回收时收到一个系统通知</p><h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><h2 id="Java线程与操作系统线程"><a href="#Java线程与操作系统线程" class="headerlink" title="Java线程与操作系统线程"></a>Java线程与操作系统线程</h2><p>Java线程和操作系统的线程基本上是一一对应的关系。</p><img src="https://s2.loli.net/2023/04/25/mvGNuXwnRck3OET.png" srcset="/img/loading.gif" lazyload style="zoom:50%"><p>Java中调用Thread类中的start方法，然后会创建一个Java线程，在操作系统也会创建一个对应的内核线程，然后内核线程最终被调度的CPU上执行。</p><h3 id="Java线程状态"><a href="#Java线程状态" class="headerlink" title="Java线程状态"></a>Java线程状态</h3><img src="https://s2.loli.net/2023/04/25/VFmH9IoxaePMtf4.jpg" srcset="/img/loading.gif" lazyload style="zoom:50%"><p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 <code>start()</code> 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><p>当线程执行 <code>wait()</code>方法之后，线程进入 <strong>WAITING（等待）</strong> 状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态。</p><p><strong>TIMED_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 <code>sleep（long millis）</code>方法或 <code>wait（long millis）</code>方法可以将线程置于 TIMED_WAITING 状态。当超时时间结束后，线程将会返回到 RUNNABLE 状态。</p><p>当线程进入 <code>synchronized</code> 方法&#x2F;块或者调用 <code>wait</code> 后（被 <code>notify</code>）重新进入 <code>synchronized</code> 方法&#x2F;块，但是锁被其它线程占有，这个时候线程就会进入 <strong>BLOCKED（阻塞）</strong> 状态。</p><blockquote><p>blocked 状态竞争的是 moniter 锁比较特殊，所以jvm专门用了一个状态来标识，这三个阻塞状态底层对应的实际都是 waiting。</p></blockquote><p>线程在执行完了 <code>run()</code>方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p><p>解释几个命令：</p><ul><li>Thread.sleep(long millis)，一定是当前线程调用此方法，当前线程进入TIMED_WAITING状态，但不释放对象锁，millis后线程自动苏醒进入就绪状态。作用：给其它线程执行机会的最佳方式。</li><li>Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的CPU时间片，但不释放锁资源，由运行状态变为就绪状态，让OS再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()不会导致阻塞。该方法与sleep()类似，只是不能由用户指定暂停多长时间。</li><li>thread.join()&#x2F;thread.join(long millis)，当前线程里调用其它线程t的join方法，当前线程进入WAITING&#x2F;TIMED_WAITING状态，当前线程不会释放已经持有的对象锁。线程t执行完毕或者millis时间到，当前线程一般情况下进入RUNNABLE状态，也有可能进入BLOCKED状态（因为join是基于wait实现的）。</li><li>obj.wait()，当前线程调用对象的wait()方法，当前线程释放对象锁，进入等待队列。依靠notify()&#x2F;notifyAll()唤醒或者wait(long timeout) timeout时间到自动唤醒。</li><li>obj.notify()唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()唤醒在此对象监视器上等待的所有线程。</li><li>LockSupport.park()&#x2F;LockSupport.parkNanos(long nanos),LockSupport.parkUntil(long deadlines), 当前线程进入WAITING&#x2F;TIMED_WAITING状态。对比wait方法,不需要获得锁就可以让线程进入WAITING&#x2F;TIMED_WAITING状态，需要通过LockSupport.unpark(Thread thread)唤醒。</li></ul><h3 id="线程状态关系"><a href="#线程状态关系" class="headerlink" title="线程状态关系"></a><strong>线程状态关系</strong></h3><p>操作系统线程状态与Java线程状态关系：</p><img src="../../../../../Library/Application%20Support/typora-user-images/image-20230425232541127.png" srcset="/img/loading.gif" lazyload style="zoom:70%"><p>runnable状态有一部分是waiting是因为 IO阻塞在 java 的定义中就是 rannable 状态，只不过让出了cpu资源</p><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>守护线程是一类比较特殊的线程，一般用于处理一些后台的工作，比如 JDK 的垃圾回收线程。<br>我们也可以通过<code>thread.setDeamon(true)</code>来设置守护线程<br>守护线程经常用来执行后台任务，当jvm进程中没有任意一个非守护线程存活时，jvm就会退出。</p><h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal是一个将在多线程中为每一个线程创建单独的变量副本的类。每个线程都可以通过<code>set()</code>和<code>get()</code>来对这个局部变量进行操作，但不会和其他线程的局部变量进行冲突，<strong>实现了线程的数据隔离</strong></p><p>在探究 ThreadLocal 之前，但发现其中最重要的 get&#x2F;set 方法都是操纵的 Thread 类 中的 threadLocals 变量 (java.lang.ThreadLocal.ThreadLocalMap)，索性先来看一下 Thread 的<a href="/2450508050/#Thread">源码</a> 吧，可以留意一下其中与 ThreadLocal 相关的属性</p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>看看阿里巴巴 java 开发手册中推荐的 ThreadLocal 的用法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.text.DateFormat;<br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DateUtils</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;DateFormat&gt; df = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;DateFormat&gt;()&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> DateFormat <span class="hljs-title function_">initialValue</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleDateFormat</span>(<span class="hljs-string">&quot;yyyy-MM-dd&quot;</span>);<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要格式化的地方直接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">DateUtils.df.get().format(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br></code></pre></td></tr></table></figure><p>它还适用于需要在线程间传递的值，比如用户session，比如链路追踪的traceId。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><img src="https://s2.loli.net/2023/04/26/qmA7lLE8r2Wkgah.png" srcset="/img/loading.gif" lazyload style="zoom:80%"><p><code>Thread</code>类有一个类型为<code>ThreadLocal.ThreadLocalMap</code>的实例变量<code>threadLocals</code>，也就是说每个线程有一个自己的<code>ThreadLocalMap</code>。</p><p><code>ThreadLocalMap</code>有自己的独立实现，可以简单地将它的<code>key</code>视作<code>ThreadLocal</code>，<code>value</code>为代码中放入的值（实际上<code>key</code>并不是<code>ThreadLocal</code>本身，而是它的一个<strong>弱引用</strong>）。</p><p>每个线程在往<code>ThreadLocal</code>里放值的时候，都会往自己的<code>ThreadLocalMap</code>里存，读也是以<code>ThreadLocal</code>作为引用，在自己的<code>map</code>里找对应的<code>key</code>，从而实现了<strong>线程隔离</strong>。</p><p><code>ThreadLocalMap</code>有点类似<code>HashMap</code>的结构，只是<code>HashMap</code>是由<strong>数组+链表</strong>实现的，而<code>ThreadLocalMap</code>中并没有<strong>链表</strong>结构。</p><p>我们还要注意<code>Entry</code>， 它的<code>key</code>是<code>ThreadLocal&lt;?&gt; k</code> ，继承自<code>WeakReference</code>， 也就是我们常说的弱引用类型。</p><h1 id="锁基础"><a href="#锁基础" class="headerlink" title="锁基础"></a>锁基础</h1><p><strong>实现依赖</strong>：</p><img src="https://s2.loli.net/2023/04/25/WNjgasXkmDpKlZu.jpg" srcset="/img/loading.gif" lazyload style="zoom:50%"><h2 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a><strong>CAS</strong></h2><h2 id="LockSuport"><a href="#LockSuport" class="headerlink" title="LockSuport"></a>LockSuport</h2><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a><strong>synchronized</strong></h2><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a><strong>ReentrantLock</strong></h2></div><hr><div><div class="post-metas my-3"><div class="post-meta mr-3 d-flex align-items-center"><i class="iconfont icon-category"></i> <span class="category-chains"><span class="category-chain"><a href="/categories/%E5%9F%BA%E7%A1%80/" class="category-chain-item">基础</a> <span>></span> <a href="/categories/%E5%9F%BA%E7%A1%80/JUC/" class="category-chain-item">JUC</a></span></span></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a href="/tags/%E5%9F%BA%E7%A1%80/">#基础</a></div></div><div class="license-box my-3"><div class="license-title"><div>JUC</div><div>https://youzi.netlify.app/2857723967/</div></div><div class="license-meta"><div class="license-meta-item"><div>作者</div><div>Noah Lee</div></div><div class="license-meta-item"><div>许可协议</div><div><a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/"><span class="hint--top hint--rounded" aria-label="BY - 署名"><i class="iconfont icon-by"></i> </span></a><a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/"><span class="hint--top hint--rounded" aria-label="SA - 相同方式共享"><i class="iconfont icon-sa"></i></span></a></div></div></div><div class="license-icon iconfont"></div></div><div class="post-prevnext my-3"><article class="post-prev col-6"><a href="/2591906323/" title="Kafka"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Kafka</span> <span class="visible-mobile">上一篇</span></a></article><article class="post-next col-6"><a href="/4264158992/" title="Redis基础"><span class="hidden-mobile">Redis基础</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div></article></div></div></div><div class="side-col d-none d-lg-block col-lg-2"><aside class="sidebar" style="margin-left:-1rem"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i> <span>目录</span></p><div class="toc-body" id="toc-body"></div></div></aside></div></div></div><a id="scroll-top-button" aria-label="TOP" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div></main><footer><div class="footer-inner"><div class="footer-content"><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div class="statistics"><span id="busuanzi_container_site_pv" style="display:none">总访问量 <span id="busuanzi_value_site_pv"></span> 次 </span><span id="busuanzi_container_site_uv" style="display:none">总访客数 <span id="busuanzi_value_site_uv"></span> 人</span></div></div></footer><script src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js"></script><link rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css"><script>NProgress.configure({showSpinner:!1,trickleSpeed:100}),NProgress.start(),window.addEventListener("load",function(){NProgress.done()})</script><script src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js"></script><script src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js"></script><script src="/js/events.js"></script><script src="/js/plugins.js"></script><script src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js"></script><script>!function(t){var e=Fluid.plugins.typing,i=t.getElementById("subtitle");i&&e&&e(i.getAttribute("data-typed-text"))}((window,document))</script><script src="/js/img-lazyload.js"></script><script>Fluid.utils.createScript("https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js",function(){var t,o=jQuery("#toc");0!==o.length&&window.tocbot&&(t=jQuery("#board-ctn").offset().top,window.tocbot.init(Object.assign({tocSelector:"#toc-body",contentSelector:".markdown-body",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",scrollSmooth:!0,includeTitleTags:!0,headingsOffset:-t},CONFIG.toc)),0<o.find(".toc-list-item").length&&o.css("visibility","visible"),Fluid.events.registerRefreshCallback(function(){if("tocbot"in window){tocbot.refresh();var t=jQuery("#toc");if(0===t.length||!tocbot)return;0<t.find(".toc-list-item").length&&t.css("visibility","visible")}}))})</script><script src="https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js"></script><script>Fluid.plugins.codeWidget()</script><script>Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });</script><script>Fluid.utils.createScript("https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js",function(){Fluid.plugins.fancyBox()})</script><script>Fluid.plugins.imageCaption()</script><script src="/js/local-search.js"></script><script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="/js/boot.js"></script><noscript><div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div></noscript><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body></html>