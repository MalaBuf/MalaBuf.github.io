<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>分布式理论</title>
    <link href="/1091987553/"/>
    <url>/1091987553/</url>
    
    <content type="html"><![CDATA[<h1 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><a href="https://zh.wikipedia.org/wiki/CAP%E5%AE%9A%E7%90%86">CAP 理论&#x2F;定理</a>起源于 2000 年，由加州大学伯克利分校的 Eric Brewer 教授在分布式计算原理研讨会（PODC）上提出，因此 CAP 定理又被称作 <strong>布鲁尔定理（Brewer’s theorem）</strong></p><p>2 年后，麻省理工学院的 Seth Gilbert 和 Nancy Lynch 发表了布鲁尔猜想的证明，CAP 理论正式成为分布式领域的定理。</p><p><code>CAP</code>由3个单词组成，即<strong>Consistency（一致性）</strong>，<strong>Availability（可用性）</strong>，<strong>Partition Tolerance（分区容错性）</strong></p><p><img src="https://s2.loli.net/2023/04/14/GYdTVZuRKg6S35w.jpg"></p><h2 id="解读"><a href="#解读" class="headerlink" title="解读"></a>解读</h2><p>在理论计算机科学中，CAP 定理指出对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个：</p><p><strong>一致性（Consistency）</strong> : 所有节点访问同一份最新的数据副本</p><p><strong>可用性（Availability）</strong>: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</p><p><strong>分区容错性（Partition Tolerance）</strong> : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</p><h3 id="网络分区"><a href="#网络分区" class="headerlink" title="网络分区"></a>网络分区</h3><p>在分布式系统中，各个节点之前应该是网络连通的，突然发生了某些故障（部分节点网络出了故障）某些节点不能通信，整个系统的网络就分成了几个，这便是网络分区了。</p><h3 id="3选2？"><a href="#3选2？" class="headerlink" title="3选2？"></a>3选2？</h3><p>大部分人认为一致性，可用性，分区容错性3者，只能存在其中的2种。其实这是一种非常具有误导性的说法，CAP之父早在2012重写之前的论文。</p><p><code>CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。</code>所以，CAP理论不存在CA架构，只存在CP或者AP架构。比如Zookeeper, Hbase就是CP架构；Ereka就是AP架构；而Nacos默认是AP，也可以支持CP。</p><h3 id="CAP应用案例"><a href="#CAP应用案例" class="headerlink" title="CAP应用案例"></a>CAP应用案例</h3><p>以注册中心来简述一下CAP的应用。Zookeeper，Ereka，Nacos都可以作为注册中心，它们有什么区别呢？</p><ul><li><strong>Zookeeper支持CP</strong>：任何时刻对 ZooKeeper 的读请求都能得到一致性的结果，但是， ZooKeeper 不保证每次请求的可用性比如在 Leader 选举过程中或者半数以上的机器不可用的时候服务就是不可用的。</li><li><strong>Ereka支持AP</strong>：Eureka 在设计的时候就是优先保证 A （可用性）。在 Eureka 中不存在什么 Leader 节点，每个节点都是一样的、平等的。 Eureka 保证即使大部分节点挂掉也不会影响正常提供服务，只要有一个节点是可用的就行了。只不过这个节点上的数据可能并不是最新的。</li><li>Nacos可以选择支持一种</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在系统发生了网络分区，我们应该根据业务来选者保证可用性还是一致性。没有发生网络分区，一致性和可用性都要保证。</p><h1 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p><strong>BASE</strong>是<strong>Basically Available（基本可用）</strong> 、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。BASE理论是对CAP定理中一致性 C 与可用性 A 权衡之后的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p><h2 id="核心思想"><a href="#核心思想" class="headerlink" title="核心思想"></a>核心思想</h2><p>即使无法做到强一致性，但每一个应用都可以根据自身业务的特点，选择适当的方式来使系统达到最终一致性。<code>牺牲数据的一致性来满足系统的高可用性，系统一部分数据不可用或者不一致时，仍然保持系统整体的可用性。</code> </p><p>BASE基本上是对 CAP 的一个补充，准确的来说是对AP的一种实现。因此，AP 方案只是在系统发生分区的时候放弃一致性，而不是永远放弃一致性。在分区故障恢复后，系统应该达到最终一致性。这一点其实就是 BASE 理论延伸的地方。</p><h3 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h3><img src="https://s2.loli.net/2023/04/14/udso1PCQJTxEADr.png" style="zoom:67%;" /><h4 id="基本可用"><a href="#基本可用" class="headerlink" title="基本可用"></a>基本可用</h4><p>基本可用指分布式系统在发生故障时，允许<strong>损失部分可用性</strong>，但是不等价于这个系统不可用</p><p><strong>损失部分可用性：</strong></p><ul><li>响应时间：比如正常情况下0.5s就能响应结果，发生故障时3s才响应结果</li><li>系统功能：正常情况下，用户可访问全部系统功能；系统访问量巨增，系统部分非核心功能无法使用</li></ul><h4 id="软状态"><a href="#软状态" class="headerlink" title="软状态"></a>软状态</h4><p>软状态指系统允许数据存在中间状态（CAP理论中的数据不一致），并且这种中间状态的存在不会影响系统整体的可用性，即允许<strong>延时更新数据</strong>。</p><h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><p>最终一致性指系统所有的数据副本，经过一段时间的同步，最终都能达到一致的状态。这个最终一致性本质上是<code>不需要所有数据副本实时一致（强一致性），只用保证数据最终能达到一致</code>。</p><p>一致性分3个等级：</p><ul><li><strong>强一致性</strong>：系统写入什么，读出就是什么</li><li><strong>弱一致性</strong>：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。</li><li><strong>最终一致性</strong>：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态</li></ul><p>业界推崇最终一致性，但是某些业务必须要强一致性（如银行转账）。</p><p><strong>最终一致性的实现方式</strong>：</p><p><strong>读时修复</strong> : 在读取数据时，检测数据的不一致，进行修复。</p><p><strong>写时修复</strong> : 在写入数据，检测数据的不一致时，进行修复。</p><p><strong>异步修复</strong> : 这个是最常用的方式，通过定时对账检测副本数据的一致性，并修复。</p><p>推荐<strong>写时修复</strong>，这种方式对性能消耗比较低。</p><h1 id="Paxos"><a href="#Paxos" class="headerlink" title="Paxos"></a>Paxos</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>Paxos 算法是 Leslie Lamport（<a href="https://zh.wikipedia.org/wiki/%E8%8E%B1%E6%96%AF%E5%88%A9%C2%B7%E5%85%B0%E4%BC%AF%E7%89%B9">莱斯利·兰伯特</a>）在 <strong>1990</strong> 年提出了一种分布式系统 <strong>共识</strong> 算法。这也是第一个被证明完备的共识算法（前提是不存在拜占庭将军问题，也就是没有恶意节点）。共识算法的作用就是让多数节点对某提议达成一致的看法。提议的定义非常宽泛，比如让某个节点成为leader，或者多个事件发生的顺序都可以是一项提议。由于 Paxos 算法在国际上被公认的非常难以理解和实现，因此不断有人尝试简化这一算法。到了 2013 年才诞生了一个比 Paxos 算法更易理解和实现的共识算法—Raft算法。</p><p>针对没有恶意节点的情况，除了 Raft 算法之外，当前最常用的一些共识算法比如 <strong>ZAB 协议</strong> 、 <strong>Fast Paxos</strong> 算法都是基于 Paxos 算法改进的。针对存在恶意节点的情况，一般使用的是 <strong>工作量证明（POW，Proof-of-Work）</strong> 、 <strong>权益证明（PoS，Proof-of-Stake ）</strong> 等共识算法。这类共识算法最典型的应用就是区块链，就比如说前段时间以太坊官方宣布其共识机制正在从工作量证明(PoW)转变为权益证明(PoS)。</p><h2 id="Basic-Paxos-算法"><a href="#Basic-Paxos-算法" class="headerlink" title="Basic Paxos 算法"></a>Basic Paxos 算法</h2><p>Basic Paxos有3个角色</p><ul><li>**提议者(Proposer)**：提议者主要负责对客户端的请求发起提议。提议信息包括提案编号 (Proposal ID) 和提议的值 (Value)。</li><li>**接受者(Acceptor)**：也可以叫做投票员，负责对提议者提出的提案进行投票，同时记住自己的投票历史。</li><li>**学习者(Learner)**：如果有超过半数的票数，所以学习者就接受提议。并将提议运算结果返回给客户端</li></ul><img src="https://s2.loli.net/2023/04/16/FGLC8qavDmMAdgp.png" style="zoom:50%;" /><p>通常一个节点可以身兼多个角色。并且，一个提案被选定需要被半数以上的 Acceptor 接受。这样的话，Basic Paxos 算法还具备容错性。</p><h2 id="Multi-Paxos-思想"><a href="#Multi-Paxos-思想" class="headerlink" title="Multi Paxos 思想"></a>Multi Paxos 思想</h2><p>Basic Paxos 算法的仅能就单个值达成共识，为了能够对一系列的值达成共识，我们需要用到 Basic Paxos 思想。</p><p>Raft 算法就是 Multi-Paxos 的一个变种，其简化了 Multi-Paxos 的思想，变得更容易被理解以及工程实现。</p><h1 id="Raft"><a href="#Raft" class="headerlink" title="Raft"></a>Raft</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>目前分布式系统都运行在高度动态的环境，通常通过额外的服务器进行横向扩展，并且根据需求进行扩展和收缩来应对高度动态的环境。同时，还应该对服务器和网络故障做出应对。</p><p>所以，系统必须在正常操作期间处理服务器的上下线，对发生的改变自适应，让系统或者服务仍然可以正常运转。这就是分布式共识的作用。</p><h2 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h2><h3 id="拜占庭将军"><a href="#拜占庭将军" class="headerlink" title="拜占庭将军"></a>拜占庭将军</h3><div class="note note-info">            <p>在分布式计算中，拜占庭将军问题（Byzantine Generals Problem）是指在一个分布式系统中，存在多个节点（将军），它们需要就某个共同的决策进行协商，但其中有些节点（将军）可能是恶意的，它们会发送错误或者不一致的信息，或者干脆不发送信息，从而破坏整个系统的正确性。这个问题最早由Leslie Lamport等人于1982年提出，被称为拜占庭将军问题，因为它类似于古代拜占庭将军们在面对敌人时需要协调决策的情形。</p>          </div><p>在介绍共识算法之前，先介绍一个<strong>简化版拜占庭将军</strong>的例子来帮助理解共识算法。</p><blockquote><p>假设多位拜占庭将军中没有叛军，信使的信息可靠但有可能被暗杀的情况下，将军们如何达成是否要进攻的一致性决定？</p></blockquote><p>解决方案大致可以理解成：先在所有的将军中选出一个大将军，用来做出所有的决定。信使被暗杀就再重派一个信使，直到收到回复。</p><h3 id="共识算法-1"><a href="#共识算法-1" class="headerlink" title="共识算法"></a>共识算法</h3><p>共识：即使面对故障，服务器在共享状态上也能达到一致。</p><p>共识算法允许一组节点像一个整体一样一起工作，即使其中的一些节点出现故障也能够继续工作下去，其正确性主要是源于复制状态机的性质：一组<code>Server</code>的状态机计算相同状态的副本，即使有一部分的<code>Server</code>宕机了它们仍然能够继续运行。</p><img src="https://s2.loli.net/2023/04/16/gaPSf8WzoXBnwFp.png" alt="复制状态机架构图" style="zoom:67%;" /><p>一般使用复制日志来实现复制状态机。每个<code>Server</code>存储一份包含命令序列的日志文件，状态机会按照顺序执行这些命令。每个日志包含相同的命令，且顺序也相同，所以每个状态机处理相同的命令序列。</p><p>因此共识算法的工作就是<code>保持复制日志的一致性</code>。服务器上的共识模块从客户端接收命令并将它们添加到日志中。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>适用于实际系统的共识算法通常具有以下特性：</p><ul><li>安全。确保在非拜占庭条件（也就是上文中提到的简易版拜占庭）下的安全性，包括网络延迟、分区、包丢失、复制和重新排序。</li><li>高可用。只要大多数服务器都是可操作的，并且可以相互通信，也可以与客户端进行通信，那么这些服务器就可以看作完全功能可用的。因此，一个典型的由五台服务器组成的集群可以容忍任何两台服务器端故障。假设服务器因停止而发生故障；它们稍后可能会从稳定存储上的状态中恢复并重新加入集群。</li><li>一致性不依赖时序。错误的时钟和极端的消息延迟，在最坏的情况下也只会造成可用性问题，而不会产生一致性问题。</li><li>在集群中大多数服务器响应，命令就可以完成，不会被少数运行缓慢的服务器来影响整体系统性能。</li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h3><p>状态（每个服务器节点一定会处于下述状态的一种）</p><ul><li><strong>Leader</strong>:负责发起心跳，响应客户端，创建日志，同步日志</li><li><strong>Condidate</strong>：Leader 选举过程中的<strong>临时</strong>角色，由 Follower 转化而来，发起投票参与竞选。</li><li><strong>Fllower</strong>：接受 Leader 的心跳和日志同步数据，投票给 Candidate。</li></ul><p>正常情况下（没有选取leader）只有一个服务器是 Leader，剩下的服务器是 Follower。Follower 是被动的，它们不会发送任何请求，只是响应来自 Leader 和 Candidate 的请求。</p><h3 id="任期"><a href="#任期" class="headerlink" title="任期"></a>任期</h3><p><img src="https://s2.loli.net/2023/04/16/m5fDMGOTu8XiH7o.png" alt="任期"></p><p>如图所示，raft 算法将时间划分为任意长度的任期（term），任期用连续的数字表示，看作当前 term 号。每一个任期的开始都是一次选举，在选举开始时，一个或多个 Candidate 会尝试成为 Leader。如果一个 Candidate 赢得了选举，它就会在该任期内担任 Leader。如果没有选出 Leader，将会开启另一个任期，并立刻开始下一次选举。raft 算法保证在给定的一个任期最少要有一个 Leader。</p><p>每个节点都会存储当前的 term 号，当服务器之间进行通信时会交换当前的 term 号；如果有服务器发现自己的 term 号比其他人小，那么他会更新到较大的 term 值。如果一个 Candidate 或者 Leader 发现自己的 term 过期了，他会立即退回成 Follower。如果一台服务器收到的请求的 term 号是过期的，那么它会拒绝此次请求。</p><h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><p><code>entry</code>：每一个事件成为 entry，只有 Leader 可以创建 entry。entry 的内容为<code>&lt;term,index,cmd&gt;</code>其中 cmd 是可以应用到状态机的操作。</p><p><code>log</code>：由 entry 构成的数组，每一个 entry 都有一个表明自己在 log 中的 index。只有 Leader 才可以改变其他节点的 log。entry 总是先被 Leader 添加到自己的 log 数组中，然后再发起共识请求，获得同意后才会被 Leader 提交给状态机。Follower 只能从 Leader 获取新日志和当前的 commitIndex，然后把对应的 entry 应用到自己的状态机中。</p><h2 id="Leader选举"><a href="#Leader选举" class="headerlink" title="Leader选举"></a>Leader选举</h2><p>Raft通过心跳机制触发Leader选举机制。</p><p>一个Fllower能够正常接受Leader或者Condidate的消息，会一直保持Fllower身份，并重置 electionElapse 倒计时；即 Leader 会通过向 Fllower 周期性发送心跳来保持Leader身份。如果一个Fllower在周期内没有收到 Leader 的心跳，会触发选举超时，并开启新的一轮 Leader 选举。</p><p>开始新的Leader选举，Fllower先将自增term号，并转化状态为Condidate。然后他会向所有节点发起 RequestVoteRPC 请求， Candidate 的状态会持续到以下情况发生：</p><ul><li>赢得选举（在一个任期内收到了来自集群内的多数选票<code>（N/2+1）</code>）</li><li>其他节点赢得选举</li><li>一轮选举结束，无人胜出</li></ul><p>在 Candidate 等待选票的时候，它可能收到其他节点声明自己是 Leader 的心跳，此时有两种情况：</p><ul><li>自己 term 小于等于该 Leader 的 term ，自己回退Fllower</li><li>自己 term 大于该 Leader 的 term，拒接请求并让其节点更新term</li></ul><p>由于可能同一时刻出现多个 Candidate，导致没有 Candidate 获得大多数选票，如果没有其他手段来重新分配选票的话，那么可能会无限重复下去。</p><p>raft 使用了随机的选举超时时间来避免上述情况。每一个 Candidate 在发起选举后，都会随机化一个新的枚举超时时间，这种机制使得各个服务器能够分散开来，在大多数情况下只有一个服务器会率先超时；它会在其他服务器超时之前赢得选举。</p><h2 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h2><p>一旦选出了 Leader，它就开始接受客户端的请求。每一个客户端的请求都包含一条需要被复制状态机（<code>Replicated State Mechine</code>）执行的命令。</p><p>Leader 收到客户端请求后，会生成一个 entry，包含<code>&lt;index,term,cmd&gt;</code>，再将这个 entry 添加到自己的日志末尾后，向所有的节点广播该 entry，要求其他服务器复制这条 entry。</p><p>如果 Follower 接受该 entry，则会将 entry 添加到自己的日志后面，同时返回给 Leader 同意。</p><p>如果 Leader 收到了多数的成功响应，Leader 会将这个 entry 应用到自己的状态机中，之后可以成为这个 entry 是 committed 的，并且向客户端返回执行结果。</p><p>raft 保证以下两个性质：</p><ul><li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们一定有相同的 cmd</li><li>在两个日志里，有两个 entry 拥有相同的 index 和 term，那么它们前面的 entry 也一定相同</li></ul><p>通过“仅有 Leader 可以生成 entry”来保证第一个性质，第二个性质需要一致性检查来进行保证。</p><h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><h3 id="选举限制"><a href="#选举限制" class="headerlink" title="选举限制"></a>选举限制</h3><p>Leader 需要保证自己存储全部已经提交的日志条目。这样才可以使日志条目只有一个流向：从 Leader 流向 Follower，Leader 永远不会覆盖已经存在的日志条目。</p><p>每个 Candidate 发送 RequestVoteRPC 时，都会带上最后一个 entry 的信息。所有节点收到投票信息时，会对该 entry 进行比较，如果发现自己的更新，则拒绝投票给该 Candidate。</p><p>判断日志新旧的方式：如果两个日志的 term 不同，term 大的更新；如果 term 相同，更长的 index 更新。</p><h3 id="节点崩溃"><a href="#节点崩溃" class="headerlink" title="节点崩溃"></a>节点崩溃</h3><p>如果 Leader 崩溃，集群中的节点在 electionTimeout 时间内没有收到 Leader 的心跳信息就会触发新一轮的选主，在选主期间整个集群对外是不可用的。</p><p>如果 Follower 和 Candidate 崩溃，处理方式会简单很多。之后发送给它的 RequestVoteRPC 和 AppendEntriesRPC 会失败。由于 raft 的所有请求都是幂等的，所以失败的话会无限的重试。如果崩溃恢复后，就可以收到新的请求，然后选择追加或者拒绝 entry。</p><h3 id="时间与可用性"><a href="#时间与可用性" class="headerlink" title="时间与可用性"></a>时间与可用性</h3><p>raft 的要求之一就是安全性不依赖于时间：系统不能仅仅因为一些事件发生的比预想的快一些或者慢一些就产生错误。为了保证上述要求，最好能满足以下的时间条件：</p><p><code>broadcastTime &lt;&lt; electionTimeout &lt;&lt; MTBF</code></p><ul><li><code>broadcastTime</code>：向其他节点并发发送消息的平均响应时间；</li><li><code>electionTimeout</code>：选举超时时间；</li><li><code>MTBF(mean time between failures)</code>：单台机器的平均健康时间；</li></ul><p>一般来说，broadcastTime 一般为 <code>0.5～20ms</code>，electionTimeout 可以设置为 <code>10～500ms</code>，MTBF 一般为一两个月。</p><h1 id="Gossip-协议"><a href="#Gossip-协议" class="headerlink" title="Gossip 协议"></a>Gossip 协议</h1><h2 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h2><p>Gossip协议是一种分布式的信息传播协议，它可以用于数据同步、状态更新、故障检测等分布式应用场景。它的基本思想是通过节点之间的<strong>随机交流来传播信息</strong>，从而使得整个网络中的节点逐渐趋于一致状态。它不同于<strong>集中式发散消息</strong>，是<code>去中心化</code>的实现，让它避免了节点多的时候同步消息的效率低，太依赖于中心节点，存在单点风险问题等。</p><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>Gossip协议的工作流程如下：</p><p>1.每个节点随机选择一些邻居节点，并向它们发送自己的状态信息。</p><p>2.邻居节点收到状态信息后，随机选择另外的一些邻居节点，并将收到的状态信息继续向它们传播。</p><p>3.不断重复上述过程，直到整个网络中的节点都达成一致状态为止。</p><h2 id="Gossip-协议应用"><a href="#Gossip-协议应用" class="headerlink" title="Gossip 协议应用"></a>Gossip 协议应用</h2><p>NoSQL 数据库 <a href="https://youzi.netlify.app/1876276682/">Redis</a> 和 Apache Cassandra、服务网格解决方案 Consul 等知名项目都用到了 Gossip 协议</p><h2 id="消息传播模式"><a href="#消息传播模式" class="headerlink" title="消息传播模式"></a>消息传播模式</h2><p>Gossip 设计了两种可能的消息传播模式：<strong>反熵（Anti-Entropy）</strong> 和 <strong>传谣（Rumor-Mongering）</strong>。</p><h3 id="反熵-Anti-entropy"><a href="#反熵-Anti-entropy" class="headerlink" title="反熵(Anti-entropy)"></a>反熵(Anti-entropy)</h3><p>可以把反熵中的熵了解为节点之间数据的混乱程度&#x2F;差异性，反熵就是指消除不同节点中数据的差异，提升节点间数据的相似度，从而降低熵值。集群中的节点，每隔段时间就随机选择某个其他节点，然后通过互相交换自己的所有数据来消除两者之间的差异，实现数据的最终一致性。</p><p>在实现反熵的时候，主要有推、拉和推拉三种方式：</p><ul><li>推方式，就是将自己的所有副本数据，推给对方，修复对方副本中的熵。</li><li>拉方式，就是拉取对方的所有副本数据，修复自己副本中的熵。</li><li>推拉就是同时修复自己副本和对方副本中的熵。</li></ul><p>实际应用场景中，一般不会采用随机的节点进行反熵，而是需要可以的设计一个闭环。这样的话，我们能够在一个确定的时间范围内实现各个节点数据的最终一致性，而不是基于随机的概率。像 InfluxDB 就是这样来实现反熵的。</p><p><img src="https://s2.loli.net/2023/04/16/TbV41GalF6zCfOe.png"></p><p>虽然反熵很简单实用，但是，节点过多或者节点动态变化的话，反熵就不太适用了。这个时候，我们想要实现最终一致性就要靠 <strong>谣言传播(Rumor mongering)</strong> 。</p><h3 id="传谣（Rumor-Mongering）"><a href="#传谣（Rumor-Mongering）" class="headerlink" title="传谣（Rumor-Mongering）"></a>传谣（Rumor-Mongering）</h3><p>谣言传播指的是分布式系统中的一个节点一旦有了新数据之后，就会变为活跃节点，活跃节点会周期性地联系其他节点向其发送新数据，直到所有的节点都存储了该新数据。谣言传播比较适合节点数量比较多的情况，不过，这种模式下要尽量避免传播的信息包不能太大，避免网络消耗太大。</p><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><ul><li><p>反熵（Anti-Entropy）会传播节点的所有数据，而谣言传播（Rumor-Mongering）只会传播节点新增的数据。</p></li><li><p>一般会给反熵设计一个闭环。</p></li><li><p>谣言传播（Rumor-Mongering）比较适合节点数量比较多或者节点动态变化的场景。</p></li></ul><h2 id="Gossip-协议优势和缺陷"><a href="#Gossip-协议优势和缺陷" class="headerlink" title="Gossip 协议优势和缺陷"></a>Gossip 协议优势和缺陷</h2><p><strong>优势：</strong></p><p>1、相比于其他分布式协议&#x2F;算法来说，Gossip 协议理解起来非常简单。</p><p>2、能够容忍网络上节点的随意地增加或者减少，宕机或者重启，因为 Gossip 协议下这些节点都是平等的，去中心化的。新增加或者重启的节点在理想情况下最终是一定会和其他节点的状态达到一致。</p><p>3、速度相对较快。节点数量比较多的情况下，扩散速度比一个主节点向其他节点传播信息要更快（多播）。</p><p><strong>缺陷</strong> :</p><p>1、消息需要通过多个传播的轮次才能传播到整个网络中，因此，必然会出现各节点状态不一致的情况。毕竟，Gossip 协议强调的是最终一致，至于达到各个节点的状态一致需要多长时间，谁也无从得知。</p><p>2、由于拜占庭将军问题，不允许存在恶意节点。</p><p>3、可能会出现消息冗余的问题。由于消息传播的随机性，同一个节点可能会重复收到相同的消息</p><blockquote><p>参考：</p><p>ChatGPT</p><p>https:&#x2F;&#x2F;<span></span>javaguide.cn&#x2F;distributed-system&#x2F;theorem&amp;algorithm&amp;protocol&#x2F;raft-algorithm.html</p><p>https:&#x2F;&#x2F;<span></span>javaguide.cn&#x2F;distributed-system&#x2F;theorem&amp;algorithm&amp;protocol&#x2F;gossip-protocl.html</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
      <category>理论</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty</title>
    <link href="/476816354/"/>
    <url>/476816354/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="1-什么是Netty"><a href="#1-什么是Netty" class="headerlink" title="1.什么是Netty"></a>1.什么是Netty</h2><p>Netty 是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务器和客户端</p><p><strong>注意</strong>：<code>netty的异步还是基于多路复用的，并没有实现真正意义上的异步IO</code></p><h2 id="2-Netty的优势"><a href="#2-Netty的优势" class="headerlink" title="2.Netty的优势"></a>2.Netty的优势</h2><p>如果使用传统NIO，其工作量大，bug多</p><ul><li>需要自己构建协议</li><li>解决TCP传输问题，如粘包、半包</li><li>因为bug的存在，epoll空轮询导致CPU 100%</li></ul><p>Netty对API进行增强，使之更易用，如</p><ul><li>FastThreadLocal &#x3D;&gt; ThreadLocal</li><li>ByteBuf &#x3D;&gt; ByteBuffer</li></ul><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="1-EventLoop"><a href="#1-EventLoop" class="headerlink" title="1.EventLoop"></a>1.EventLoop</h2><p><strong>事件循环对象</strong> EventLoop</p><p>EventLoop 本质是一个<strong>单线程执行器</strong>（同时<strong>维护了一个 Selector</strong>），里面有 run 方法处理一个或多个 Channel 上源源不断的 io 事件</p><p>它的继承关系如下</p><ul><li>继承自 j.u.c.ScheduledExecutorService 因此包含了线程池中所有的方法</li><li>继承自 netty 自己的 OrderedEventExecutor<ul><li>提供了 boolean inEventLoop(Thread thread) 方法判断一个线程是否属于此 EventLoop</li><li>提供了 EventLoopGroup parent() 方法来看看自己属于哪个 EventLoopGroup</li></ul></li></ul><p><strong>事件循环组</strong> EventLoopGroup</p><p>EventLoopGroup 是一组 EventLoop，Channel 一般会调用 EventLoopGroup 的 register 方法来绑定其中一个 EventLoop，后续这个 Channel 上的 io 事件都由此 EventLoop 来处理（保证了 io 事件处理时的线程安全）</p><ul><li>继承自 netty 自己的 EventExecutorGroup<ul><li>实现了 Iterable 接口提供遍历 EventLoop 的能力</li><li>另有 next 方法获取集合中下一个 EventLoop</li></ul></li></ul><h3 id="处理普通与定时任务"><a href="#处理普通与定时任务" class="headerlink" title="处理普通与定时任务"></a>处理普通与定时任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestEventLoop</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建拥有两个EventLoop的NioEventLoopGroup，对应两个线程</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">// 通过next方法可以获得下一个 EventLoop</span><br>        System.out.println(group.next());<br>        System.out.println(group.next());<br><br>        <span class="hljs-comment">// 通过EventLoop执行普通任务</span><br>        group.next().execute(()-&gt;&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; hello&quot;</span>);<br>        &#125;);<br><br>        <span class="hljs-comment">// 通过EventLoop执行定时任务</span><br>        group.next().scheduleAtFixedRate(()-&gt;&#123;<br>            System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; hello2&quot;</span>);<br>        &#125;, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>        <br>        <span class="hljs-comment">// 优雅地关闭</span><br>        group.shutdownGracefully();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果如下</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">io</span>.netty.channel.nio.NioEventLoop@<span class="hljs-number">7</span>bb11784<br><span class="hljs-attribute">io</span>.netty.channel.nio.NioEventLoop@<span class="hljs-number">33</span>a10788<br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">1</span> hello<br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> hello2<br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> hello2<br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> hello2<br></code></pre></td></tr></table></figure><p><strong>关闭 EventLoopGroup</strong></p><p>优雅关闭 <code>shutdownGracefully</code> 方法。该方法会首先切换 <code>EventLoopGroup</code> 到关闭状态从而拒绝新的任务的加入，然后在任务队列的任务都处理完成后，停止线程的运行。从而确保整体应用是在正常有序的状态下退出的</p><h3 id="处理IO任务"><a href="#处理IO任务" class="headerlink" title="处理IO任务"></a>处理IO任务</h3><h4 id="服务器代码"><a href="#服务器代码" class="headerlink" title="服务器代码"></a>服务器代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>()<br>                .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br>                .channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                                <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + buf.toString(StandardCharsets.UTF_8));<br><br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>()<br>                .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>());<br>                    &#125;<br>                &#125;)<br>                .connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>))<br>                .sync()<br>                .channel();<br>        System.out.println(channel);<br>        <span class="hljs-comment">// 此处打断点调试，调用 channel.writeAndFlush(...);</span><br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分工"><a href="#分工" class="headerlink" title="分工"></a>分工</h3><p>Bootstrap的group()方法<strong>可以传入两个EventLoopGroup参数</strong>，分别负责处理不同的事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>()<br>            <span class="hljs-comment">// 两个Group，分别为Boss 负责Accept事件，Worker 负责读写事件</span><br>                .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">2</span>))<br>            <br>...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>多个客户端分别发送 <code>hello</code> 结果</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">3</span>-<span class="hljs-number">1</span> hello1<br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">3</span>-<span class="hljs-number">2</span> hello2<br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">3</span>-<span class="hljs-number">1</span> hello3<br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">3</span>-<span class="hljs-number">2</span> hello4<br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">3</span>-<span class="hljs-number">2</span> hello4<br></code></pre></td></tr></table></figure><p>可以看出，一个EventLoop可以<strong>负责多个</strong>Channel，且EventLoop一旦与Channel绑定，则<strong>一直负责</strong>处理该Channel中的事件</p><p><img src="https://s2.loli.net/2023/04/11/phKN5T6gU2zOvEq.png"></p><h4 id="增加自定义EventLoopGroup"><a href="#增加自定义EventLoopGroup" class="headerlink" title="增加自定义EventLoopGroup"></a>增加自定义EventLoopGroup</h4><p>当有的<strong>任务需要较长的时间处理时，可以使用非NioEventLoopGroup</strong>，避免同一个NioEventLoop中的其他Channel在较长的时间内都无法得到处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 增加自定义的非NioEventLoopGroup</span><br>        <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultEventLoopGroup</span>();<br>        <br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>()<br>                .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>), <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">2</span>))<br>                .channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                        <span class="hljs-comment">// 增加两个handler，第一个使用NioEventLoopGroup处理，第二个使用自定义EventLoopGroup处理</span><br>                        socketChannel.pipeline().addLast(<span class="hljs-string">&quot;nioHandler&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                                <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + buf.toString(StandardCharsets.UTF_8));<br>                                <span class="hljs-comment">// 调用下一个handler</span><br>                                ctx.fireChannelRead(msg);<br>                            &#125;<br>                        &#125;)<br>                        <span class="hljs-comment">// 该handler绑定自定义的Group</span><br>                        .addLast(group, <span class="hljs-string">&quot;myHandler&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                                <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + buf.toString(StandardCharsets.UTF_8));<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动四个客户端发送数据</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">4</span>-<span class="hljs-number">1</span> hello1<br><span class="hljs-attribute">defaultEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">1</span> hello1<br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">4</span>-<span class="hljs-number">2</span> hello2<br><span class="hljs-attribute">defaultEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> hello2<br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">4</span>-<span class="hljs-number">1</span> hello3<br><span class="hljs-attribute">defaultEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">3</span> hello3<br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">4</span>-<span class="hljs-number">2</span> hello4<br><span class="hljs-attribute">defaultEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">4</span> hello4<br></code></pre></td></tr></table></figure><p>可以看出，客户端与服务器之间的事件，被nioEventLoopGroup和defaultEventLoopGroup分别处理</p><p><img src="https://s2.loli.net/2023/04/11/B6olPkqQnUKjmbd.png"></p><h4 id="切换的实现"><a href="#切换的实现" class="headerlink" title="切换的实现"></a>切换的实现</h4><p><strong>不同的EventLoopGroup切换的实现原理如下</strong></p><p>由上面的图可以看出，当handler中绑定的Group不同时，需要切换Group来执行不同的任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">invokeChannelRead</span><span class="hljs-params">(<span class="hljs-keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="hljs-string">&quot;msg&quot;</span>), next);<br>    <span class="hljs-comment">// 获得下一个EventLoop, excutor 即为 EventLoopGroup</span><br>    <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> next.executor();<br>    <br>    <span class="hljs-comment">// 如果下一个EventLoop 在当前的 EventLoopGroup中</span><br>    <span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br>        <span class="hljs-comment">// 使用当前 EventLoopGroup 中的 EventLoop 来处理任务</span><br>        next.invokeChannelRead(m);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 否则让另一个 EventLoopGroup 中的 EventLoop 来创建任务并执行</span><br>        executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                next.invokeChannelRead(m);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>如果两个 handler 绑定的是<strong>同一个EventLoopGroup</strong>，那么就直接调用</li><li>否则，把要调用的代码封装为一个任务对象，由下一个 handler 的 EventLoopGroup 来调用</li></ul><h2 id="2-Channel"><a href="#2-Channel" class="headerlink" title="2.Channel"></a>2.Channel</h2><p>Channel的常用方法</p><ul><li>close() 可以用来关闭Channel</li><li>closeFuture() 用来处理 Channel 的关闭<ul><li>sync 方法作用是同步等待 Channel 关闭</li><li>而 addListener 方法是异步等待 Channel 关闭</li></ul></li><li>pipeline() 方法用于添加处理器</li><li>write()方法将数据写入<ul><li>因为缓冲机制，数据被写入到 Channel 中以后，不会立即被发送</li><li><strong>只有当缓冲满了或者调用了flush()方法后</strong>，才会将数据通过 Channel 发送出去</li></ul></li><li>writeAndFlush() 方法将数据写入并<strong>立即发送（刷出）</strong></li></ul><h3 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h3><h4 id="连接问题"><a href="#连接问题" class="headerlink" title="连接问题"></a>连接问题</h4><p>拆分客户端代码分析</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>()<br>                .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>());<br>                    &#125;<br>                &#125;)<br>                <span class="hljs-comment">// 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程</span><br>            <span class="hljs-comment">// NIO线程：NioEventLoop 中的线程</span><br>                .connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>        <br>        <span class="hljs-comment">// 该方法用于等待连接真正建立</span><br>        channelFuture.sync();<br>        <br>        <span class="hljs-comment">// 获取客户端-服务器之间的Channel对象</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> channelFuture.channel();<br>        channel.writeAndFlush(<span class="hljs-string">&quot;hello world&quot;</span>);<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们去掉<code>channelFuture.sync()</code>方法，会服务器无法收到<code>hello world</code></p><p>这是因为建立连接(connect)的过程是<strong>异步非阻塞</strong>的，若不通过<code>sync()</code>方法阻塞主线程，等待连接真正建立，这时通过 channelFuture.channel() <strong>拿到的 Channel 对象，并不是真正与服务器建立好连接的 Channel</strong>，也就没法将信息正确的传输给服务器端</p><p>所以需要通过<code>channelFuture.sync()</code>方法，阻塞主线程，<strong>同步处理结果</strong>，等待连接真正建立好以后，再去获得 Channel 传递数据。使用该方法，获取 Channel 和发送数据的线程<strong>都是主线程</strong></p><p>下面还有一种方法，用于<strong>异步</strong>获取建立连接后的 Channel 和发送数据，使得执行这些操作的线程是 NIO 线程（去执行connect操作的线程）</p><p><strong>addListener方法</strong></p><p>通过这种方法可以<strong>在NIO线程中获取 Channel 并发送数据</strong>，而不是在主线程中执行这些操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException &#123;<br>        <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>()<br>                .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>());<br>                    &#125;<br>                &#125;)<br>                <span class="hljs-comment">// 该方法为异步非阻塞方法，主线程调用后不会被阻塞，真正去执行连接操作的是NIO线程</span><br>                <span class="hljs-comment">// NIO线程：NioEventLoop 中的线程</span><br>                .connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>        <br><span class="hljs-comment">// 当connect方法执行完毕后，也就是连接真正建立后</span><br>        <span class="hljs-comment">// 会在NIO线程中调用operationComplete方法</span><br>        channelFuture.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> channelFuture.channel();<br>                channel.writeAndFlush(<span class="hljs-string">&quot;hello world&quot;</span>);<br>            &#125;<br>        &#125;);<br>        System.in.read();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="处理关闭"><a href="#处理关闭" class="headerlink" title="处理关闭"></a>处理关闭</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReadClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-comment">// 创建EventLoopGroup，使用完毕后关闭</span><br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <br>        <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>()<br>                .group(group)<br>                .channel(NioSocketChannel.class)<br>                .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                        socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEncoder</span>());<br>                    &#125;<br>                &#125;)<br>                .connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">8080</span>));<br>        channelFuture.sync();<br><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> channelFuture.channel();<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br><br>        <span class="hljs-comment">// 创建一个线程用于输入并向服务器发送</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> scanner.next();<br>                <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;q&quot;</span>.equals(msg)) &#123;<br>                    <span class="hljs-comment">// 关闭操作是异步的，在NIO线程中执行</span><br>                    channel.close();<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                channel.writeAndFlush(msg);<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;inputThread&quot;</span>).start();<br><br>        <span class="hljs-comment">// 获得closeFuture对象</span><br>        <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">closeFuture</span> <span class="hljs-operator">=</span> channel.closeFuture();<br>        System.out.println(<span class="hljs-string">&quot;waiting close...&quot;</span>);<br>        <br>        <span class="hljs-comment">// 同步等待NIO线程执行完close操作</span><br>        closeFuture.sync();<br>        <br>        <span class="hljs-comment">// 关闭之后执行一些操作，可以保证执行的操作一定是在channel关闭以后执行的</span><br>        System.out.println(<span class="hljs-string">&quot;关闭之后执行一些额外操作...&quot;</span>);<br>        <br>        <span class="hljs-comment">// 关闭EventLoopGroup</span><br>        group.shutdownGracefully();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>关闭channel</strong></p><p>当我们要关闭channel时，可以调用channel.close()方法进行关闭。但是该方法也是一个<strong>异步方法</strong>。真正的关闭操作并不是在调用该方法的线程中执行的，而是<strong>在NIO线程中执行真正的关闭操作</strong></p><p>如果我们想在channel<strong>真正关闭以后</strong>，执行一些额外的操作，可以选择以下两种方法来实现</p><ul><li><p>通过channel.closeFuture()方法获得对应的ChannelFuture对象，然后调用<strong>sync()方法</strong>阻塞执行操作的线程，等待channel真正关闭后，再执行其他操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获得closeFuture对象</span><br><span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">closeFuture</span> <span class="hljs-operator">=</span> channel.closeFuture();<br><br><span class="hljs-comment">// 同步等待NIO线程执行完close操作</span><br>closeFuture.sync();<br></code></pre></td></tr></table></figure></li><li><p>调用<strong>closeFuture.addListener</strong>方法，添加close的后续操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">closeFuture.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 等待channel关闭后才执行的操作</span><br>        System.out.println(<span class="hljs-string">&quot;关闭之后执行一些额外操作...&quot;</span>);<br>        <span class="hljs-comment">// 关闭EventLoopGroup</span><br>        group.shutdownGracefully();<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><h2 id="3-Future与Promise"><a href="#3-Future与Promise" class="headerlink" title="3.Future与Promise"></a>3.Future与Promise</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>netty 中的 Future 与 jdk 中的 Future <strong>同名</strong>，但是是两个接口</p><p>netty 的 Future 继承自 jdk 的 Future，而 Promise 又对 netty Future 进行了扩展</p><ul><li>jdk Future 只能同步等待任务结束（或成功、或失败）才能得到结果</li><li>netty Future 可以同步等待任务结束得到结果，也可以异步方式得到结果，但<strong>都是要等任务结束</strong></li><li>netty Promise 不仅有 netty Future 的功能，而且脱离了任务独立存在，<strong>只作为两个线程间传递结果的容器</strong></li></ul><table><thead><tr><th>功能&#x2F;名称</th><th>jdk Future</th><th>netty Future</th><th>Promise</th></tr></thead><tbody><tr><td>cancel</td><td>取消任务</td><td>-</td><td>-</td></tr><tr><td>isCanceled</td><td>任务是否取消</td><td>-</td><td>-</td></tr><tr><td>isDone</td><td>任务是否完成，不能区分成功失败</td><td>-</td><td>-</td></tr><tr><td>get</td><td>获取任务结果，阻塞等待</td><td>-</td><td>-</td></tr><tr><td>getNow</td><td>-</td><td>获取任务结果，非阻塞，还未产生结果时返回 null</td><td>-</td></tr><tr><td>await</td><td>-</td><td>等待任务结束，如果任务失败，<strong>不会抛异常</strong>，而是通过 isSuccess 判断</td><td>-</td></tr><tr><td>sync</td><td>-</td><td>等待任务结束，如果任务失败，抛出异常</td><td>-</td></tr><tr><td>isSuccess</td><td>-</td><td>判断任务是否成功</td><td>-</td></tr><tr><td>cause</td><td>-</td><td>获取失败信息，非阻塞，如果没有失败，返回null</td><td>-</td></tr><tr><td>addLinstener</td><td>-</td><td>添加回调，异步接收结果</td><td>-</td></tr><tr><td>setSuccess</td><td>-</td><td>-</td><td>设置成功结果</td></tr><tr><td>setFailure</td><td>-</td><td>-</td><td>设置失败结果</td></tr></tbody></table><h3 id="JDK-Future"><a href="#JDK-Future" class="headerlink" title="JDK Future"></a>JDK Future</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">JdkFuture</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">factory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactory</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(r, <span class="hljs-string">&quot;JdkFuture&quot;</span>);<br>            &#125;<br>        &#125;;<br>        <span class="hljs-comment">// 创建线程池</span><br>        <span class="hljs-type">ThreadPoolExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">5</span>, <span class="hljs-number">10</span>,<span class="hljs-number">10</span>, TimeUnit.SECONDS, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="hljs-number">10</span>), factory);<br><br>        <span class="hljs-comment">// 获得Future对象</span><br>        Future&lt;Integer&gt; future = executor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;() &#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">50</span>;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 通过阻塞的方式，获得运行结果</span><br>        System.out.println(future.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="Netty-Future"><a href="#Netty-Future" class="headerlink" title="Netty Future"></a>Netty Future</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyFuture</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br>        <span class="hljs-comment">// 获得 EventLoop 对象</span><br>        <span class="hljs-type">EventLoop</span> <span class="hljs-variable">eventLoop</span> <span class="hljs-operator">=</span> group.next();<br>        Future&lt;Integer&gt; future = eventLoop.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">50</span>;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 主线程中获取结果</span><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 获取结果&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;getNow &quot;</span> + future.getNow());<br>        System.out.println(<span class="hljs-string">&quot;get &quot;</span> + future.get());<br><br>        <span class="hljs-comment">// NIO线程中异步获取结果</span><br>        future.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericFutureListener</span>&lt;Future&lt;? <span class="hljs-built_in">super</span> Integer&gt;&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(Future&lt;? <span class="hljs-built_in">super</span> Integer&gt; future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; 获取结果&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;getNow &quot;</span> + future.getNow());<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">main</span> 获取结果<br><span class="hljs-attribute">getNow</span> null<br><span class="hljs-attribute">get</span> <span class="hljs-number">50</span><br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">1</span> 获取结果<br><span class="hljs-attribute">getNow</span> <span class="hljs-number">50</span><br></code></pre></td></tr></table></figure><p>Netty中的Future对象，可以通过EventLoop的sumbit()方法得到</p><ul><li>可以通过Future对象的<strong>get方法</strong>，阻塞地获取返回结果</li><li>也可以通过<strong>getNow方法</strong>，获取结果，若还没有结果，则返回null，该方法是非阻塞的</li><li>还可以通过<strong>future.addListener方法</strong>，在Callable方法执行的线程中，异步获取返回结果</li></ul><h3 id="Netty-Promise"><a href="#Netty-Promise" class="headerlink" title="Netty Promise"></a>Netty Promise</h3><p>Promise相当于一个容器，可以用于存放各个线程中的结果，然后让其他线程去获取该结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyPromise</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException &#123;<br>        <span class="hljs-comment">// 创建EventLoop</span><br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">EventLoop</span> <span class="hljs-variable">eventLoop</span> <span class="hljs-operator">=</span> group.next();<br><br>        <span class="hljs-comment">// 创建Promise对象，用于存放结果</span><br>        DefaultPromise&lt;Integer&gt; promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultPromise</span>&lt;&gt;(eventLoop);<br><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                TimeUnit.SECONDS.sleep(<span class="hljs-number">1</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">// 自定义线程向Promise中存放结果</span><br>            promise.setSuccess(<span class="hljs-number">50</span>);<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 主线程从Promise中获取结果</span><br>        System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; &quot;</span> + promise.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-Handler与Pipeline"><a href="#4-Handler与Pipeline" class="headerlink" title="4.Handler与Pipeline"></a>4.Handler与Pipeline</h2><h3 id="pipelien"><a href="#pipelien" class="headerlink" title="pipelien"></a>pipelien</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PipeLineServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>()<br>                .group(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>())<br>                .channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                        <span class="hljs-comment">// 在socketChannel的pipeline中添加handler</span><br>                        <span class="hljs-comment">// pipeline中handler是带有head与tail节点的双向链表，的实际结构为</span><br>     <span class="hljs-comment">// head &lt;-&gt; handler1 &lt;-&gt; ... &lt;-&gt; handler4 &lt;-&gt;tail</span><br>                        <span class="hljs-comment">// Inbound主要处理入站操作，一般为读操作，发生入站操作时会触发Inbound方法</span><br>                        <span class="hljs-comment">// 入站时，handler是从head向后调用的</span><br>                        socketChannel.pipeline().addLast(<span class="hljs-string">&quot;handler1&quot;</span> ,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; Inbound handler 1&quot;</span>);<br>                                <span class="hljs-comment">// 父类该方法内部会调用fireChannelRead</span><br>                                <span class="hljs-comment">// 将数据传递给下一个handler</span><br>                                <span class="hljs-built_in">super</span>.channelRead(ctx, msg);<br>                            &#125;<br>                        &#125;);<br>                        socketChannel.pipeline().addLast(<span class="hljs-string">&quot;handler2&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; Inbound handler 2&quot;</span>);<br>                                <span class="hljs-comment">// 执行write操作，使得Outbound的方法能够得到调用</span><br>          socketChannel.writeAndFlush(ctx.alloc().buffer().writeBytes(<span class="hljs-string">&quot;Server...&quot;</span>.getBytes(StandardCharsets.UTF_8)));<br>                                <span class="hljs-built_in">super</span>.channelRead(ctx, msg);<br>                            &#125;<br>                        &#125;);<br>                        <span class="hljs-comment">// Outbound主要处理出站操作，一般为写操作，发生出站操作时会触发Outbound方法</span><br>                        <span class="hljs-comment">// 出站时，handler的调用是从tail向前调用的</span><br>                        socketChannel.pipeline().addLast(<span class="hljs-string">&quot;handler3&quot;</span> ,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelOutboundHandlerAdapter</span>()&#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; Outbound handler 1&quot;</span>);<br>                                <span class="hljs-built_in">super</span>.write(ctx, msg, promise);<br>                            &#125;<br>                        &#125;);<br>                        socketChannel.pipeline().addLast(<span class="hljs-string">&quot;handler4&quot;</span> ,<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelOutboundHandlerAdapter</span>()&#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                                System.out.println(Thread.currentThread().getName() + <span class="hljs-string">&quot; Outbound handler 2&quot;</span>);<br>                                <span class="hljs-built_in">super</span>.write(ctx, msg, promise);<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果如下</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> Inbound handler <span class="hljs-number">1</span><br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> Inbound handler <span class="hljs-number">2</span><br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> Outbound handler <span class="hljs-number">2</span><br><span class="hljs-attribute">nioEventLoopGroup</span>-<span class="hljs-number">2</span>-<span class="hljs-number">2</span> Outbound handler <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>通过channel.pipeline().addLast(name, handler)添加handler时，<strong>记得给handler取名字</strong>。这样可以调用pipeline的<strong>addAfter、addBefore等方法更灵活地向pipeline中添加handler</strong></p><p>handler需要放入通道的pipeline中，才能根据放入顺序来使用handler</p><ul><li>pipeline是结构是一个带有head与tail指针的双向链表，其中的节点为handler<ul><li>要通过ctx.fireChannelRead(msg)等方法，<strong>将当前handler的处理结果传递给下一个handler</strong></li></ul></li><li>当有<strong>入站</strong>（Inbound）操作时，会从<strong>head开始向后</strong>调用handler，直到handler不是处理Inbound操作为止</li><li>当有<strong>出站</strong>（Outbound）操作时，会从<strong>tail开始向前</strong>调用handler，直到handler不是处理Outbound操作为止</li></ul><p><strong>具体结构如下</strong></p><p><img src="https://s2.loli.net/2023/04/11/VKfBbE4WLvTRtxn.png"></p><p><strong>调用顺序如下</strong></p><p><img src="https://s2.loli.net/2023/04/11/YOz2yesxLgR9Uo7.png"></p><h3 id="OutboundHandler"><a href="#OutboundHandler" class="headerlink" title="OutboundHandler"></a>OutboundHandler</h3><h4 id="socketChannel-writeAndFlush"><a href="#socketChannel-writeAndFlush" class="headerlink" title="socketChannel.writeAndFlush()"></a>socketChannel.writeAndFlush()</h4><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从tail向前寻找OutboundHandler</strong></p><p><img src="https://s2.loli.net/2023/04/11/RdKGAB5NmcW69wC.png"></p><h4 id="ctx-writeAndFlush"><a href="#ctx-writeAndFlush" class="headerlink" title="ctx.writeAndFlush()"></a>ctx.writeAndFlush()</h4><p>当handler中调用该方法进行写操作时，会触发Outbound操作，<strong>此时是从当前handler向前寻找OutboundHandler</strong></p><p><img src="https://s2.loli.net/2023/04/11/61onQ3TZbXdINCG.png"></p><h3 id="EmbeddedChannel"><a href="#EmbeddedChannel" class="headerlink" title="EmbeddedChannel"></a>EmbeddedChannel</h3><p>EmbeddedChannel可以用于测试各个handler，通过其构造函数按顺序传入需要测试handler，然后调用对应的Inbound和Outbound方法即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestEmbeddedChannel</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ChannelInboundHandlerAdapter</span> <span class="hljs-variable">h1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                System.out.println(<span class="hljs-string">&quot;1&quot;</span>);<br>                <span class="hljs-built_in">super</span>.channelRead(ctx, msg);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">ChannelInboundHandlerAdapter</span> <span class="hljs-variable">h2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                System.out.println(<span class="hljs-string">&quot;2&quot;</span>);<br>                <span class="hljs-built_in">super</span>.channelRead(ctx, msg);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">ChannelOutboundHandlerAdapter</span> <span class="hljs-variable">h3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelOutboundHandlerAdapter</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                System.out.println(<span class="hljs-string">&quot;3&quot;</span>);<br>                <span class="hljs-built_in">super</span>.write(ctx, msg, promise);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-type">ChannelOutboundHandlerAdapter</span> <span class="hljs-variable">h4</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelOutboundHandlerAdapter</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                System.out.println(<span class="hljs-string">&quot;4&quot;</span>);<br>                <span class="hljs-built_in">super</span>.write(ctx, msg, promise);<br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 用于测试Handler的Channel</span><br>        <span class="hljs-type">EmbeddedChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmbeddedChannel</span>(h1, h2, h3, h4);<br>        <br>        <span class="hljs-comment">// 执行Inbound操作 </span><br>        channel.writeInbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="hljs-string">&quot;hello&quot;</span>.getBytes(StandardCharsets.UTF_8)));<br>        <span class="hljs-comment">// 执行Outbound操作</span><br>        channel.writeOutbound(ByteBufAllocator.DEFAULT.buffer().writeBytes(<span class="hljs-string">&quot;hello&quot;</span>.getBytes(StandardCharsets.UTF_8)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-Bytebuf"><a href="#5-Bytebuf" class="headerlink" title="5.Bytebuf"></a>5.Bytebuf</h2><p><strong>调试工具方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">log</span><span class="hljs-params">(ByteBuf buffer)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> buffer.readableBytes();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rows</span> <span class="hljs-operator">=</span> length / <span class="hljs-number">16</span> + (length % <span class="hljs-number">15</span> == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>) + <span class="hljs-number">4</span>;<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>(rows * <span class="hljs-number">80</span> * <span class="hljs-number">2</span>)<br>        .append(<span class="hljs-string">&quot;read index:&quot;</span>).append(buffer.readerIndex())<br>        .append(<span class="hljs-string">&quot; write index:&quot;</span>).append(buffer.writerIndex())<br>        .append(<span class="hljs-string">&quot; capacity:&quot;</span>).append(buffer.capacity())<br>        .append(NEWLINE);<br>    appendPrettyHexDump(buf, buffer);<br>    System.out.println(buf.toString());<br>&#125;该方法可以帮助我们更为详细地查看ByteBuf中的内容<br></code></pre></td></tr></table></figure><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteBufStudy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建ByteBuf</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>);<br>        ByteBufUtil.log(buffer);<br><br>        <span class="hljs-comment">// 向buffer中写入数据</span><br>        <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++) &#123;<br>            sb.append(<span class="hljs-string">&quot;a&quot;</span>);<br>        &#125;<br>        buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));<br><br>        <span class="hljs-comment">// 查看写入结果</span><br>        ByteBufUtil.log(buffer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">read index:0 write index:0 capacity:16<br><br>read index:0 write index:20 capacity:64<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 61 |aaaaaaaaaaaaaaaa|<br><span class="hljs-section">|00000010| 61 61 61 61                                     |aaaa            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>ByteBuf<strong>通过<code>ByteBufAllocator</code>选择allocator并调用对应的buffer()方法来创建的</strong>，默认使用<strong>直接内存</strong>作为ByteBuf，容量为256个字节，可以指定初始容量的大小</p><p>当ByteBuf的容量无法容纳所有数据时，<strong>ByteBuf会进行扩容操作</strong></p><p><strong>如果在handler中创建ByteBuf，建议使用<code>ChannelHandlerContext ctx.alloc().buffer()</code>来创建</strong></p><h3 id="直接内存与堆内存"><a href="#直接内存与堆内存" class="headerlink" title="直接内存与堆内存"></a>直接内存与堆内存</h3><p>通过该方法创建的ByteBuf，使用的是<strong>基于直接内存</strong>的ByteBuf</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vhdl">ByteBuf <span class="hljs-keyword">buffer</span> = ByteBufAllocator.<span class="hljs-keyword">DEFAULT</span>.<span class="hljs-keyword">buffer</span>(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure><p>可以使用下面的代码来创建池化<strong>基于堆</strong>的 ByteBuf</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ByteBuf buffer <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.heapBuffer(<span class="hljs-number">16</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>也可以使用下面的代码来创建池化<strong>基于直接内存</strong>的 ByteBuf</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ByteBuf buffer <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.directBuffer(<span class="hljs-number">16</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><ul><li>直接内存创建和销毁的代价昂贵，但读写性能高（少一次内存复制），适合配合池化功能一起用</li><li>直接内存对 GC 压力小，因为这部分内存不受 JVM 垃圾回收的管理，但也要注意及时主动释放</li></ul><p><strong>验证</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteBufStudy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>);<br>        System.out.println(buffer.getClass());<br><br>        buffer = ByteBufAllocator.DEFAULT.heapBuffer(<span class="hljs-number">16</span>);<br>        System.out.println(buffer.getClass());<br><br>        buffer = ByteBufAllocator.DEFAULT.directBuffer(<span class="hljs-number">16</span>);<br>        System.out.println(buffer.getClass());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用池化的直接内存</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">io</span>.netty.buffer.PooledUnsafeDirectByteBuf<br>    <br><span class="hljs-comment">// 使用池化的堆内存    </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">io</span>.netty.buffer.PooledUnsafeHeapByteBuf<br>    <br><span class="hljs-comment">// 使用池化的直接内存    </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">io</span>.netty.buffer.PooledUnsafeDirectByteBuf<br></code></pre></td></tr></table></figure><h3 id="池化与非池化"><a href="#池化与非池化" class="headerlink" title="池化与非池化"></a>池化与非池化</h3><p>池化的最大意义在于可以<strong>重用</strong> ByteBuf，优点有</p><ul><li>没有池化，则每次都得创建新的 ByteBuf 实例，这个操作对直接内存代价昂贵，就算是堆内存，也会增加 GC 压力</li><li>有了池化，则可以重用池中 ByteBuf 实例，并且采用了与 jemalloc 类似的内存分配算法提升分配效率</li><li>高并发时，池化功能更节约内存，减少内存溢出的可能</li></ul><p>池化功能是否开启，可以通过下面的系统环境变量来设置</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm">-<span class="hljs-type">Dio</span>.netty.allocator.<span class="hljs-keyword">type</span>=&#123;unpooled|pooled&#125;<br></code></pre></td></tr></table></figure><ul><li>4.1 以后，<strong>非 Android 平台默认启用池化实现</strong>，Android 平台启用非池化实现</li><li>4.1 之前，池化功能还不成熟，默认是非池化实现</li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p>ByteBuf主要有以下几个组成部分</p><ul><li>最大容量与当前容量<ul><li>在构造ByteBuf时，可传入两个参数，分别代表初始容量和最大容量，若未传入第二个参数（最大容量），最大容量默认为Integer.MAX_VALUE</li><li>当ByteBuf容量无法容纳所有数据时，会进行扩容操作，若<strong>超出最大容量</strong>，会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</li></ul></li><li>读写操作不同于ByteBuffer只用position进行控制，<strong>ByteBuf分别由读指针和写指针两个指针控制。</strong>进行读写操作时，无需进行模式的切换<ul><li>读指针前的部分被称为废弃部分，是已经读过的内容</li><li>读指针与写指针之间的空间称为可读部分</li><li>写指针与当前容量之间的空间称为可写部分</li></ul></li></ul><p><img src="https://s2.loli.net/2023/04/11/J1A8VfQeBymO7sE.png"></p><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><p>常用方法如下</p><table><thead><tr><th>方法签名</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>writeBoolean(boolean value)</td><td>写入 boolean 值</td><td><strong>用一字节 01|00 代表 true|false</strong></td></tr><tr><td>writeByte(int value)</td><td>写入 byte 值</td><td></td></tr><tr><td>writeShort(int value)</td><td>写入 short 值</td><td></td></tr><tr><td>writeInt(int value)</td><td>写入 int 值</td><td>Big Endian（大端写入），即 0x250，写入后 00 00 02 50</td></tr><tr><td>writeIntLE(int value)</td><td>写入 int 值</td><td>Little Endian（小端写入），即 0x250，写入后 50 02 00 00</td></tr><tr><td>writeLong(long value)</td><td>写入 long 值</td><td></td></tr><tr><td>writeChar(int value)</td><td>写入 char 值</td><td></td></tr><tr><td>writeFloat(float value)</td><td>写入 float 值</td><td></td></tr><tr><td>writeDouble(double value)</td><td>写入 double 值</td><td></td></tr><tr><td>writeBytes(ByteBuf src)</td><td>写入 netty 的 ByteBuf</td><td></td></tr><tr><td>writeBytes(byte[] src)</td><td>写入 byte[]</td><td></td></tr><tr><td>writeBytes(ByteBuffer src)</td><td>写入 nio 的 <strong>ByteBuffer</strong></td><td></td></tr><tr><td>int writeCharSequence(CharSequence sequence, Charset charset)</td><td>写入字符串</td><td>CharSequence为字符串类的父类，第二个参数为对应的字符集</td></tr></tbody></table><blockquote><p>注意</p><ul><li>这些方法的未指明返回值的，其返回值都是 ByteBuf，意味着可以链式调用来写入不同的数据</li><li>网络传输中，<strong>默认习惯是 Big Endian</strong>，使用 writeInt(int value)</li></ul></blockquote><p><strong>使用方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteBufStudy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建ByteBuf</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>, <span class="hljs-number">20</span>);<br>        ByteBufUtil.log(buffer);<br><br>        <span class="hljs-comment">// 向buffer中写入数据</span><br>        buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);<br>        ByteBufUtil.log(buffer);<br><br>        buffer.writeInt(<span class="hljs-number">5</span>);<br>        ByteBufUtil.log(buffer);<br><br>        buffer.writeIntLE(<span class="hljs-number">6</span>);<br>        ByteBufUtil.log(buffer);<br><br>        buffer.writeLong(<span class="hljs-number">7</span>);<br>        ByteBufUtil.log(buffer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">read index:0 write index:0 capacity:16<br><br>read index:0 write index:4 capacity:16<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04                                     |....            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>read index:0 write index:8 capacity:16<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 00 00 00 05                         |........        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>read index:0 write index:12 capacity:16<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 00 00 00 05 06 00 00 00             |............    |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>read index:0 write index:20 capacity:20<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>|00000000| 01 02 03 04 00 00 00 05 06 00 00 00 00 00 00 00 |................|<br><span class="hljs-section">|00000010| 00 00 00 07                                     |....            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>还有一类方法是 <strong>set 开头</strong>的一系列方法，也<strong>可以写入数据，但不会改变写指针位置</strong></p><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><p>当ByteBuf中的容量无法容纳写入的数据时，会进行扩容操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">buffer.writeLong(<span class="hljs-number">7</span>);<br>ByteBufUtil.log(buffer);<br></code></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-comment">// 扩容前</span><br>read index:0 write index:12 capacity:16<br><span class="hljs-bullet">...</span><br><span class="hljs-bullet"></span><br><span class="hljs-bullet"></span><span class="hljs-comment">// 扩容后</span><br>read index:0 write index:20 capacity:20<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>|00000000| 01 02 03 04 00 00 00 05 06 00 00 00 00 00 00 00 |................|<br><span class="hljs-section">|00000010| 00 00 00 07                                     |....            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><h4 id="扩容规则"><a href="#扩容规则" class="headerlink" title="扩容规则"></a>扩容规则</h4><ul><li><p>如何写入后数据大小未超过 512 字节，则选择下一个 16 的整数倍进行扩容</p><ul><li>例如写入后大小为 12 字节，则扩容后 capacity 是 16 字节</li></ul></li><li><p>如果写入后数据大小超过 512 字节，则选择下一个 2</p><p>n</p><ul><li>例如写入后大小为 513 字节，则扩容后 capacity 是 210&#x3D;1024 字节（29&#x3D;512 已经不够了）</li></ul></li><li><p>扩容<strong>不能超过</strong> maxCapacity，否则会抛出<code>java.lang.IndexOutOfBoundsException</code>异常</p></li></ul><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> java.lang.IndexOutOfBoundsException: writer<span class="hljs-constructor">Index(20)</span> + min<span class="hljs-constructor">WritableBytes(8)</span> exceeds max<span class="hljs-constructor">Capacity(20)</span>: <span class="hljs-constructor">PooledUnsafeDirectByteBuf(<span class="hljs-params">ridx</span>: 0, <span class="hljs-params">widx</span>: 20, <span class="hljs-params">cap</span>: 20<span class="hljs-operator">/</span>20)</span><br>...<br></code></pre></td></tr></table></figure><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><p>读取主要是通过一系列read方法进行读取，读取时会根据读取数据的字节数移动读指针</p><p>如果需要<strong>重复读取</strong>，需要调用<code>buffer.markReaderIndex()</code>对读指针进行标记，并通过<code>buffer.resetReaderIndex()</code>将读指针恢复到mark标记的位置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ByteBufStudy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建ByteBuf</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>, <span class="hljs-number">20</span>);<br><br>        <span class="hljs-comment">// 向buffer中写入数据</span><br>        buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;);<br>        buffer.writeInt(<span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 读取4个字节</span><br>        System.out.println(buffer.readByte());<br>        System.out.println(buffer.readByte());<br>        System.out.println(buffer.readByte());<br>        System.out.println(buffer.readByte());<br>        ByteBufUtil.log(buffer);<br><br>        <span class="hljs-comment">// 通过mark与reset实现重复读取</span><br>        buffer.markReaderIndex();<br>        System.out.println(buffer.readInt());<br>        ByteBufUtil.log(buffer);<br><br>        <span class="hljs-comment">// 恢复到mark标记处</span><br>        buffer.resetReaderIndex();<br>        ByteBufUtil.log(buffer);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">1<br>2<br>3<br>4<br>read index:4 write index:8 capacity:16<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 00 00 00 05                                     |....            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>5<br>read index:8 write index:8 capacity:16<br><br>read index:4 write index:8 capacity:16<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 00 00 00 05                                     |....            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>还有以 get 开头的一系列方法，这些<strong>方法不会改变读指针的位置</strong></p><h3 id="释放"><a href="#释放" class="headerlink" title="释放"></a>释放</h3><p>由于 Netty 中有堆外内存（直接内存）的 ByteBuf 实现，<strong>堆外内存最好是手动来释放</strong>，而不是等 GC 垃圾回收。</p><ul><li>UnpooledHeapByteBuf 使用的是 JVM 内存，只需等 GC 回收内存即可</li><li>UnpooledDirectByteBuf 使用的就是直接内存了，需要特殊的方法来回收内存</li><li>PooledByteBuf 和它的子类使用了池化机制，需要更复杂的规则来回收内存</li></ul><p>Netty 这里采用了引用计数法来控制回收内存，每个 ByteBuf 都实现了 ReferenceCounted 接口</p><ul><li>每个 ByteBuf 对象的初始计数为 1</li><li>调用 release 方法计数减 1，如果计数为 0，ByteBuf 内存被回收</li><li>调用 retain 方法计数加 1，表示调用者没用完之前，其它 handler 即使调用了 release 也不会造成回收</li><li>当计数为 0 时，底层内存会被回收，这时即使 ByteBuf 对象还在，其各个方法均无法正常使用</li></ul><h4 id="释放规则"><a href="#释放规则" class="headerlink" title="释放规则"></a>释放规则</h4><p>因为 pipeline 的存在，一般需要将 ByteBuf 传递给下一个 ChannelHandler，如果在每个 ChannelHandler 中都去调用 release ，就失去了传递性（如果在这个 ChannelHandler 内这个 ByteBuf 已完成了它的使命，那么便无须再传递）</p><p><strong>基本规则是，谁是最后使用者，谁负责 release</strong></p><ul><li><p>起点，对于 NIO 实现来讲，在 io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe.read 方法中首次创建 ByteBuf 放入 pipeline（line 163 pipeline.fireChannelRead(byteBuf)）</p></li><li><p>入站 ByteBuf 处理原则</p><ul><li>对原始 ByteBuf 不做处理，调用 ctx.fireChannelRead(msg) 向后传递，这时无须 release</li><li><strong>将原始 ByteBuf 转换为其它类型的 Java 对象，这时 ByteBuf 就没用了，必须 release</strong></li><li><strong>如果不调用 ctx.fireChannelRead(msg) 向后传递，那么也必须 release</strong></li><li><strong>注意各种异常，如果 ByteBuf 没有成功传递到下一个 ChannelHandler，必须 release</strong></li><li>假设消息<strong>一直向后传</strong>，那么 TailContext 会负责释放未处理消息（原始的 ByteBuf）</li></ul></li><li><p>出站 ByteBuf 处理原则</p><ul><li><strong>出站消息最终都会转为 ByteBuf 输出，一直向前传，由 HeadContext flush 后 release</strong></li></ul></li><li><p>异常处理原则</p><ul><li>有时候不清楚 ByteBuf 被引用了多少次，但又必须彻底释放，可以<strong>循环调用 release 直到返回 true</strong></li></ul><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">while</span> (!<span class="hljs-built_in">buffer</span>.release()) &#123;&#125;<br></code></pre></td></tr></table></figure></li></ul><p>当ByteBuf<strong>被传到了pipeline的head与tail时</strong>，ByteBuf会被其中的方法彻底释放，但<strong>前提是ByteBuf被传递到了head与tail中</strong></p><p><strong>TailConext中释放ByteBuf的源码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUnhandledInboundMessage</span><span class="hljs-params">(Object msg)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        logger.debug(<span class="hljs-string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. Please check your pipeline configuration.&quot;</span>, msg);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 具体的释放方法</span><br>        ReferenceCountUtil.release(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>判断传过来的是否为ByteBuf，是的话才需要释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(Object msg)</span> &#123;<br><span class="hljs-keyword">return</span> msg <span class="hljs-keyword">instanceof</span> ReferenceCounted ? ((ReferenceCounted)msg).release() : <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>ByteBuf切片是【零拷贝】的体现之一，对原始 ByteBuf 进行切片成多个 ByteBuf，<strong>切片后的 ByteBuf 并没有发生内存复制，还是使用原始 ByteBuf 的内存</strong>，切片后的 ByteBuf 维护独立的 read，write 指针</p><p>得到分片后的buffer后，要调用其retain方法，使其内部的引用计数加一。避免原ByteBuf释放，导致切片buffer无法使用</p><p>修改原ByteBuf中的值，也会影响切片后得到的ByteBuf</p><p><img src="https://s2.loli.net/2023/04/11/9cIuEkJCweyVrft.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSlice</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建ByteBuf</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">16</span>, <span class="hljs-number">20</span>);<br><br>        <span class="hljs-comment">// 向buffer中写入数据</span><br>        buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;);<br><br>        <span class="hljs-comment">// 将buffer分成两部分</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">slice1</span> <span class="hljs-operator">=</span> buffer.slice(<span class="hljs-number">0</span>, <span class="hljs-number">5</span>);<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">slice2</span> <span class="hljs-operator">=</span> buffer.slice(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>);<br><br>        <span class="hljs-comment">// 需要让分片的buffer引用计数加一</span><br>        <span class="hljs-comment">// 避免原Buffer释放导致分片buffer无法使用</span><br>        slice1.retain();<br>        slice2.retain();<br>        <br>        ByteBufUtil.log(slice1);<br>        ByteBufUtil.log(slice2);<br><br>        <span class="hljs-comment">// 更改原始buffer中的值</span><br>        System.out.println(<span class="hljs-string">&quot;===========修改原buffer中的值===========&quot;</span>);<br>        buffer.setByte(<span class="hljs-number">0</span>,<span class="hljs-number">5</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;===========打印slice1===========&quot;</span>);<br>        ByteBufUtil.log(slice1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">read index:0 write index:5 capacity:5<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 01 02 03 04 05                                  |.....           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>read index:0 write index:5 capacity:5<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 06 07 08 09 0a                                  |.....           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>===========修改原buffer中的值===========<br>===========打印slice1===========<br>read index:0 write index:5 capacity:5<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 05 02 03 04 05                                  |.....           |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul><li>池化思想 - 可以重用池中 ByteBuf 实例，更节约内存，减少内存溢出的可能</li><li><strong>读写指针分离</strong>，不需要像 ByteBuffer 一样切换读写模式</li><li>可以<strong>自动扩容</strong></li><li>支持链式调用，使用更流畅</li><li>很多地方体现零拷贝，例如<ul><li>slice、duplicate、CompositeByteBuf</li></ul></li></ul><h1 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h1><h2 id="1-粘包与半包"><a href="#1-粘包与半包" class="headerlink" title="1.粘包与半包"></a>1.粘包与半包</h2><h3 id="服务器代码-1"><a href="#服务器代码-1" class="headerlink" title="服务器代码"></a>服务器代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudyServer</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(StudyServer.class);<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">boss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">serverBootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            serverBootstrap.channel(NioServerSocketChannel.class);<br>            serverBootstrap.group(boss, worker);<br>            serverBootstrap.childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> &#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG));<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-comment">// 连接建立时会执行该方法</span><br>                            log.debug(<span class="hljs-string">&quot;connected &#123;&#125;&quot;</span>, ctx.channel());<br>                            <span class="hljs-built_in">super</span>.channelActive(ctx);<br>                        &#125;<br><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-comment">// 连接断开时会执行该方法</span><br>                            log.debug(<span class="hljs-string">&quot;disconnect &#123;&#125;&quot;</span>, ctx.channel());<br>                            <span class="hljs-built_in">super</span>.channelInactive(ctx);<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> serverBootstrap.bind(<span class="hljs-number">8080</span>);<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125; binding...&quot;</span>, channelFuture.channel());<br>            channelFuture.sync();<br>            log.debug(<span class="hljs-string">&quot;&#123;&#125; bound...&quot;</span>, channelFuture.channel());<br>            <span class="hljs-comment">// 关闭channel</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;server error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            boss.shutdownGracefully();<br>            worker.shutdownGracefully();<br>            log.debug(<span class="hljs-string">&quot;stopped&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">StudyServer</span>().start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="粘包现象"><a href="#粘包现象" class="headerlink" title="粘包现象"></a>粘包现象</h3><p><strong>客户端代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StudyClient</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(StudyClient.class);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.group(worker);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    log.debug(<span class="hljs-string">&quot;connected...&quot;</span>);<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            log.debug(<span class="hljs-string">&quot;sending...&quot;</span>);<br>                            <span class="hljs-comment">// 每次发送16个字节的数据，共发送10次</span><br>                            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>                                <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ctx.alloc().buffer();<br>                                buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125;);<br>                                ctx.writeAndFlush(buffer);<br>                            &#125;<br>                        &#125;<br>                    &#125;);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8080</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            log.error(<span class="hljs-string">&quot;client error&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            worker.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>服务器接收结果</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs tap">7999 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x5b43ecb0, L:/127.0.0.1:8080 - R:/127.0.0.1:53797] READ: 160B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000010|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000020|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000030|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000040|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000050|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000060|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000070|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000080|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>|00000090|<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 02 </span>03<span class="hljs-number"> 04 </span>05<span class="hljs-number"> 06 </span>07<span class="hljs-number"> 08 </span>09 0a 0b 0c 0d 0e 0f |................|<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><p>可见虽然客户端是分别以16字节为单位，通过channel向服务器发送了10次数据，可是<strong>服务器端却只接收了一次，接收数据的大小为160B，即客户端发送的数据总大小，这就是粘包现象</strong></p><h3 id="半包现象"><a href="#半包现象" class="headerlink" title="半包现象"></a>半包现象</h3><p>将客户端-服务器之间的channel容量进行调整</p><p><strong>服务器代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调整channel的容量</span><br>serverBootstrap.option(ChannelOption.SO_RCVBUF, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><blockquote><p>serverBootstrap.option(ChannelOption.SO_RCVBUF, 10) 影响的底层接收缓冲区（即滑动窗口）大小，仅决定了 netty 读取的最小单位，<strong>netty 实际每次读取的一般是它的整数倍</strong></p></blockquote><p><strong>服务器接收结果</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 36B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br>|00000010| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|<br><span class="hljs-section">|00000020| 00 01 02 03                                     |....            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 40B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|<br>|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|<br><span class="hljs-section">|00000020| 04 05 06 07 08 09 0a 0b                         |........        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 40B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>|00000000| 0c 0d 0e 0f 00 01 02 03 04 05 06 07 08 09 0a 0b |................|<br>|00000010| 0c 0d 0e 0f 00 01 02 03 04 05 06 07 08 09 0a 0b |................|<br><span class="hljs-section">|00000020| 0c 0d 0e 0f 00 01 02 03                         |........        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 40B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br>|00000000| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|<br>|00000010| 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 00 01 02 03 |................|<br><span class="hljs-section">|00000020| 04 05 06 07 08 09 0a 0b                         |........        |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>5901 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xc73284f3, L:/127.0.0.1:8080 - R:/127.0.0.1:49679] READ: 4B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 0c 0d 0e 0f                                     |....            |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><p>可见客户端每次发送的数据，<strong>因channel容量不足，无法将发送的数据一次性接收</strong>，便产生了半包现象</p><h3 id="现象分析"><a href="#现象分析" class="headerlink" title="现象分析"></a>现象分析</h3><h4 id="粘包"><a href="#粘包" class="headerlink" title="粘包"></a>粘包</h4><ul><li>现象<ul><li>发送 abc def，接收 abcdef</li></ul></li><li>原因<ul><li>应用层<ul><li>接收方 ByteBuf 设置太大（Netty 默认 1024）</li></ul></li><li>传输层-网络层<ul><li>滑动窗口：假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且<strong>窗口大小足够大（大于256 bytes），这 256 bytes 字节就会缓冲在接收方的滑动窗口中，</strong>当滑动窗口中缓冲了多个报文就会粘包</li><li>Nagle 算法：会造成粘包</li></ul></li></ul></li></ul><h4 id="半包"><a href="#半包" class="headerlink" title="半包"></a>半包</h4><ul><li>现象<ul><li>发送 abcdef，接收 abc def</li></ul></li><li>原因<ul><li>应用层<ul><li>接收方 ByteBuf 小于实际发送数据量</li></ul></li><li>传输层-网络层<ul><li>滑动窗口：假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时<strong>接收方窗口中无法容纳发送方的全部报文，发送方只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包</strong></li></ul></li><li>数据链路层<ul><li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包</li></ul></li></ul></li></ul><h4 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h4><p>发生粘包与半包现象的本质是<strong>因为 TCP 是流式协议，消息无边界</strong></p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="短链接"><a href="#短链接" class="headerlink" title="短链接"></a>短链接</h4><p><strong>客户端每次向服务器发送数据以后，就与服务器断开连接，此时的消息边界为连接建立到连接断开</strong>。这时便无需使用滑动窗口等技术来缓冲数据，则不会发生粘包现象。但如果一次性数据发送过多，接收方无法一次性容纳所有数据，还是会发生半包现象，所以<strong>短链接无法解决半包现象</strong></p><p><strong>客户端代码改进</strong></p><p>修改channelActive方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    log.debug(<span class="hljs-string">&quot;sending...&quot;</span>);<br>    <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ctx.alloc().buffer(<span class="hljs-number">16</span>);<br>    buffer.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>, <span class="hljs-number">15</span>&#125;);<br>    ctx.writeAndFlush(buffer);<br>    <span class="hljs-comment">// 使用短链接，每次发送完毕后就断开连接</span><br>    ctx.channel().close();<br>&#125;<br></code></pre></td></tr></table></figure><p>将发送步骤整体封装为send()方法，调用10次send()方法，模拟发送10次数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-comment">// 发送10次</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>        send();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">6452 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:/127.0.0.1:8080 - R:/127.0.0.1:65024] ACTIVE<br><br>6468 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:/127.0.0.1:8080 - R:/127.0.0.1:65024] READ: 16B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>6468 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x3eb6a684, L:/127.0.0.1:8080 ! R:/127.0.0.1:65024] INACTIVE<br><br>6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:/127.0.0.1:8080 - R:/127.0.0.1:65057] ACTIVE<br><br>6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:/127.0.0.1:8080 - R:/127.0.0.1:65057] READ: 16B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f |................|</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>6483 [nioEventLoopGroup-3-2] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x7dcc31ff, L:/127.0.0.1:8080 ! R:/127.0.0.1:65057] INACTIVE<br><br>...<br></code></pre></td></tr></table></figure><p>客户端先于服务器建立连接，此时控制台打印<code>ACTIVE</code>，之后客户端向服务器发送了16B的数据，发送后断开连接，此时控制台打印<code>INACTIVE</code>，可见<strong>未出现粘包现象</strong></p><h4 id="定长解码器"><a href="#定长解码器" class="headerlink" title="定长解码器"></a>定长解码器</h4><p>客户端于服务器<strong>约定一个最大长度，保证客户端每次发送的数据长度都不会大于该长度</strong>。若发送数据长度不足则需要<strong>补齐</strong>至该长度</p><p>服务器接收数据时，<strong>将接收到的数据按照约定的最大长度进行拆分</strong>，即使发送过程中产生了粘包，也可以通过定长解码器将数据正确地进行拆分。<strong>服务端需要用到<code>FixedLengthFrameDecoder</code>对数据进行定长解码</strong>，具体使用方法如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FixedLengthFrameDecoder</span>(<span class="hljs-number">16</span>));<br></code></pre></td></tr></table></figure><p><strong>客户端代码</strong></p><p>客户端发送数据的代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 约定最大长度为16</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">16</span>;<br><span class="hljs-comment">// 被发送的数据</span><br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-comment">// 向服务器发送10个报文</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ctx.alloc().buffer(maxLength);<br>    <span class="hljs-comment">// 定长byte数组，未使用部分会以0进行填充</span><br>    <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[maxLength];<br>    <span class="hljs-comment">// 生成长度为0~15的数据</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; (<span class="hljs-type">int</span>)(Math.random()*(maxLength-<span class="hljs-number">1</span>)); j++) &#123;<br>        bytes[j] = (<span class="hljs-type">byte</span>) c;<br>    &#125;<br>    buffer.writeBytes(bytes);<br>    c++;<br>    <span class="hljs-comment">// 将数据发送给服务器</span><br>    ctx.writeAndFlush(buffer);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>服务器代码</strong></p><p>使用<code>FixedLengthFrameDecoder</code>对粘包数据进行拆分，该handler需要添加在<code>LoggingHandler</code>之前，保证数据被打印时已被拆分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过定长解码器对粘包数据进行拆分</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FixedLengthFrameDecoder</span>(<span class="hljs-number">16</span>));<br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG));<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:/127.0.0.1:8080 - R:/127.0.0.1:52954] READ: 16B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61 61 61 61 00 00 00 00 00 00 00 00 00 00 00 00 |aaaa............|</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:/127.0.0.1:8080 - R:/127.0.0.1:52954] READ: 16B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 62 62 62 00 00 00 00 00 00 00 00 00 00 00 00 00 |bbb.............|</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br><br>8222 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xbc122d07, L:/127.0.0.1:8080 - R:/127.0.0.1:52954] READ: 16B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 63 63 00 00 00 00 00 00 00 00 00 00 00 00 00 00 |cc..............|</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>...<br></code></pre></td></tr></table></figure><h4 id="行解码器"><a href="#行解码器" class="headerlink" title="行解码器"></a>行解码器</h4><p>行解码器的是<strong>通过分隔符对数据进行拆分</strong>来解决粘包半包问题的</p><p>可以通过<code>LineBasedFrameDecoder(int maxLength)</code>来拆分以<strong>换行符(\n)<strong>为分隔符的数据，也可以通过<code>DelimiterBasedFrameDecoder(int maxFrameLength, ByteBuf... delimiters)</code>来</strong>指定通过什么分隔符来拆分数据（可以传入多个分隔符）</strong></p><p>两种解码器<strong>都需要传入数据的最大长度</strong>，若超出最大长度，会抛出<code>TooLongFrameException</code>异常</p><p><strong>以换行符 \n 为分隔符</strong></p><p>客户端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 约定最大长度为 64</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">maxLength</span> <span class="hljs-operator">=</span> <span class="hljs-number">64</span>;<br><span class="hljs-comment">// 被发送的数据</span><br><span class="hljs-type">char</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;a&#x27;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>    <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ctx.alloc().buffer(maxLength);<br>    <span class="hljs-comment">// 生成长度为0~62的数据</span><br>    <span class="hljs-type">Random</span> <span class="hljs-variable">random</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>();<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">sb</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; (<span class="hljs-type">int</span>)(random.nextInt(maxLength-<span class="hljs-number">2</span>)); j++) &#123;<br>        sb.append(c);<br>    &#125;<br>    <span class="hljs-comment">// 数据以 \n 结尾</span><br>    sb.append(<span class="hljs-string">&quot;\n&quot;</span>);<br>    buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));<br>    c++;<br>    <span class="hljs-comment">// 将数据发送给服务器</span><br>    ctx.writeAndFlush(buffer);<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 通过行解码器对粘包数据进行拆分，以 \n 为分隔符</span><br><span class="hljs-comment">// 需要指定最大长度</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelimiterBasedFrameDecoder</span>(<span class="hljs-number">64</span>));<br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG));<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:/127.0.0.1:8080 - R:/127.0.0.1:58282] READ: 10B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61 61 61 61 61 61 61 61 61 61                   |aaaaaaaaaa      |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:/127.0.0.1:8080 - R:/127.0.0.1:58282] READ: 11B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 62 62 62 62 62 62 62 62 62 62 62                |bbbbbbbbbbb     |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>4184 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x9d6ac701, L:/127.0.0.1:8080 - R:/127.0.0.1:58282] READ: 2B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 63 63                                           |cc              |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>...<br></code></pre></td></tr></table></figure><p><strong>以自定义分隔符 \c 为分隔符</strong></p><p>客户端代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">...<br>    <br><span class="hljs-comment">// 数据以 \c 结尾</span><br>sb.append(<span class="hljs-string">&quot;\\c&quot;</span>);<br>buffer.writeBytes(sb.toString().getBytes(StandardCharsets.UTF_8));<br><br>...<br></code></pre></td></tr></table></figure><p>服务器代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 将分隔符放入ByteBuf中</span><br><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">bufSet</span> <span class="hljs-operator">=</span> ch.alloc().buffer().writeBytes(<span class="hljs-string">&quot;\\c&quot;</span>.getBytes(StandardCharsets.UTF_8));<br><span class="hljs-comment">// 通过行解码器对粘包数据进行拆分，以 \c 为分隔符</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DelimiterBasedFrameDecoder</span>(<span class="hljs-number">64</span>, ch.alloc().buffer().writeBytes(bufSet)));<br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG));<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">8246 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:/127.0.0.1:8080 - R:/127.0.0.1:65159] READ: 14B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 61 61 61 61 61 61 61 61 61 61 61 61 61 61       |aaaaaaaaaaaaaa  |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br><br>8247 [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0x86215ccd, L:/127.0.0.1:8080 - R:/127.0.0.1:65159] READ: 3B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| 62 62 62                                        |bbb             |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>...<br></code></pre></td></tr></table></figure><h4 id="长度字段解码器"><a href="#长度字段解码器" class="headerlink" title="长度字段解码器"></a>长度字段解码器</h4><p>在传送数据时可以在数据中<strong>添加一个用于表示有用数据长度的字段</strong>，在解码时读取出这个用于表明长度的字段，同时读取其他相关参数，即可知道最终需要的数据是什么样子的</p><p><code>LengthFieldBasedFrameDecoder</code>解码器可以提供更为丰富的拆分方法，其构造方法有五个参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">LengthFieldBasedFrameDecoder</span><span class="hljs-params">(</span><br><span class="hljs-params">    <span class="hljs-type">int</span> maxFrameLength,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> lengthFieldOffset, <span class="hljs-type">int</span> lengthFieldLength,</span><br><span class="hljs-params">    <span class="hljs-type">int</span> lengthAdjustment, <span class="hljs-type">int</span> initialBytesToStrip)</span><br></code></pre></td></tr></table></figure><p><strong>参数解析</strong></p><ul><li>maxFrameLength 数据最大长度<ul><li>表示数据的最大长度（包括附加信息、长度标识等内容）</li></ul></li><li>lengthFieldOffset <strong>数据长度标识的起始偏移量</strong><ul><li>用于指明数据第几个字节开始是用于标识有用字节长度的，因为前面可能还有其他附加信息</li></ul></li><li>lengthFieldLength <strong>数据长度标识所占字节数</strong>（用于指明有用数据的长度）<ul><li>数据中用于表示有用数据长度的标识所占的字节数</li></ul></li><li>lengthAdjustment <strong>长度表示与有用数据的偏移量</strong><ul><li>用于指明数据长度标识和有用数据之间的距离，因为两者之间还可能有附加信息</li></ul></li><li>initialBytesToStrip <strong>数据读取起点</strong><ul><li>读取起点，<strong>不读取</strong> 0 ~ initialBytesToStrip 之间的数据</li></ul></li></ul><p><strong>参数图解</strong></p><p><img src="https://s2.loli.net/2023/04/11/KaQJq5DfFLvTUnW.png"></p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">lengthFieldOffset   = 0<br>lengthFieldLength   = 2<br>lengthAdjustment    = 0<br>initialBytesToStrip = 0 (= do not strip header)<br>  <br>BEFORE DECODE (14 bytes)         AFTER DECODE (14 bytes)<br>+--------+----------------+      +--------+----------------+<br>|<span class="hljs-string"> Length </span>|<span class="hljs-string"> Actual Content </span>|<span class="hljs-string">-----&gt;</span>|<span class="hljs-string"> Length </span>|<span class="hljs-string"> Actual Content </span>|<br>|<span class="hljs-string"> 0x000C </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<span class="hljs-string">      </span>|<span class="hljs-string"> 0x000C </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<br>+--------+----------------+      +--------+----------------+<br></code></pre></td></tr></table></figure><p>从0开始即为长度标识，长度标识长度为2个字节</p><p><strong>0x000C</strong> 即为后面 <code>HELLO, WORLD</code>的长度</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">lengthFieldOffset   = 0<br>lengthFieldLength   = 2<br>lengthAdjustment    = 0<br>initialBytesToStrip = 2 (= the length of the Length field)<br>  <br>BEFORE DECODE (14 bytes)         AFTER DECODE (12 bytes)<br>+--------+----------------+      +----------------+<br>|<span class="hljs-string"> Length </span>|<span class="hljs-string"> Actual Content </span>|<span class="hljs-string">-----&gt;</span>|<span class="hljs-string"> Actual Content </span>|<br>|<span class="hljs-string"> 0x000C </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<span class="hljs-string">      </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<br>+--------+----------------+      +----------------+<br></code></pre></td></tr></table></figure><p>从0开始即为长度标识，长度标识长度为2个字节，<strong>读取时从第二个字节开始读取</strong>（此处即跳过长度标识）</p><p>因为<strong>跳过了用于表示长度的2个字节</strong>，所以此处直接读取<code>HELLO, WORLD</code></p><hr><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">lengthFieldOffset   = 2 (= the length of Header 1)<br>lengthFieldLength   = 3<br>lengthAdjustment    = 0<br>initialBytesToStrip = 0<br>  <br>BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)<br>+----------+----------+----------------+      +----------+----------+----------------+<br>|<span class="hljs-string"> Header 1 </span>|<span class="hljs-string">  Length  </span>|<span class="hljs-string"> Actual Content </span>|<span class="hljs-string">-----&gt;</span>|<span class="hljs-string"> Header 1 </span>|<span class="hljs-string">  Length  </span>|<span class="hljs-string"> Actual Content </span>|<br>|<span class="hljs-string">  0xCAFE  </span>|<span class="hljs-string"> 0x00000C </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<span class="hljs-string">      </span>|<span class="hljs-string">  0xCAFE  </span>|<span class="hljs-string"> 0x00000C </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<br>+----------+----------+----------------+      +----------+----------+----------------+<br></code></pre></td></tr></table></figure><p>长度标识<strong>前面还有2个字节的其他内容</strong>（0xCAFE），第三个字节开始才是长度标识，长度表示长度为3个字节(0x00000C)</p><p>Header1中有附加信息，<strong>读取长度标识时需要跳过这些附加信息来获取长度</strong></p><hr><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">lengthFieldOffset   = 0<br>lengthFieldLength   = 3<br>lengthAdjustment    = 2 (= the length of Header 1)<br>initialBytesToStrip = 0<br>  <br>BEFORE DECODE (17 bytes)                      AFTER DECODE (17 bytes)<br>+----------+----------+----------------+      +----------+----------+----------------+<br>|<span class="hljs-string">  Length  </span>|<span class="hljs-string"> Header 1 </span>|<span class="hljs-string"> Actual Content </span>|<span class="hljs-string">-----&gt;</span>|<span class="hljs-string">  Length  </span>|<span class="hljs-string"> Header 1 </span>|<span class="hljs-string"> Actual Content </span>|<br>|<span class="hljs-string"> 0x00000C </span>|<span class="hljs-string">  0xCAFE  </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<span class="hljs-string">      </span>|<span class="hljs-string"> 0x00000C </span>|<span class="hljs-string">  0xCAFE  </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<br>+----------+----------+----------------+      +----------+----------+----------------+<br></code></pre></td></tr></table></figure><p>&#96;&#96;</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">从<span class="hljs-number">0</span>开始即为长度标识，长度标识长度为<span class="hljs-number">3</span>个字节，**长度标识之后还有<span class="hljs-number">2</span>个字节的其他内容**（<span class="hljs-number">0xCAFE</span>）<br>长度标识(<span class="hljs-number">0x00000C</span>)表示的是**从其后lengthAdjustment（<span class="hljs-number">2</span>个字节）开始的数据的长度，即<span class="hljs-string">`HELLO, WORLD`</span>**，不包括<span class="hljs-number">0xCAFE</span><br></code></pre></td></tr></table></figure><hr><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">lengthFieldOffset   = 1 (= the length of HDR1)<br>lengthFieldLength   = 2<br>lengthAdjustment    = 1 (= the length of HDR2)<br>initialBytesToStrip = 3 (= the length of HDR1 + LEN)<br>  <br>BEFORE DECODE (16 bytes)                       AFTER DECODE (13 bytes)<br>+------+--------+------+----------------+      +------+----------------+<br>|<span class="hljs-string"> HDR1 </span>|<span class="hljs-string"> Length </span>|<span class="hljs-string"> HDR2 </span>|<span class="hljs-string"> Actual Content </span>|<span class="hljs-string">-----&gt;</span>|<span class="hljs-string"> HDR2 </span>|<span class="hljs-string"> Actual Content </span>|<br>|<span class="hljs-string"> 0xCA </span>|<span class="hljs-string"> 0x000C </span>|<span class="hljs-string"> 0xFE </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<span class="hljs-string">      </span>|<span class="hljs-string"> 0xFE </span>|<span class="hljs-string"> &quot;HELLO, WORLD&quot; </span>|<br>+------+--------+------+----------------+      +------+----------------+<br></code></pre></td></tr></table></figure><p>长度标识<strong>前面有1个字节的其他内容，后面也有1个字节的其他内容，读取时从长度标识之后3个字节处开始读取</strong>，即读取 <code>0xFE HELLO, WORLD</code></p><p><strong>使用</strong></p><p>通过 <strong>EmbeddedChannel</strong> 对 handler 进行测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EncoderStudy</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 模拟服务器</span><br>        <span class="hljs-comment">// 使用EmbeddedChannel测试handler</span><br>        <span class="hljs-type">EmbeddedChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmbeddedChannel</span>(<br>                <span class="hljs-comment">// 数据最大长度为1KB，长度标识前后各有1个字节的附加信息，长度标识长度为4个字节（int）</span><br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LengthFieldBasedFrameDecoder</span>(<span class="hljs-number">1024</span>, <span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG)<br>        );<br><br>        <span class="hljs-comment">// 模拟客户端，写入数据</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.buffer();<br>        send(buffer, <span class="hljs-string">&quot;Hello&quot;</span>);<br>        channel.writeInbound(buffer);<br>        send(buffer, <span class="hljs-string">&quot;World&quot;</span>);<br>        channel.writeInbound(buffer);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(ByteBuf buf, String msg)</span> &#123;<br>        <span class="hljs-comment">// 得到数据的长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> msg.length();<br>        <span class="hljs-type">byte</span>[] bytes = msg.getBytes(StandardCharsets.UTF_8);<br>        <span class="hljs-comment">// 将数据信息写入buf</span><br>        <span class="hljs-comment">// 写入长度标识前的其他信息</span><br>        buf.writeByte(<span class="hljs-number">0xCA</span>);<br>        <span class="hljs-comment">// 写入数据长度标识</span><br>        buf.writeInt(length);<br>        <span class="hljs-comment">// 写入长度标识后的其他信息</span><br>        buf.writeByte(<span class="hljs-number">0xFE</span>);<br>        <span class="hljs-comment">// 写入具体的数据</span><br>        buf.writeBytes(bytes);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">146  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| ca 00 00 00 05 fe 48 65 6c 6c 6f                |......Hello     |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><br>146  [main] DEBUG io.netty.handler.logging.LoggingHandler  - [id: 0xembedded, L:embedded - R:embedded] READ: 11B<br><span class="hljs-code">         +-------------------------------------------------+</span><br><span class="hljs-section">         |  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br><span class="hljs-section">|00000000| ca 00 00 00 05 fe 57 6f 72 6c 64                |......World     |</span><br><span class="hljs-section">+--------+-------------------------------------------------+----------------+</span><br></code></pre></td></tr></table></figure><h2 id="2-协议设计与解析"><a href="#2-协议设计与解析" class="headerlink" title="2.协议设计与解析"></a>2.协议设计与解析</h2><h3 id="协议的作用"><a href="#协议的作用" class="headerlink" title="协议的作用"></a>协议的作用</h3><p>TCP&#x2F;IP 中消息传输基于流的方式，没有边界</p><p><strong>协议的目的就是划定消息的边界，制定通信双方要共同遵守的通信规则</strong></p><h3 id="Redis协议"><a href="#Redis协议" class="headerlink" title="Redis协议"></a>Redis协议</h3><p>如果我们要向Redis服务器发送一条<code>set name Youzi</code>的指令，需要遵守如下协议</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 该指令一共有<span class="hljs-number">3</span>部分，每条指令之后都要添加回车与换行符<br>*<span class="hljs-number">3</span>\r\n<br><span class="hljs-regexp">//</span> 第一个指令的长度是<span class="hljs-number">3</span><br><span class="hljs-variable">$3</span>\r\n<br><span class="hljs-regexp">//</span> 第一个指令是set指令<br>set\r\n<br><span class="hljs-regexp">//</span> 下面的指令以此类推<br><span class="hljs-variable">$4</span>\r\n<br>name\r\n<br><span class="hljs-variable">$5</span>\r\n<br>Nyima\r\n<br></code></pre></td></tr></table></figure><p><strong>客户端代码如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisClient</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(StudyServer.class);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span>  <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>()<br>                    .group(group)<br>                    .channel(NioSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> &#123;<br>                            <span class="hljs-comment">// 打印日志</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG));<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>                                <span class="hljs-meta">@Override</span><br>                                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                                    <span class="hljs-comment">// 回车与换行符</span><br>                                    <span class="hljs-keyword">final</span> <span class="hljs-type">byte</span>[] LINE = &#123;<span class="hljs-string">&#x27;\r&#x27;</span>,<span class="hljs-string">&#x27;\n&#x27;</span>&#125;;<br>                                    <span class="hljs-comment">// 获得ByteBuf</span><br>                                    <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ctx.alloc().buffer();<br>                                    <span class="hljs-comment">// 连接建立后，向Redis中发送一条指令，注意添加回车与换行</span><br>                                    <span class="hljs-comment">// set name Nyima</span><br>                                    buffer.writeBytes(<span class="hljs-string">&quot;*3&quot;</span>.getBytes());<br>                                    buffer.writeBytes(LINE);<br>                                    buffer.writeBytes(<span class="hljs-string">&quot;$3&quot;</span>.getBytes());<br>                                    buffer.writeBytes(LINE);<br>                                    buffer.writeBytes(<span class="hljs-string">&quot;set&quot;</span>.getBytes());<br>                                    buffer.writeBytes(LINE);<br>                                    buffer.writeBytes(<span class="hljs-string">&quot;$4&quot;</span>.getBytes());<br>                                    buffer.writeBytes(LINE);<br>                                    buffer.writeBytes(<span class="hljs-string">&quot;name&quot;</span>.getBytes());<br>                                    buffer.writeBytes(LINE);<br>                                    buffer.writeBytes(<span class="hljs-string">&quot;$5&quot;</span>.getBytes());<br>                                    buffer.writeBytes(LINE);<br>                                    buffer.writeBytes(<span class="hljs-string">&quot;Youzi&quot;</span>.getBytes());<br>                                    buffer.writeBytes(LINE);<br>                                    ctx.writeAndFlush(buffer);<br>                                &#125;<br><br>                            &#125;);<br>                        &#125;<br>                    &#125;)<br>                    .connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">6379</span>));<br>            channelFuture.sync();<br>            <span class="hljs-comment">// 关闭channel</span><br>            channelFuture.channel().close().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 关闭group</span><br>            group.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>控制台打印结果</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tap">[nioEventLoopGroup-2-1] DEBUG io.netty.handler.logging.LoggingHandler - [id: 0x515329dc, L:/127.0.0.1:52542 - R:localhost/127.0.0.1:6379] WRITE: 34B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000| 2a<span class="hljs-number"> 33 </span>0d 0a<span class="hljs-number"> 24 </span>33 0d 0a<span class="hljs-number"> 73 </span>65<span class="hljs-number"> 74 </span>0d 0a<span class="hljs-number"> 24 </span>34 0d |*3..$3..set..$4.|<br>|00000010| 0a 6e<span class="hljs-number"> 61 </span>6d<span class="hljs-number"> 65 </span>0d 0a<span class="hljs-number"> 24 </span>35 0d 0a<span class="hljs-number"> 59 </span>6f<span class="hljs-number"> 75 </span>7a<span class="hljs-number"> 69 </span>|.name..$5..Youzi|<br>|00000020| 0d 0a                                           |..              |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><p><strong>Redis中查询执行结果</strong></p><p><img src="https://s2.loli.net/2023/04/11/POYXK48gs5ErxUT.png"></p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h3><p>HTTP协议在请求行请求头中都有很多的内容，自己实现较为困难，可以使用<code>HttpServerCodec</code>作为<strong>服务器端的解码器与编码器，来处理HTTP请求</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// HttpServerCodec 中既有请求的解码器 HttpRequestDecoder 又有响应的编码器 HttpResponseEncoder</span><br><span class="hljs-comment">// Codec(CodeCombine) 一般代表该类既作为 编码器 又作为 解码器</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServerCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">CombinedChannelDuplexHandler</span>&lt;HttpRequestDecoder, HttpResponseEncoder&gt;<br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">HttpServerUpgradeHandler</span>.SourceCodec<br></code></pre></td></tr></table></figure><p><strong>服务器代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpServer</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(StudyServer.class);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>()<br>                .group(group)<br>                .channel(NioServerSocketChannel.class)<br>                .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> &#123;<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG));<br>                        <span class="hljs-comment">// 作为服务器，使用 HttpServerCodec 作为编码器与解码器</span><br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpServerCodec</span>());<br>                        <span class="hljs-comment">// 服务器只处理HTTPRequest</span><br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;HttpRequest&gt;() &#123;<br>                            <span class="hljs-meta">@Override</span><br>                            <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, HttpRequest msg)</span> &#123;<br>                                <span class="hljs-comment">// 获得请求uri</span><br>                                log.debug(msg.uri());<br><br>                                <span class="hljs-comment">// 获得完整响应，设置版本号与状态码</span><br>                                <span class="hljs-type">DefaultFullHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultFullHttpResponse</span>(msg.protocolVersion(), HttpResponseStatus.OK);<br>                                <span class="hljs-comment">// 设置响应内容</span><br>                                <span class="hljs-type">byte</span>[] bytes = <span class="hljs-string">&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;</span>.getBytes(StandardCharsets.UTF_8);<br>                                <span class="hljs-comment">// 设置响应体长度，避免浏览器一直接收响应内容</span><br>                                response.headers().setInt(CONTENT_LENGTH, bytes.length);<br>                                <span class="hljs-comment">// 设置响应体</span><br>                                response.content().writeBytes(bytes);<br><br>                                <span class="hljs-comment">// 写回响应</span><br>                                ctx.writeAndFlush(response);<br>                            &#125;<br>                        &#125;);<br>                    &#125;<br>                &#125;)<br>                .bind(<span class="hljs-number">8080</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器负责处理请求并响应浏览器。所以<strong>只需要处理HTTP请求</strong>即可</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 服务器只处理HTTPRequest</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-type">SimpleChannelInboundHandler</span>&lt;HttpRequest&gt;()<br></code></pre></td></tr></table></figure><p>获得请求后，需要返回响应给浏览器。需要创建响应对象<code>DefaultFullHttpResponse</code>，设置HTTP版本号及状态码，为避免浏览器获得响应后，因为获得<code>CONTENT_LENGTH</code>而一直空转，需要添加<code>CONTENT_LENGTH</code>字段，表明响应体中数据的具体长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获得完整响应，设置版本号与状态码</span><br><span class="hljs-type">DefaultFullHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultFullHttpResponse</span>(msg.protocolVersion(), HttpResponseStatus.OK);<br><span class="hljs-comment">// 设置响应内容</span><br><span class="hljs-type">byte</span>[] bytes = <span class="hljs-string">&quot;&lt;h1&gt;Hello, World!&lt;/h1&gt;&quot;</span>.getBytes(StandardCharsets.UTF_8);<br><span class="hljs-comment">// 设置响应体长度，避免浏览器一直接收响应内容</span><br>response.headers().setInt(CONTENT_LENGTH, bytes.length);<br><span class="hljs-comment">// 设置响应体</span><br>response.content().writeBytes(bytes);<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>浏览器</p><img src="https://s2.loli.net/2023/04/11/P8IslVmfjSvQhZ5.png" style="zoom:50%;" /><p>控制台</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs tap">//请求内容<br>[nioEventLoopGroup-2-2] DEBUG io.netty.handler.logging.LoggingHandler - [id: 0x85f2e1e9, L:/0:0:0:0:0:0:0:1:8080 - R:/0:0:0:0:0:0:0:1:53182] READ: 631B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 47 </span>45<span class="hljs-number"> 54 </span>20 2f<span class="hljs-number"> 66 </span>61<span class="hljs-number"> 76 </span>69<span class="hljs-number"> 63 </span>6f 6e 2e<span class="hljs-number"> 69 </span>63 6f |GET /favicon.ico|<br>|00000010|<span class="hljs-number"> 20 </span>48<span class="hljs-number"> 54 </span>54<span class="hljs-number"> 50 </span>2f<span class="hljs-number"> 31 </span>2e<span class="hljs-number"> 31 </span>0d 0a<span class="hljs-number"> 48 </span>6f<span class="hljs-number"> 73 </span>74 3a | HTTP/1.1..Host:|<br>|00000020|<span class="hljs-number"> 20 </span>6c 6f<span class="hljs-number"> 63 </span>61 6c<span class="hljs-number"> 68 </span>6f<span class="hljs-number"> 73 </span>74 3a<span class="hljs-number"> 38 </span>30<span class="hljs-number"> 38 </span>30 0d | localhost:8080.|<br>|00000030| 0a<span class="hljs-number"> 43 </span>6f 6e 6e<span class="hljs-number"> 65 </span>63<span class="hljs-number"> 74 </span>69 6f 6e 3a<span class="hljs-number"> 20 </span>6b<span class="hljs-number"> 65 </span>65 |.Connection: kee|<br>|00000040|<span class="hljs-number"> 70 </span>2d<span class="hljs-number"> 61 </span>6c<span class="hljs-number"> 69 </span>76<span class="hljs-number"> 65 </span>0d 0a<span class="hljs-number"> 73 </span>65<span class="hljs-number"> 63 </span>2d<span class="hljs-number"> 63 </span>68 2d |p-alive..sec-ch-|<br>|00000050|<span class="hljs-number"> 75 </span>61 3a<span class="hljs-number"> 20 </span>22 4d<span class="hljs-number"> 69 </span>63<span class="hljs-number"> 72 </span>6f<span class="hljs-number"> 73 </span>6f<span class="hljs-number"> 66 </span>74<span class="hljs-number"> 20 </span>45 |ua: &quot;Microsoft E|<br>//响应内容<br>[nioEventLoopGroup-2-2] DEBUG io.netty.handler.logging.LoggingHandler - [id: 0x85f2e1e9, L:/0:0:0:0:0:0:0:1:8080 - R:/0:0:0:0:0:0:0:1:53182] WRITE: 61B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 48 </span>54<span class="hljs-number"> 54 </span>50 2f<span class="hljs-number"> 31 </span>2e<span class="hljs-number"> 31 </span>20<span class="hljs-number"> 32 </span>30<span class="hljs-number"> 30 </span>20 4f 4b 0d |HTTP/1.1<span class="hljs-number"> 200 </span>OK.|<br>|00000010| 0a<span class="hljs-number"> 63 </span>6f 6e<span class="hljs-number"> 74 </span>65 6e<span class="hljs-number"> 74 </span>2d 6c<span class="hljs-number"> 65 </span>6e<span class="hljs-number"> 67 </span>74<span class="hljs-number"> 68 </span>3a |.content-length:|<br>|00000020|<span class="hljs-number"> 20 </span>32<span class="hljs-number"> 32 </span>0d 0a 0d 0a 3c<span class="hljs-number"> 68 </span>31 3e<span class="hljs-number"> 48 </span>65 6c 6c 6f | 22....&lt;h1&gt;Hello|<br>|00000030| 2c<span class="hljs-number"> 20 </span>57 6f<span class="hljs-number"> 72 </span>6c<span class="hljs-number"> 64 </span>21 3c 2f<span class="hljs-number"> 68 </span>31 3e          |, World!&lt;/h1&gt;   |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><h3 id="自定义协议"><a href="#自定义协议" class="headerlink" title="自定义协议"></a>自定义协议</h3><h4 id="组成要素"><a href="#组成要素" class="headerlink" title="组成要素"></a>组成要素</h4><ul><li><p><strong>魔数</strong>：用来在第一时间判定接收的数据是否为无效数据包</p></li><li><p><strong>版本号</strong>：可以支持协议的升级</p></li><li><p>序列化算法</p><p>：消息正文到底采用哪种序列化反序列化方式</p><ul><li>如：json、protobuf、hessian、jdk</li></ul></li><li><p><strong>指令类型</strong>：是登录、注册、单聊、群聊… 跟业务相关</p></li><li><p><strong>请求序号</strong>：为了双工通信，提供异步能力</p></li><li><p><strong>正文长度</strong></p></li><li><p><strong>消息正文</strong></p></li></ul><h4 id="编码器与解码器"><a href="#编码器与解码器" class="headerlink" title="编码器与解码器"></a>编码器与解码器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ByteToMessageCodec</span>&lt;Message&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Message msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 设置魔数 4个字节</span><br>        out.writeBytes(<span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[]&#123;<span class="hljs-string">&#x27;Y&#x27;</span>,<span class="hljs-string">&#x27;O&#x27;</span>,<span class="hljs-string">&#x27;U&#x27;</span>,<span class="hljs-string">&#x27;Z&#x27;</span>&#125;);<br>        <span class="hljs-comment">// 设置版本号 1个字节</span><br>        out.writeByte(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 设置序列化方式 1个字节</span><br>        out.writeByte(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">// 设置指令类型 1个字节</span><br>        out.writeByte(msg.getMessageType());<br>        <span class="hljs-comment">// 设置请求序号 4个字节</span><br>        out.writeInt(msg.getSequenceId());<br>        <span class="hljs-comment">// 为了补齐为16个字节，填充1个字节的数据</span><br>        out.writeByte(<span class="hljs-number">0xff</span>);<br><br>        <span class="hljs-comment">// 获得序列化后的msg</span><br>        <span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>        <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos);<br>        oos.writeObject(msg);<br>        <span class="hljs-type">byte</span>[] bytes = bos.toByteArray();<br><br>        <span class="hljs-comment">// 获得并设置正文长度 长度用4个字节标识</span><br>        out.writeInt(bytes.length);<br>        <span class="hljs-comment">// 设置消息正文</span><br>        out.writeBytes(bytes);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获取魔数</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">magic</span> <span class="hljs-operator">=</span> in.readInt();<br>        <span class="hljs-comment">// 获取版本号</span><br>        <span class="hljs-type">byte</span> <span class="hljs-variable">version</span> <span class="hljs-operator">=</span> in.readByte();<br>        <span class="hljs-comment">// 获得序列化方式</span><br>        <span class="hljs-type">byte</span> <span class="hljs-variable">seqType</span> <span class="hljs-operator">=</span> in.readByte();<br>        <span class="hljs-comment">// 获得指令类型</span><br>        <span class="hljs-type">byte</span> <span class="hljs-variable">messageType</span> <span class="hljs-operator">=</span> in.readByte();<br>        <span class="hljs-comment">// 获得请求序号</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">sequenceId</span> <span class="hljs-operator">=</span> in.readInt();<br>        <span class="hljs-comment">// 移除补齐字节</span><br>        in.readByte();<br>        <span class="hljs-comment">// 获得正文长度</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> in.readInt();<br>        <span class="hljs-comment">// 获得正文</span><br>        <span class="hljs-type">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[length];<br>        in.readBytes(bytes, <span class="hljs-number">0</span>, length);<br>        <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bytes));<br>        <span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> (Message) ois.readObject();<br><span class="hljs-comment">// 将信息放入List中，传递给下一个handler</span><br>        out.add(message);<br>        <br>        <span class="hljs-comment">// 打印获得的信息正文</span><br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;, &#123;&#125;&quot;</span>, magic, version, seqType, messageType, sequenceId, length);<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>,message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><p>编码器与解码器方法源于<strong>父类ByteToMessageCodec</strong>，通过该类可以自定义编码器与解码器，<strong>泛型类型为被编码与被解码的类</strong>。此处使用了自定义类Message，代表消息</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageCodec&lt;Message&gt;</span></span><br></code></pre></td></tr></table></figure></li><li><p>编码器<strong>负责将附加信息与正文信息写入到ByteBuf中</strong>，其中附加信息<strong>总字节数最好为2n，不足需要补齐</strong>。正文内容如果为对象，需要通过<strong>序列化</strong>将其放入到ByteBuf中</p></li><li><p>解码器<strong>负责将ByteBuf中的信息取出，并放入List中</strong>，该List用于将信息传递给下一个handler</p></li></ul><p><strong>编写测试类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestCodec</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> org.slf4j.<span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(StudyServer.class);<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">EmbeddedChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">EmbeddedChannel</span>();<br>        <span class="hljs-comment">// 添加解码器，避免粘包半包问题</span><br>        channel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LengthFieldBasedFrameDecoder</span>(<span class="hljs-number">1024</span>, <span class="hljs-number">12</span>, <span class="hljs-number">4</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>));<br>        channel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG));<br>        channel.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageCodec</span>());<br>        <span class="hljs-type">LoginRequestMessage</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginRequestMessage</span>(<span class="hljs-string">&quot;Youzi&quot;</span>, <span class="hljs-string">&quot;123&quot;</span>, <span class="hljs-string">&quot;柚子&quot;</span>);<br><br>        <span class="hljs-comment">// 测试编码与解码</span><br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> ByteBufAllocator.DEFAULT.buffer();<br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageCodec</span>().encode(<span class="hljs-literal">null</span>, user, byteBuf);<br>        channel.writeInbound(byteBuf);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>测试类中用到了LengthFieldBasedFrameDecoder，避免粘包半包问题</li><li>通过MessageCodec的encode方法将附加信息与正文写入到ByteBuf中，通过channel执行入站操作。入站时会调用decode方法进行解码</li></ul><p>运行结果</p><p><img src="https://s2.loli.net/2023/04/11/ExaWsBbq9lCPpOr.png"></p><h4 id="Sharable注解"><a href="#Sharable注解" class="headerlink" title="@Sharable注解"></a>@Sharable注解</h4><p>为了<strong>提高handler的复用率，可以将handler创建为handler对象</strong>，然后在不同的channel中使用该handler对象进行处理操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">LoggingHandler</span> <span class="hljs-variable">loggingHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG);<br><span class="hljs-comment">// 不同的channel中使用同一个handler对象，提高复用率</span><br>channel1.pipeline().addLast(loggingHandler);<br>channel2.pipeline().addLast(loggingHandler);<br></code></pre></td></tr></table></figure><p>但是<strong>并不是所有的handler都能通过这种方法来提高复用率的</strong>，例如<code>LengthFieldBasedFrameDecoder</code>。如果多个channel中使用同一个LengthFieldBasedFrameDecoder对象，则可能发生如下问题</p><ul><li>channel1中收到了一个半包，LengthFieldBasedFrameDecoder发现不是一条完整的数据，则没有继续向下传播</li><li>此时channel2中也收到了一个半包，<strong>因为两个channel使用了同一个LengthFieldBasedFrameDecoder，存入其中的数据刚好拼凑成了一个完整的数据包</strong>。LengthFieldBasedFrameDecoder让该数据包继续向下传播，<strong>最终引发错误</strong></li></ul><p>为了提高handler的复用率，同时又避免出现一些并发问题，<strong>Netty中原生的handler中用<font color=Red><code>@Sharable</code></font>注解来标明，该handler能否在多个channel中共享。</strong></p><p><strong>只有带有该注解，才能通过对象的方式被共享</strong>，否则无法被共享</p><h5 id="自定义编解码器能否使用-Sharable注解"><a href="#自定义编解码器能否使用-Sharable注解" class="headerlink" title="自定义编解码器能否使用@Sharable注解"></a><strong>自定义编解码器能否使用@Sharable注解</strong></h5><p><strong>这需要根据自定义的handler的处理逻辑进行分析</strong></p><p>我们的MessageCodec本身接收的是LengthFieldBasedFrameDecoder处理之后的数据，那么数据肯定是完整的，按分析来说是可以添加@Sharable注解的</p><p>但是实际情况我们并<strong>不能</strong>添加该注解，会抛出异常信息<font color=Red><code>ChannelHandler com.noah.netty.potocol.MessageCodec is not allowed to be shared</code> </font></p><ul><li><p>因为MessageCodec<strong>继承自ByteToMessageCodec</strong>，ByteToMessageCodec类的注解如下</p><p><img src="https://s2.loli.net/2023/04/11/3KNWyGfajT2FQmi.png" alt="image-20230411212819730"></p><p>这就意味着<strong>ByteToMessageCodec不能被多个channel所共享的</strong></p><ul><li>原因：<strong>因为该类的目标是：将ByteBuf转化为Message，意味着传进该handler的数据还未被处理过</strong>。所以传过来的ByteBuf<strong>可能并不是完整的数据</strong>，如果共享则会出现问题</li></ul></li></ul><p><strong>如果想要共享，需要怎么办呢？</strong></p><p>继承<strong>MessageToMessageDecoder</strong>即可。<strong>该类的目标是：将已经被处理的完整数据再次被处理。</strong>传过来的Message<strong>如果是被处理过的完整数据</strong>，那么被共享也就不会出现问题了，也就可以使用@Sharable注解了。实现方式与ByteToMessageCodec类似</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageSharableCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MessageToMessageCodec</span>&lt;ByteBuf, Message&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Message msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ...<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-在线聊天室"><a href="#3-在线聊天室" class="headerlink" title="3.在线聊天室"></a>3.在线聊天室</h2><h3 id="聊天室业务"><a href="#聊天室业务" class="headerlink" title="聊天室业务"></a>聊天室业务</h3><h4 id="用户登录接口"><a href="#用户登录接口" class="headerlink" title="用户登录接口"></a>用户登录接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserService</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 登录</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 用户名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> password 密码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 登录成功返回 true, 否则返回 false</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">login</span><span class="hljs-params">(String username, String password)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="用户会话接口"><a href="#用户会话接口" class="headerlink" title="用户会话接口"></a>用户会话接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Session</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 绑定会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel 要绑定会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 会话绑定用户</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">(Channel channel, String username)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解绑会话</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel 要解绑会话</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">unbind</span><span class="hljs-params">(Channel channel)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取属性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 属性名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 属性值</span><br><span class="hljs-comment">     */</span><br>    Object <span class="hljs-title function_">getAttribute</span><span class="hljs-params">(Channel channel, String name)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置属性</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 哪个 channel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 属性名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> value 属性值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAttribute</span><span class="hljs-params">(Channel channel, String name, Object value)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据用户名获取 channel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 用户名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> channel</span><br><span class="hljs-comment">     */</span><br>    Channel <span class="hljs-title function_">getChannel</span><span class="hljs-params">(String username)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="群聊会话接口"><a href="#群聊会话接口" class="headerlink" title="群聊会话接口"></a>群聊会话接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GroupSession</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建一个聊天组, 如果不存在才能创建成功, 否则返回 null</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> members 成员</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成功时返回组对象, 失败返回 null</span><br><span class="hljs-comment">     */</span><br>    Group <span class="hljs-title function_">createGroup</span><span class="hljs-params">(String name, Set&lt;String&gt; members)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加入聊天组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> member 成员名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span><br><span class="hljs-comment">     */</span><br>    Group <span class="hljs-title function_">joinMember</span><span class="hljs-params">(String name, String member)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除组成员</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> member 成员名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span><br><span class="hljs-comment">     */</span><br>    Group <span class="hljs-title function_">removeMember</span><span class="hljs-params">(String name, String member)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 移除聊天组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 如果组不存在返回 null, 否则返回组对象</span><br><span class="hljs-comment">     */</span><br>    Group <span class="hljs-title function_">removeGroup</span><span class="hljs-params">(String name)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取组成员</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成员集合, 如果群不存在或没有成员会返回 empty set</span><br><span class="hljs-comment">     */</span><br>    Set&lt;String&gt; <span class="hljs-title function_">getMembers</span><span class="hljs-params">(String name)</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取组成员的 channel 集合, 只有在线的 channel 才会返回</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 组名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 成员 channel 集合</span><br><span class="hljs-comment">     */</span><br>    List&lt;Channel&gt; <span class="hljs-title function_">getMembersChannel</span><span class="hljs-params">(String name)</span>;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断群聊是否一被创建</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 群聊名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否存在</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isCreated</span><span class="hljs-params">(String name)</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断是否为该群聊的成员</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> name 群聊名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> username 成员名 </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否存在</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isMember</span><span class="hljs-params">(String name, String username)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h4><img src="https://s2.loli.net/2023/04/13/kYo5QJclROWXENj.png" alt="image-20230413001903385" style="zoom:50%;" /><img src="https://s2.loli.net/2023/04/13/mxcuRnHgjdeNs6K.png" alt="image-20230413002323813" style="zoom:50%;" /><ul><li>client包：存放客户端相关类</li><li>message包：存放各种类型的消息</li><li>protocol包：存放自定义协议</li><li>server包：存放服务器相关类<ul><li>service包：存放用户相关类</li><li>session包：单聊及群聊相关会话类</li></ul></li></ul><h4 id="客户端代码-1"><a href="#客户端代码-1" class="headerlink" title="客户端代码"></a>客户端代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">LoggingHandler</span> <span class="hljs-variable">loggingHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG);<br>        <span class="hljs-type">MessageSharableCodec</span> <span class="hljs-variable">messageSharableCodec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageSharableCodec</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>            bootstrap.group(group);<br>            bootstrap.channel(NioSocketChannel.class);<br>            bootstrap.handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtocolFrameDecoder</span>());<br>                    ch.pipeline().addLast(loggingHandler);<br>                    ch.pipeline().addLast(messageSharableCodec);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> bootstrap.connect().sync().channel();<br>            channel.closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>           group.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="服务器代码-2"><a href="#服务器代码-2" class="headerlink" title="服务器代码"></a>服务器代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">boss</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">worker</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-type">LoggingHandler</span> <span class="hljs-variable">loggingHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingHandler</span>(LogLevel.DEBUG);<br>        <span class="hljs-type">MessageSharableCodec</span> <span class="hljs-variable">messageSharableCodec</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageSharableCodec</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            bootstrap.group(boss, worker);<br>            bootstrap.channel(NioServerSocketChannel.class);<br>            bootstrap.childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ProtocolFrameDecoder</span>());<br>                    ch.pipeline().addLast(loggingHandler);<br>                    ch.pipeline().addLast(messageSharableCodec);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> bootstrap.bind(<span class="hljs-number">8080</span>).sync().channel();<br>            channel.closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            boss.shutdownGracefully();<br>            worker.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><h4 id="服务器代码-3"><a href="#服务器代码-3" class="headerlink" title="服务器代码"></a>服务器代码</h4><p>客户端添加如下handler，<strong>分别处理登录、聊天等操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java">ch.pipeline().addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span>() &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建连接时执行的处理器，用于执行登陆操作</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 开辟额外线程，用于用户登陆及后续操作</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(()-&gt;&#123;<br>            <span class="hljs-type">Scanner</span> <span class="hljs-variable">scanner</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(System.in);<br>            System.out.println(<span class="hljs-string">&quot;请输入用户名&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> scanner.next();<br>            System.out.println(<span class="hljs-string">&quot;请输入密码&quot;</span>);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> scanner.next();<br>            <span class="hljs-comment">// 创建包含登录信息的请求体</span><br>            <span class="hljs-type">LoginRequestMessage</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginRequestMessage</span>(username, password);<br>            <span class="hljs-comment">// 发送到channel中</span><br>            ctx.writeAndFlush(message);<br>            System.out.println(<span class="hljs-string">&quot;等待后台校验&quot;</span>);<br>            <span class="hljs-comment">// 阻塞，直到登陆成功后CountDownLatch被设置为0</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                waitLogin.await();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">// 执行后续操作</span><br>            <span class="hljs-keyword">if</span> (!loginStatus.get()) &#123;<br>                <span class="hljs-comment">// 登陆失败，关闭channel并返回</span><br>                ctx.channel().close();<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">// 登录成功后，执行其他操作</span><br>            <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;==================================&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;send [username] [content]&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;gsend [group name] [content]&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;gcreate [group name] [m1,m2,m3...]&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;gmembers [group name]&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;gjoin [group name]&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;gquit [group name]&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;quit&quot;</span>);<br>                System.out.println(<span class="hljs-string">&quot;==================================&quot;</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">command</span> <span class="hljs-operator">=</span> scanner.nextLine();<br>                <span class="hljs-comment">// 获得指令及其参数，并发送对应类型消息</span><br>                String[] commands = command.split(<span class="hljs-string">&quot; &quot;</span>);<br>                <span class="hljs-keyword">switch</span> (commands[<span class="hljs-number">0</span>])&#123;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;send&quot;</span>:<br>                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatRequestMessage</span>(username, commands[<span class="hljs-number">1</span>], commands[<span class="hljs-number">2</span>]));<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gsend&quot;</span>:<br>                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupChatRequestMessage</span>(username,commands[<span class="hljs-number">1</span>], commands[<span class="hljs-number">2</span>]));<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gcreate&quot;</span>:<br>                        <span class="hljs-comment">// 分割，获得群员名</span><br>                        String[] members = commands[<span class="hljs-number">2</span>].split(<span class="hljs-string">&quot;,&quot;</span>);<br>                        Set&lt;String&gt; set = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>&lt;&gt;(Arrays.asList(members));<br>                        <span class="hljs-comment">// 把自己加入到群聊中</span><br>                        set.add(username);<br>                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupCreateRequestMessage</span>(commands[<span class="hljs-number">1</span>],set));<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gmembers&quot;</span>:<br>                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupMembersRequestMessage</span>(commands[<span class="hljs-number">1</span>]));<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gjoin&quot;</span>:<br>                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupJoinRequestMessage</span>(username, commands[<span class="hljs-number">1</span>]));<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;gquit&quot;</span>:<br>                        ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupQuitRequestMessage</span>(username, commands[<span class="hljs-number">1</span>]));<br>                        <span class="hljs-keyword">break</span>;<br>                    <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;quit&quot;</span>:<br>                        ctx.channel().close();<br>                        <span class="hljs-keyword">return</span>;<br>                    <span class="hljs-keyword">default</span>:<br>                        System.out.println(<span class="hljs-string">&quot;指令有误，请重新输入&quot;</span>);<br>                        <span class="hljs-keyword">continue</span>;<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;login channel&quot;</span>).start();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        log.debug(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, msg);<br>        <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> LoginResponseMessage) &#123;<br>            <span class="hljs-comment">// 如果是登录响应信息</span><br>            <span class="hljs-type">LoginResponseMessage</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> (LoginResponseMessage) msg;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">isSuccess</span> <span class="hljs-operator">=</span> message.isSuccess();<br>            <span class="hljs-comment">// 登录成功，设置登陆标记</span><br>            <span class="hljs-keyword">if</span> (isSuccess) &#123;<br>                loginStatus.set(<span class="hljs-literal">true</span>);<br>            &#125;<br>            <span class="hljs-comment">// 登陆后，唤醒登陆线程</span><br>            waitLogin.countDown();<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="客户端代码-2"><a href="#客户端代码-2" class="headerlink" title="客户端代码"></a>客户端代码</h4><p>服务器添加如下handler，并添加到对应的channel中，<strong>负责处理登录请求信息，并作出响应</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable <span class="hljs-comment">// 必须添加该注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoginRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;LoginRequestMessage&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, LoginRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获得登录信息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> msg.getUsername();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">password</span> <span class="hljs-operator">=</span> msg.getPassword();<br>        <span class="hljs-comment">// 校验登录信息</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">login</span> <span class="hljs-operator">=</span> UserServiceFactory.getUserService().login(username, password);<br>        LoginResponseMessage message;<br>        <span class="hljs-keyword">if</span> (login) &#123;<br>            message = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginResponseMessage</span>(<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;登陆成功&quot;</span>);<br>            <span class="hljs-comment">// 绑定channel与user</span><br>            SessionFactory.getSession().bind(ctx.channel(), username);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            message = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginResponseMessage</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;登陆失败&quot;</span>);<br>        &#125;<br>        ctx.writeAndFlush(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 该handler处理登录请求</span><br><span class="hljs-type">LoginRequestMessageHandler</span> <span class="hljs-variable">LOGIN_HANDLER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoginRequestMessageHandler</span>();<br>....<br>ch.pipeline().addLast(LOGIN_HANDLER);<br></code></pre></td></tr></table></figure><h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><p><strong>客户端</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">[nioEventLoopGroup-2-1] <span class="hljs-built_in">DEBUG</span> com.noah.netty.potocol.MessageCodecSharable - 1498371418, 1, 1, 1, 0, 261<br>[nioEventLoopGroup-2-1] <span class="hljs-built_in">DEBUG</span> com.noah.netty.potocol.MessageCodecSharable - LoginResponseMessage(<span class="hljs-attribute">super</span>=AbstractResponseMessage(super=Message(sequenceId=0, <span class="hljs-attribute">messageType</span>=1), <span class="hljs-attribute">success</span>=<span class="hljs-literal">true</span>, <span class="hljs-attribute">reason</span>=登陆成功))<br>[nioEventLoopGroup-2-1] <span class="hljs-built_in">DEBUG</span> com.noah.netty.client.ChatClient - msg:LoginResponseMessage(<span class="hljs-attribute">super</span>=AbstractResponseMessage(super=Message(sequenceId=0, <span class="hljs-attribute">messageType</span>=1), <span class="hljs-attribute">success</span>=<span class="hljs-literal">true</span>, <span class="hljs-attribute">reason</span>=登陆成功))<br></code></pre></td></tr></table></figure><p><strong>服务器</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs tap"> [nioEventLoopGroup-3-1] DEBUG com.noah.netty.potocol.MessageCodecSharable - 1498371418, 1, 1, 0, 0, 205<br> [nioEventLoopGroup-3-1] DEBUG com.noah.netty.potocol.MessageCodecSharable - LoginRequestMessage(super=Message(sequenceId=0, messageType=0), username=youzi, password=123)<br> [nioEventLoopGroup-3-1] DEBUG io.netty.handler.logging.LoggingHandler - [id: 0xc67b1437, L:/127.0.0.1:8080 - R:/127.0.0.1:56405] WRITE: 277B<br>         +-------------------------------------------------+<br>         | <span class="hljs-number"> 0 </span><span class="hljs-number"> 1 </span><span class="hljs-number"> 2 </span><span class="hljs-number"> 3 </span><span class="hljs-number"> 4 </span><span class="hljs-number"> 5 </span><span class="hljs-number"> 6 </span><span class="hljs-number"> 7 </span><span class="hljs-number"> 8 </span><span class="hljs-number"> 9 </span> a  b  c  d  e  f |<br>+--------+-------------------------------------------------+----------------+<br>|00000000|<span class="hljs-number"> 59 </span>4f<span class="hljs-number"> 55 </span>5a<span class="hljs-number"> 01 </span>01<span class="hljs-number"> 01 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>ff<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 01 </span>05 |YOUZ............|<br>|00000010| ac ed<span class="hljs-number"> 00 </span>05<span class="hljs-number"> 73 </span>72<span class="hljs-number"> 00 </span>2b<span class="hljs-number"> 63 </span>6f 6d 2e 6e 6f<span class="hljs-number"> 61 </span>68 |....sr.+com.noah|<br>|00000020| 2e 6e<span class="hljs-number"> 65 </span>74<span class="hljs-number"> 74 </span>79 2e 6d<span class="hljs-number"> 65 </span>73<span class="hljs-number"> 73 </span>61<span class="hljs-number"> 67 </span>65 2e 4c |.netty.message.L|<br>|00000030| 6f<span class="hljs-number"> 67 </span>69 6e<span class="hljs-number"> 52 </span>65<span class="hljs-number"> 73 </span>70 6f 6e<span class="hljs-number"> 73 </span>65 4d<span class="hljs-number"> 65 </span>73<span class="hljs-number"> 73 </span>|oginResponseMess|<br>|00000040|<span class="hljs-number"> 61 </span>67<span class="hljs-number"> 65 </span>8f a4<span class="hljs-number"> 96 </span>e2<span class="hljs-number"> 40 </span>b3<span class="hljs-number"> 40 </span>29<span class="hljs-number"> 02 </span>00<span class="hljs-number"> 00 </span>78<span class="hljs-number"> 72 </span>|age....@.@)...xr|<br>|00000050|<span class="hljs-number"> 00 </span>2e<span class="hljs-number"> 63 </span>6f 6d 2e 6e 6f<span class="hljs-number"> 61 </span>68 2e 6e<span class="hljs-number"> 65 </span>74<span class="hljs-number"> 74 </span>79 |..com.noah.netty|<br>|00000060| 2e 6d<span class="hljs-number"> 65 </span>73<span class="hljs-number"> 73 </span>61<span class="hljs-number"> 67 </span>65 2e<span class="hljs-number"> 41 </span>62<span class="hljs-number"> 73 </span>74<span class="hljs-number"> 72 </span>61<span class="hljs-number"> 63 </span>|.message.Abstrac|<br>|00000070|<span class="hljs-number"> 74 </span>52<span class="hljs-number"> 65 </span>73<span class="hljs-number"> 70 </span>6f 6e<span class="hljs-number"> 73 </span>65 4d<span class="hljs-number"> 65 </span>73<span class="hljs-number"> 73 </span>61<span class="hljs-number"> 67 </span>65 |tResponseMessage|<br>|00000080|<span class="hljs-number"> 91 </span>fc a2<span class="hljs-number"> 93 </span>f0 d5<span class="hljs-number"> 27 </span>49<span class="hljs-number"> 02 </span>00<span class="hljs-number"> 02 </span>5a<span class="hljs-number"> 00 </span>07<span class="hljs-number"> 73 </span>75 |......&#x27;I...Z..su|<br>|00000090|<span class="hljs-number"> 63 </span>63<span class="hljs-number"> 65 </span>73<span class="hljs-number"> 73 </span>4c<span class="hljs-number"> 00 </span>06<span class="hljs-number"> 72 </span>65<span class="hljs-number"> 61 </span>73 6f 6e<span class="hljs-number"> 74 </span>00 |ccessL..reasont.|<br>|000000a0|<span class="hljs-number"> 12 </span>4c 6a<span class="hljs-number"> 61 </span>76<span class="hljs-number"> 61 </span>2f 6c<span class="hljs-number"> 61 </span>6e<span class="hljs-number"> 67 </span>2f<span class="hljs-number"> 53 </span>74<span class="hljs-number"> 72 </span>69 |.Ljava/lang/Stri|<br>|000000b0| 6e<span class="hljs-number"> 67 </span>3b<span class="hljs-number"> 78 </span>72<span class="hljs-number"> 00 </span>1e<span class="hljs-number"> 63 </span>6f 6d 2e 6e 6f<span class="hljs-number"> 61 </span>68 2e |ng;xr..com.noah.|<br>|000000c0| 6e<span class="hljs-number"> 65 </span>74<span class="hljs-number"> 74 </span>79 2e 6d<span class="hljs-number"> 65 </span>73<span class="hljs-number"> 73 </span>61<span class="hljs-number"> 67 </span>65 2e 4d<span class="hljs-number"> 65 </span>|netty.message.Me|<br>|000000d0|<span class="hljs-number"> 73 </span>73<span class="hljs-number"> 61 </span>67<span class="hljs-number"> 65 </span>66 0a<span class="hljs-number"> 01 </span>c9 db<span class="hljs-number"> 10 </span>ff 8f<span class="hljs-number"> 02 </span>00<span class="hljs-number"> 02 </span>|ssagef..........|<br>|000000e0|<span class="hljs-number"> 49 </span>00 0b 6d<span class="hljs-number"> 65 </span>73<span class="hljs-number"> 73 </span>61<span class="hljs-number"> 67 </span>65<span class="hljs-number"> 54 </span>79<span class="hljs-number"> 70 </span>65<span class="hljs-number"> 49 </span>00 |I..messageTypeI.|<br>|000000f0| 0a<span class="hljs-number"> 73 </span>65<span class="hljs-number"> 71 </span>75<span class="hljs-number"> 65 </span>6e<span class="hljs-number"> 63 </span>65<span class="hljs-number"> 49 </span>64<span class="hljs-number"> 78 </span>70<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>|.sequenceIdxp...|<br>|00000100|<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>00<span class="hljs-number"> 00 </span>01<span class="hljs-number"> 74 </span>00 0c e7<span class="hljs-number"> 99 </span>bb e9<span class="hljs-number"> 99 </span>86 e6 |......t.........|<br>|00000110|<span class="hljs-number"> 88 </span>90 e5 8a 9f                                  |.....           |<br>+--------+-------------------------------------------------+----------------+<br></code></pre></td></tr></table></figure><h3 id="单聊"><a href="#单聊" class="headerlink" title="单聊"></a>单聊</h3><p>客户端输入<code>send username content</code>即可发送单聊消息，需要<strong>服务器端添加处理ChatRequestMessage的handler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable <span class="hljs-comment">// 必须添加该注解</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChatRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;ChatRequestMessage&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ChatRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获得user所在的channel</span><br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> SessionFactory.getSession().getChannel(msg.getTo());<br>        <span class="hljs-comment">// 如果双方都在线</span><br>        <span class="hljs-keyword">if</span> (channel != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 通过接收方与服务器之间的channel发送信息</span><br>            channel.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatResponseMessage</span>(msg.getFrom(), msg.getContent()));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 通过发送方与服务器之间的channel发送消息</span><br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatResponseMessage</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;对方用户不存在或离线，发送失败&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 该handler处理单聊请求</span><br><span class="hljs-type">ChatRequestMessageHandler</span> <span class="hljs-variable">chatRequestMessageHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChatRequestMessageHandler</span>();<br>ch.pipeline().addLast(chatRequestMessageHandler);<br></code></pre></td></tr></table></figure><p><strong>运行结果</strong></p><p>发送方（zhangsan）</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit"><span class="hljs-built_in">send</span> youzi hello<br></code></pre></td></tr></table></figure><p>接收方（youzi）</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 收到zhangsan发来的消息</span><br><span class="hljs-selector-attr">[nioEventLoopGroup-2-1]</span> DEBUG com<span class="hljs-selector-class">.noah</span><span class="hljs-selector-class">.netty</span><span class="hljs-selector-class">.client</span><span class="hljs-selector-class">.ChatClient</span> - msg:<span class="hljs-built_in">ChatResponseMessage</span>(from=zhangsan, <span class="hljs-attribute">content</span>=hello) <br></code></pre></td></tr></table></figure><h3 id="群聊"><a href="#群聊" class="headerlink" title="群聊"></a>群聊</h3><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><h5 id="创建handler"><a href="#创建handler" class="headerlink" title="创建handler"></a>创建handler</h5><p>客户端输入<code>gcreate &lt;群聊&gt; m1,m2</code>即可创建群聊，并拉入成员，需要<strong>服务器端添加处理GroupCreateRequestMessage的handler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Sharable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupCreateRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;GroupCreateRequestMessage&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupCreateRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 获得要创建的群聊名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">groupName</span> <span class="hljs-operator">=</span> msg.getGroupName();<br>        <span class="hljs-comment">// 获得要创建的群聊的成员组</span><br>        Set&lt;String&gt; members = msg.getMembers();<br>        <span class="hljs-comment">// 判断该群聊是否创建过，未创建返回null并创建群聊</span><br>        <span class="hljs-type">Group</span> <span class="hljs-variable">group</span> <span class="hljs-operator">=</span> GroupSessionFactory.getGroupSession().createGroup(groupName, members);<br>        <span class="hljs-keyword">if</span> (group != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 发送创建成功消息</span><br>            <span class="hljs-type">GroupCreateResponseMessage</span> <span class="hljs-variable">groupCreateResponseMessage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupCreateResponseMessage</span>(<span class="hljs-literal">true</span>,<br>                    groupName + <span class="hljs-string">&quot;创建成功&quot;</span>);<br>            ctx.writeAndFlush(groupCreateResponseMessage);<br>            <span class="hljs-comment">// 获得在线群员的channel，给群员发送入群聊消息</span><br>            List&lt;Channel&gt; membersChannel = GroupSessionFactory.getGroupSession().getMembersChannel(groupName);<br>            groupCreateResponseMessage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupCreateResponseMessage</span>(<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;您已被拉入&quot;</span> + groupName);<br>            <span class="hljs-comment">// 给每个在线群员发送消息</span><br>            <span class="hljs-keyword">for</span> (Channel channel : membersChannel) &#123;<br>                channel.writeAndFlush(groupCreateResponseMessage);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 发送失败消息</span><br>            <span class="hljs-type">GroupCreateResponseMessage</span> <span class="hljs-variable">groupCreateResponseMessage</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupCreateResponseMessage</span>(<span class="hljs-literal">false</span>,<br>                    groupName + <span class="hljs-string">&quot;已存在&quot;</span>);<br>            ctx.writeAndFlush(groupCreateResponseMessage);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="服务器添加代码"><a href="#服务器添加代码" class="headerlink" title="服务器添加代码"></a>服务器添加代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">GroupCreateRequestMessageHandler</span> <span class="hljs-variable">GROUP_CREATE_HANDLER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupCreateRequestMessageHandler</span>();<br>...<br>ch.pipeline().addLast(GROUP_CREATE_HANDLER);    <br></code></pre></td></tr></table></figure><h5 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>创建群聊，拉入成员<br>gcreate 群聊<span class="hljs-number">1</span> lisi,wangwu<br></code></pre></td></tr></table></figure><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">[nioEventLoopGroup-2-1] <span class="hljs-built_in">DEBUG</span> com.noah.netty.potocol.MessageCodecSharable - AbstractResponseMessage(<span class="hljs-attribute">super</span>=Message(sequenceId=0, <span class="hljs-attribute">messageType</span>=5), <span class="hljs-attribute">success</span>=<span class="hljs-literal">true</span>, <span class="hljs-attribute">reason</span>=群聊1创建成功)<br><span class="hljs-built_in">..</span>.<br>[nioEventLoopGroup-2-1] <span class="hljs-built_in">DEBUG</span> com.noah.netty.potocol.MessageCodecSharable - AbstractResponseMessage(<span class="hljs-attribute">super</span>=Message(sequenceId=0, <span class="hljs-attribute">messageType</span>=5), <span class="hljs-attribute">success</span>=<span class="hljs-literal">true</span>, <span class="hljs-attribute">reason</span>=您已被拉入群聊1)<br></code></pre></td></tr></table></figure><h4 id="聊天"><a href="#聊天" class="headerlink" title="聊天"></a>聊天</h4><h5 id="创建GroupChatHandler"><a href="#创建GroupChatHandler" class="headerlink" title="创建GroupChatHandler"></a>创建GroupChatHandler</h5><p>客户端执行 <code>gsend &lt;群聊&gt; &lt;消息&gt;</code>即可发送消息到其他成员，需要<strong>服务器端添加处理GroupChatRequestMessage的handler</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Sharable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupChatRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;GroupChatRequestMessage&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupChatRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">groupName</span> <span class="hljs-operator">=</span> msg.getGroupName();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> msg.getFrom();<br>        <span class="hljs-type">GroupSession</span> <span class="hljs-variable">groupSession</span> <span class="hljs-operator">=</span> GroupSessionFactory.getGroupSession();<br>        <span class="hljs-comment">// 判断群聊是否存在</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isCreated</span> <span class="hljs-operator">=</span> groupSession.isCreated(groupName);<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">isMember</span> <span class="hljs-operator">=</span> groupSession.isMember(groupName, username);<br>        <span class="hljs-keyword">if</span> (isCreated) &#123;<br>            <span class="hljs-comment">// 判断是否属于成员</span><br>            <span class="hljs-keyword">if</span> (isMember) &#123;<br>                <span class="hljs-comment">// 给群员发送信息</span><br>                List&lt;Channel&gt; membersChannel = groupSession.getMembersChannel(groupName);<br>                <span class="hljs-keyword">for</span> (Channel channel : membersChannel) &#123;<br>                    channel.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupChatResponseMessage</span>(msg.getFrom(), msg.getContent()));<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupChatResponseMessage</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;非该群组成员不能发言&quot;</span>));<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupChatResponseMessage</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;群聊不存在&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">GroupChatRequestMessageHandler</span> <span class="hljs-variable">GROUP_CHAT_HANDLER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupChatRequestMessageHandler</span>();<br>...<br>ch.pipeline().addLast(GROUP_CHAT_HANDLER);<br></code></pre></td></tr></table></figure><h5 id="运行结果-2"><a href="#运行结果-2" class="headerlink" title="运行结果"></a>运行结果</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">[nioEventLoopGroup-2-1] <span class="hljs-built_in">DEBUG</span> com.noah.netty.potocol.MessageCodecSharable - GroupChatResponseMessage(<span class="hljs-attribute">fromName</span>=youzi, <span class="hljs-attribute">toName</span>=大家好)<br></code></pre></td></tr></table></figure><h4 id="加入"><a href="#加入" class="headerlink" title="加入"></a>加入</h4><h5 id="创建Handler"><a href="#创建Handler" class="headerlink" title="创建Handler"></a>创建Handler</h5><p>客户端发送命令 <code>sjoin &lt;群聊&gt; </code> 加入群聊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Sharable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupJoinRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;GroupJoinRequestMessage&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupJoinRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">GroupSession</span> <span class="hljs-variable">groupSession</span> <span class="hljs-operator">=</span> GroupSessionFactory.getGroupSession();<br>        <span class="hljs-comment">// 判断该用户是否在群聊中</span><br>        Set&lt;String&gt; members = groupSession.getMembers(msg.getGroupName());<br>        <span class="hljs-comment">// 群聊存在且用户未加入，才能加入</span><br>        <span class="hljs-keyword">if</span> (!members.contains(msg.getUsername()) &amp;&amp; groupSession.isCreated(msg.getGroupName())) &#123;<br>            <span class="hljs-comment">// 加入群聊</span><br>            groupSession.joinMember(msg.getGroupName(), msg.getUsername());<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupJoinResponseMessage</span>(<span class="hljs-literal">true</span>,<span class="hljs-string">&quot;加入&quot;</span>+msg.getGroupName()+<span class="hljs-string">&quot;成功&quot;</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupJoinResponseMessage</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;加入失败，群聊未存在或您已加入该群聊&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="服务器添加Handler"><a href="#服务器添加Handler" class="headerlink" title="服务器添加Handler"></a>服务器添加Handler</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">GroupJoinRequestMessageHandler</span> <span class="hljs-variable">GROUP_JOIN_HANDLER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupJoinRequestMessageHandler</span>();<br>...<br>ch.pipeline().addLast(GROUP_JOIN_HANDLER);<br></code></pre></td></tr></table></figure><h5 id="运行结果-3"><a href="#运行结果-3" class="headerlink" title="运行结果"></a>运行结果</h5><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">[nioEventLoopGroup-2-1] <span class="hljs-built_in">DEBUG</span> com.noah.netty.potocol.MessageCodecSharable - AbstractResponseMessage(<span class="hljs-attribute">super</span>=Message(sequenceId=0, <span class="hljs-attribute">messageType</span>=7), <span class="hljs-attribute">success</span>=<span class="hljs-literal">true</span>, <span class="hljs-attribute">reason</span>=加入群聊1成功)<br></code></pre></td></tr></table></figure><h4 id="退出"><a href="#退出" class="headerlink" title="退出"></a>退出</h4><h5 id="创建Handler-1"><a href="#创建Handler-1" class="headerlink" title="创建Handler"></a>创建Handler</h5><p>客户端发送命令<code>gquit &lt;群聊&gt;</code> 退出该群聊</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupQuitRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;GroupQuitRequestMessage&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupQuitRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">GroupSession</span> <span class="hljs-variable">groupSession</span> <span class="hljs-operator">=</span> GroupSessionFactory.getGroupSession();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">groupName</span> <span class="hljs-operator">=</span> msg.getGroupName();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">username</span> <span class="hljs-operator">=</span> msg.getUsername();<br>        <span class="hljs-comment">// 判断用户是否在群聊中以及群聊是否存在 </span><br>        <span class="hljs-keyword">if</span> (groupSession.isCreated(groupName) &amp;&amp; groupSession.isMember(groupName, username)) &#123;<br>            <span class="hljs-comment">/// 退出成功</span><br>            groupSession.removeMember(groupName, username);<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupQuitResponseMessage</span>(<span class="hljs-literal">true</span>, <span class="hljs-string">&quot;退出&quot;</span>+groupName+<span class="hljs-string">&quot;成功&quot;</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 退出失败</span><br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupQuitResponseMessage</span>(<span class="hljs-literal">false</span>, <span class="hljs-string">&quot;群聊不存在或您未加入该群，退出&quot;</span>+groupName+<span class="hljs-string">&quot;失败&quot;</span>));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 该handler处理退出群聊</span><br><span class="hljs-type">GroupQuitRequestMessageHandler</span> <span class="hljs-variable">GROUP_QUIT_HANDLER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupQuitRequestMessageHandler</span>();<br>ch.pipeline().addLast(GROUP_QUIT_HANDLER);<br></code></pre></td></tr></table></figure><h5 id="运行结果-4"><a href="#运行结果-4" class="headerlink" title="运行结果"></a>运行结果</h5><p>正常退出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG com.noah.netty.potocol.MessageCodecSharable - AbstractResponseMessage(<span class="hljs-built_in">super</span>=Message(sequenceId=<span class="hljs-number">0</span>, messageType=<span class="hljs-number">9</span>), success=<span class="hljs-literal">true</span>, reason=退出群聊<span class="hljs-number">1</span>成功)<br></code></pre></td></tr></table></figure><p>异常退出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG com.noah.netty.potocol.MessageCodecSharable - AbstractResponseMessage(<span class="hljs-built_in">super</span>=Message(sequenceId=<span class="hljs-number">0</span>, messageType=<span class="hljs-number">9</span>), success=<span class="hljs-literal">false</span>, reason=群聊不存在或您未加入该群，退出群聊<span class="hljs-number">1</span>失败)<br></code></pre></td></tr></table></figure><h4 id="查看成员"><a href="#查看成员" class="headerlink" title="查看成员"></a>查看成员</h4><h5 id="创建Handler-2"><a href="#创建Handler-2" class="headerlink" title="创建Handler"></a>创建Handler</h5><p>客户端发送命令<code>gmembers &lt;群聊&gt;</code> 查看该群聊的成员</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Sharable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GroupMembersRequestMessageHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SimpleChannelInboundHandler</span>&lt;GroupMembersRequestMessage&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, GroupMembersRequestMessage msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        ctx.writeAndFlush(<span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupMembersResponseMessage</span>(GroupSessionFactory.getGroupSession().getMembers(msg.getGroupName())));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">GroupMembersRequestMessageHandler</span> <span class="hljs-variable">GROUP_MEMBERS_HANDLER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GroupMembersRequestMessageHandler</span>();<br>...<br>ch.pipeline().addLast(GROUP_MEMBERS_HANDLER);<br></code></pre></td></tr></table></figure><h5 id="运行结果-5"><a href="#运行结果-5" class="headerlink" title="运行结果"></a>运行结果</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG com.noah.netty.potocol.MessageCodecSharable - GroupMembersResponseMessage(members=[zhangsan, lisi, youzi])<br></code></pre></td></tr></table></figure><h3 id="关闭聊天室（用户）"><a href="#关闭聊天室（用户）" class="headerlink" title="关闭聊天室（用户）"></a>关闭聊天室（用户）</h3><p>创建Handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Sharable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuitGroupHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 断开连接时触发 Inactive事件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 解绑</span><br>        SessionFactory.getSession().unbind(ctx.channel());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 异常退出，需要解绑</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 解绑</span><br>        SessionFactory.getSession().unbind(ctx.channel());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务器添加Handler</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">QuitGroupHandler</span> <span class="hljs-variable">USER_QUIT_HANDLER</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">QuitGroupHandler</span>();<br>ch.pipeline().addLast(USER_QUIT_HANDLER);<br></code></pre></td></tr></table></figure><p>客户端添加退出处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> <span class="hljs-string">&quot;quit&quot;</span>:<br>ctx.channel().close();<br>    <span class="hljs-keyword">return</span>;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">quit<br>[nioEventLoopGroup-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] DEBUG io.netty.handler.logging.LoggingHandler - [id: <span class="hljs-number">0x91adba4b</span>, L:/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">50730</span> - R:localhost/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span>] CLOSE<br></code></pre></td></tr></table></figure><h3 id="空闲检测-心跳机制"><a href="#空闲检测-心跳机制" class="headerlink" title="空闲检测(心跳机制)"></a>空闲检测(心跳机制)</h3><h4 id="连接假死"><a href="#连接假死" class="headerlink" title="连接假死"></a>连接假死</h4><p><strong>现象：</strong></p><ul><li>网络设备故障，比如网卡，机房等底层的TCP连接已经断开，但是<strong>应用程序没有感知到</strong>，仍然占用资源</li><li>公网网络波动，出现丢包。如果出现连续丢包，客户端数据发不出去，服务端一直接受不到，浪费资源</li><li>应用程序线程阻塞，无法进行数据读写</li></ul><p><strong>问题：</strong></p><ul><li>假死连接占用资源不能自动释放</li><li>向假死的连接发送数据，得到反馈超时。</li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>可以添加<font color=Red><code>IdleStateHandler</code></font>对空闲时间进行检测，通过构造函数可以传入三个参数</p><ul><li>readerIdleTimeSeconds 读空闲经过的秒数</li><li>writerIdleTimeSeconds 写空闲经过的秒数</li><li>allIdleTimeSeconds 读和写空闲经过的秒数</li></ul><p>当指定时间内未发生读或写事件时，<strong>会触发特定事件</strong></p><img src="https://s2.loli.net/2023/04/13/nL3NPtojxmiOwTg.png" style="zoom:50%;" /><ul><li><p>读空闲触发<font color=Red><code>READER_IDLE</code></font></p></li><li><p>写空闲触发<font color=Red><code>WRITE_IDLE</code></font></p></li><li><p>读写空闲会触发<font color=Red><code>ALL_IDLE</code></font></p></li><li><p>想要处理这些事件，<strong>需要自定义事件处理函数</strong></p></li><li><p><strong>服务器端代码</strong></p></li><li><pre><code class="java">// 用于空闲连接的检测，5s内未读到数据，会触发READ_IDLE事件ch.pipeline().addLast(new IdleStateHandler(5, 0, 0));// 添加双向处理器，负责处理READER_IDLE事件ch.pipeline().addLast(new ChannelDuplexHandler() &#123;    @Override    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;        // 获得事件        IdleStateEvent event = (IdleStateEvent) evt;        if (event.state() == IdleState.READER_IDLE) &#123;            // 断开连接            ctx.channel().close();        &#125;    &#125;&#125;);<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- 使用`IdleStateHandler`进行空闲检测<br><br>- 使用双向处理器`ChannelDuplexHandler`<br><br>  对入站与出站事件进行处理<br><br>  - `IdleStateHandler`中的事件为特殊事件，需要实现`ChannelDuplexHandler`的`userEventTriggered`方法，判断事件类型并自定义处理方式，来对事件进行处理<br><br>为**避免因非网络等原因引发的READ_IDLE事件**，比如网络情况良好，只是用户本身没有输入数据，这时发生READ_IDLE事件，**直接让服务器断开连接是不可取的**<br><br>为避免此类情况，需要在**客户端向服务器发送心跳包**，发送频率要**小于**服务器设置的`IdleTimeSeconds`，一般设置为其值的一半<br><br>```java<br>// 发送心跳包，让服务器知道客户端在线<br>// <span class="hljs-number">3</span>s未发生WRITER_IDLE，就像服务器发送心跳包<br>// 该值为服务器端设置的READER_IDLE触发时间的一半左右<br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> IdleStateHandler(<span class="hljs-number">0</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>))<span class="hljs-comment">;</span><br>ch.pipeline().addLast(<span class="hljs-keyword">new</span> ChannelDuplexHandler() &#123;<br>    @Override<br>    public void userEventTriggered(ChannelHandlerContext ctx, Object evt) throws Exception &#123;<br>        IdleStateEvent event = (IdleStateEvent) evt<span class="hljs-comment">;</span><br>        if (event.state() == IdleState.WRITER_IDLE) &#123;<br>            // 发送心跳包<br>            ctx.writeAndFlush(<span class="hljs-keyword">new</span> PingMessage())<span class="hljs-comment">;</span><br>        &#125;<br>    &#125;<br>&#125;)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></code></pre></li></ul><h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="1-拓展序列化算法"><a href="#1-拓展序列化算法" class="headerlink" title="1.拓展序列化算法"></a>1.拓展序列化算法</h2><p>序列化接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Serializer</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 序列化</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> object 被序列化的对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt; 被序列化对象类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 序列化后的字节数组</span><br><span class="hljs-comment">     */</span><br>    &lt;T&gt; <span class="hljs-type">byte</span>[] serialize(T object);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 反序列化</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> clazz 反序列化的目标类的Class对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bytes 被反序列化的字节数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> &lt;T&gt; 反序列化目标类</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 反序列化后的对象</span><br><span class="hljs-comment">     */</span><br>    &lt;T&gt; T <span class="hljs-title function_">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-type">byte</span>[] bytes)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="枚举实现类"><a href="#枚举实现类" class="headerlink" title="枚举实现类"></a>枚举实现类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> <span class="hljs-title class_">SerializerAlgorithm</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Serializer</span> &#123;<br>    <span class="hljs-comment">// Java的序列化和反序列化</span><br>    Java &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-type">byte</span>[] serialize(T object) &#123;<br>            <span class="hljs-comment">// 序列化后的字节数组</span><br>            <span class="hljs-type">byte</span>[] bytes = <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> (<span class="hljs-type">ByteArrayOutputStream</span> <span class="hljs-variable">bos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayOutputStream</span>();<br>                 <span class="hljs-type">ObjectOutputStream</span> <span class="hljs-variable">oos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectOutputStream</span>(bos)) &#123;<br>                oos.writeObject(object);<br>                bytes = bos.toByteArray();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-keyword">return</span> bytes;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-type">byte</span>[] bytes)</span> &#123;<br>            <span class="hljs-type">T</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            System.out.println(Arrays.toString(bytes));<br>            <span class="hljs-keyword">try</span> (<span class="hljs-type">ByteArrayInputStream</span> <span class="hljs-variable">bis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ByteArrayInputStream</span>(bytes);<br>                 <span class="hljs-type">ObjectInputStream</span> <span class="hljs-variable">ois</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectInputStream</span>(bis)) &#123;<br>                target = (T) ois.readObject();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException | ClassNotFoundException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            <span class="hljs-comment">// 返回反序列化后的对象</span><br>            <span class="hljs-keyword">return</span> target;<br>        &#125;<br>    &#125;<br>    <br>     <span class="hljs-comment">// Json的序列化和反序列化</span><br>    Json &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-type">byte</span>[] serialize(T object) &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>().toJson(object);<br>            System.out.println(s);<br>            <span class="hljs-comment">// 指定字符集，获得字节数组</span><br>            <span class="hljs-keyword">return</span> s.getBytes(StandardCharsets.UTF_8);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> &lt;T&gt; T <span class="hljs-title function_">deserialize</span><span class="hljs-params">(Class&lt;T&gt; clazz, <span class="hljs-type">byte</span>[] bytes)</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, StandardCharsets.UTF_8);<br>            System.out.println(s);<br>            <span class="hljs-comment">// 此处的clazz为具体类型的Class对象，而不是父类Message的</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Gson</span>().fromJson(s, clazz);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="修改原编解码器"><a href="#修改原编解码器" class="headerlink" title="修改原编解码器"></a>修改原编解码器</h3><p><strong>编码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获得序列化后的msg</span><br><span class="hljs-comment">// 使用指定的序列化方式</span><br>SerializerAlgorithm[] values = SerializerAlgorithm.values();<br><span class="hljs-comment">// 获得序列化后的对象</span><br><span class="hljs-type">byte</span>[] bytes = values[out.getByte(<span class="hljs-number">5</span>)-<span class="hljs-number">1</span>].serialize(msg);<br></code></pre></td></tr></table></figure><p><strong>解码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获得反序列化方式</span><br>SerializerAlgorithm[] values = SerializerAlgorithm.values();<br><span class="hljs-comment">// 通过指定方式进行反序列化</span><br><span class="hljs-comment">// 需要通过Message的方法获得具体的消息类型</span><br><span class="hljs-type">Message</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> values[seqType-<span class="hljs-number">1</span>].deserialize(Message.getMessageClass(messageType), bytes);<br></code></pre></td></tr></table></figure><h2 id="2、参数调优"><a href="#2、参数调优" class="headerlink" title="2、参数调优"></a>2、参数调优</h2><h3 id="CONNECT-TIMEOUT-MILLIS"><a href="#CONNECT-TIMEOUT-MILLIS" class="headerlink" title="CONNECT_TIMEOUT_MILLIS"></a>CONNECT_TIMEOUT_MILLIS</h3><ul><li>属于 <strong>SocketChannal</strong> 的参数</li><li>用在<strong>客户端建立连接</strong>时，如果在指定毫秒内无法连接，会抛出 timeout 异常</li><li><strong>注意</strong>：Netty 中不要用成了SO_TIMEOUT 主要用在阻塞 IO，而 Netty 是非阻塞 IO</li></ul><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a><strong>使用</strong></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestParam</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// SocketChannel 5s内未建立连接就抛出异常</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>().option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">5000</span>);<br>        <br>        <span class="hljs-comment">// ServerSocketChannel 5s内未建立连接就抛出异常</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>().option(ChannelOption.CONNECT_TIMEOUT_MILLIS,<span class="hljs-number">5000</span>);<br>        <span class="hljs-comment">// SocketChannel 5s内未建立连接就抛出异常</span><br>        <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>().childOption(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="hljs-number">5000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>客户端通过 <code>Bootstrap.option</code> 函数来配置参数，<strong>配置参数作用于 SocketChannel</strong></li><li>服务器通过<code>ServerBootstrap</code>来配置参数，但是对于不同的 Channel 需要选择不同的方法<ul><li>通过 <code>option</code> 来配置 <strong>ServerSocketChannel</strong> 上的参数</li><li>通过 <code>childOption</code> 来配置 <strong>SocketChannel</strong> 上的参数</li></ul></li></ul><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><p>客户端中连接服务器的线程是 NIO 线程，抛出异常的是主线程。这是如何做到超时判断以及线程通信的呢？</p><p><code>AbstractNioChannel.AbstractNioUnsafe.connect</code>方法中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">connect</span><span class="hljs-params">(</span><br><span class="hljs-params">                <span class="hljs-keyword">final</span> SocketAddress remoteAddress, <span class="hljs-keyword">final</span> SocketAddress localAddress, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> &#123;<br>    <br>    ...<br>        <br>    <span class="hljs-comment">// Schedule connect timeout.</span><br>    <span class="hljs-comment">// 设置超时时间，通过option方法传入的CONNECT_TIMEOUT_MILLIS参数进行设置</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">connectTimeoutMillis</span> <span class="hljs-operator">=</span> config().getConnectTimeoutMillis();<br>    <span class="hljs-comment">// 如果超时时间大于0</span><br>    <span class="hljs-keyword">if</span> (connectTimeoutMillis &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 创建一个定时任务，延时connectTimeoutMillis（设置的超时时间时间）后执行</span><br>        <span class="hljs-comment">// schedule(Runnable command, long delay, TimeUnit unit)</span><br>        connectTimeoutFuture = eventLoop().schedule(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-comment">// 判断是否建立连接，Promise进行NIO线程与主线程之间的通信</span><br>                <span class="hljs-comment">// 如果超时，则通过tryFailure方法将异常放入Promise中</span><br>                <span class="hljs-comment">// 在主线程中抛出</span><br>                <span class="hljs-type">ChannelPromise</span> <span class="hljs-variable">connectPromise</span> <span class="hljs-operator">=</span> AbstractNioChannel.<span class="hljs-built_in">this</span>.connectPromise;<br>                <span class="hljs-type">ConnectTimeoutException</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConnectTimeoutException</span>(<span class="hljs-string">&quot;connection timed out: &quot;</span> + remoteAddress);<br>                <span class="hljs-keyword">if</span> (connectPromise != <span class="hljs-literal">null</span> &amp;&amp; connectPromise.tryFailure(cause)) &#123;<br>                    close(voidPromise());<br>                &#125;<br>            &#125;<br>        &#125;, connectTimeoutMillis, TimeUnit.MILLISECONDS);<br>    &#125;<br>    <br>   ...<br>        <br>&#125;<br></code></pre></td></tr></table></figure><p>超时的判断<strong>主要是通过 Eventloop 的 schedule 方法和 Promise 共同实现的</strong></p><ul><li>schedule 设置了一个定时任务，延迟<code>connectTimeoutMillis</code>秒后执行该方法</li><li>如果指定时间内没有建立连接，则会执行其中的任务<ul><li>任务负责创建 <code>ConnectTimeoutException</code> 异常，并将异常通过 Pormise 传给主线程并抛出</li></ul></li></ul><h3 id="SO-BACKLOG"><a href="#SO-BACKLOG" class="headerlink" title="SO_BACKLOG"></a>SO_BACKLOG</h3><p>该参数是 <strong>ServerSocketChannel</strong> 的参数</p><h4 id="三次握手与连接队列"><a href="#三次握手与连接队列" class="headerlink" title="三次握手与连接队列"></a>三次握手与连接队列</h4><p>第一次握手时，因为客户端与服务器之间的连接还未完全建立，连接会被放入<strong>半连接队列</strong>中</p><img src="https://s2.loli.net/2023/04/13/A2XgtMTUcyPHJrK.png" style="zoom:80%;" /><p>当完成三次握手以后，连接会被放入<strong>全连接队列中</strong></p><img src="https://s2.loli.net/2023/04/13/tMYpGJCdSF3Xsue.png" style="zoom:80%;" /><p>服务器处理Accept事件是在TCP三次握手，也就是建立连接之后。服务器会从全连接队列中获取连接并进行处理</p><img src="https://s2.loli.net/2023/04/13/ndG6zjPKMQIb5wt.png" style="zoom:80%;" /><p>在 linux 2.2 之前，backlog 大小包括了两个队列的大小，<strong>在 linux 2.2 之后，分别用下面两个参数来控制</strong></p><ul><li>半连接队列 - sync queue<ul><li>大小通过 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;ipv4&#x2F;tcp_max_syn_backlog 指定，在 <code>syncookies</code> 启用的情况下，逻辑上没有最大值限制，这个设置便被忽略</li></ul></li><li>全连接队列 - accept queue<ul><li>其大小通过 &#x2F;proc&#x2F;sys&#x2F;net&#x2F;core&#x2F;somaxconn 指定，在使用 listen 函数时，<strong>内核会根据传入的 backlog 参数与系统参数，取二者的较小值</strong></li><li>如果 accpet queue 队列满了，server 将发送一个拒绝连接的错误信息到 client</li></ul></li></ul><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>在Netty中，<code>SO_BACKLOG</code>主要用于设置全连接队列的大小。<strong>当处理Accept的速率小于连接建立的速率时，全连接队列中堆积的连接数大于<code>SO_BACKLOG</code>设置的值是，便会抛出异常</strong></p><p><strong>设置方式如下</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 设置全连接队列，大小为2</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>().option(ChannelOption.SO_BACKLOG, <span class="hljs-number">2</span>);<br></code></pre></td></tr></table></figure><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>backlog参数在<code>NioSocketChannel.doBind</code>方法被使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBind</span><span class="hljs-params">(SocketAddress localAddress)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="hljs-number">7</span>) &#123;<br>        javaChannel().bind(localAddress, config.getBacklog());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        javaChannel().socket().bind(localAddress, config.getBacklog());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中backlog被保存在了<code>DefaultServerSocketChannelConfig</code>配置类中</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> backlog = NetUtil.SOMAXCONN;<br></code></pre></td></tr></table></figure><p>具体的赋值操作如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">SOMAXCONN = AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Integer&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// Determine the default somaxconn (server socket backlog) value of the platform.</span><br>        <span class="hljs-comment">// The known defaults:</span><br>        <span class="hljs-comment">// - Windows NT Server 4.0+: 200</span><br>        <span class="hljs-comment">// - Linux and Mac OS X: 128</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">somaxconn</span> <span class="hljs-operator">=</span> PlatformDependent.isWindows() ? <span class="hljs-number">200</span> : <span class="hljs-number">128</span>;<br>        <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(<span class="hljs-string">&quot;/proc/sys/net/core/somaxconn&quot;</span>);<br>        <span class="hljs-type">BufferedReader</span> <span class="hljs-variable">in</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// file.exists() may throw a SecurityException if a SecurityManager is used, so execute it in the</span><br>            <span class="hljs-comment">// try / catch block.</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/4936</span><br>            <span class="hljs-keyword">if</span> (file.exists()) &#123;<br>                in = <span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedReader</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FileReader</span>(file));<br>                <span class="hljs-comment">// 将somaxconn设置为Linux配置文件中设置的值</span><br>                somaxconn = Integer.parseInt(in.readLine());<br>                <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                    logger.debug(<span class="hljs-string">&quot;&#123;&#125;: &#123;&#125;&quot;</span>, file, somaxconn);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ...<br>            &#125;<br>            ...<br>        &#125;  <br>        <span class="hljs-comment">// 返回backlog的值</span><br>        <span class="hljs-keyword">return</span> somaxconn;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>- </p><ul><li><p>backlog的值会根据操作系统的不同，来</p><p>选择不同的默认值</p><ul><li>Windows 200</li><li>Linux&#x2F;Mac OS 128</li></ul></li><li><p><strong>如果配置文件<code>/proc/sys/net/core/somaxconn</code>存在</strong>，会读取配置文件中的值，并将backlog的值设置为配置文件中指定的</p></li></ul><h3 id="TCP-NODELAY"><a href="#TCP-NODELAY" class="headerlink" title="TCP_NODELAY"></a>TCP_NODELAY</h3><ul><li>属于 <strong>SocketChannal</strong> 参数</li><li>因为 Nagle 算法，数据包会堆积到一定的数量后一起发送，这就<strong>可能导致数据的发送存在一定的延时</strong></li><li><strong>该参数默认为false</strong>，如果不希望的发送被延时，则需要将该值设置为true</li></ul><h3 id="SO-SNDBUF-amp-SO-RCVBUF"><a href="#SO-SNDBUF-amp-SO-RCVBUF" class="headerlink" title="SO_SNDBUF &amp; SO_RCVBUF"></a>SO_SNDBUF &amp; SO_RCVBUF</h3><ul><li>SO_SNDBUF 属于 <strong>SocketChannal</strong> 参数</li><li>SO_RCVBUF <strong>既可用于 SocketChannal 参数，也可以用于 ServerSocketChannal 参数</strong>（建议设置到 ServerSocketChannal 上）</li><li>该参数用于<strong>指定接收方与发送方的滑动窗口大小</strong></li></ul><h3 id="ALLOCATOR"><a href="#ALLOCATOR" class="headerlink" title="ALLOCATOR"></a>ALLOCATOR</h3><ul><li>属于 <strong>SocketChannal</strong> 参数</li><li>用来配置 ByteBuf 是池化还是非池化，是直接内存还是堆内存</li></ul><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 选择ALLOCATOR参数，设置SocketChannel中分配的ByteBuf类型</span><br><span class="hljs-comment">// 第二个参数需要传入一个ByteBufAllocator，用于指定生成的 ByteBuf 的类型</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>().childOption(ChannelOption.ALLOCATOR, <span class="hljs-keyword">new</span> <span class="hljs-title class_">PooledByteBufAllocator</span>());<br></code></pre></td></tr></table></figure><p><strong>ByteBufAllocator类型</strong></p><ul><li><p>池化并使用直接内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// true表示使用直接内存</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">PooledByteBufAllocator</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure></li><li><p>池化并使用堆内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// false表示使用堆内存</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">PooledByteBufAllocator</span>(<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure></li><li><p>非池化并使用直接内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// ture表示使用直接内存</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">UnpooledByteBufAllocator</span>(<span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure></li><li><p>非池化并使用堆内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// false表示使用堆内存</span><br><span class="hljs-keyword">new</span> <span class="hljs-title class_">UnpooledByteBufAllocator</span>(<span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure></li></ul><h3 id="RCVBUF-ALLOCATOR"><a href="#RCVBUF-ALLOCATOR" class="headerlink" title="RCVBUF_ALLOCATOR"></a>RCVBUF_ALLOCATOR</h3><ul><li>属于 <strong>SocketChannal</strong> 参数</li><li><strong>控制 Netty 接收缓冲区大小</strong></li><li>负责入站数据的分配，决定入站缓冲区的大小（并可动态调整），<strong>统一采用 direct 直接内存</strong>，具体池化还是非池化由 allocator 决定</li></ul><h2 id="3-PRC框架"><a href="#3-PRC框架" class="headerlink" title="3.PRC框架"></a>3.PRC框架</h2><p>…</p><h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><h2 id="1-启动流程"><a href="#1-启动流程" class="headerlink" title="1.启动流程"></a>1.启动流程</h2><p>Netty启动流程可以简化成如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// netty 中使用 NioEventLoopGroup （简称 nio boss 线程）来封装线程和 selector</span><br><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open(); <br><br><span class="hljs-comment">// 创建 NioServerSocketChannel，同时会初始化它关联的 handler，以及为原生 ssc 存储 config</span><br><span class="hljs-type">NioServerSocketChannel</span> <span class="hljs-variable">attachment</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioServerSocketChannel</span>();<br><br><span class="hljs-comment">// 创建 NioServerSocketChannel 时，创建了 java 原生的 ServerSocketChannel</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocketChannel</span> <span class="hljs-operator">=</span> ServerSocketChannel.open(); <br>serverSocketChannel.configureBlocking(<span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">// 启动 nio boss 线程执行接下来的操作</span><br><br><span class="hljs-comment">//注册（仅关联 selector 和 NioServerSocketChannel），未关注事件</span><br><span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> serverSocketChannel.register(selector, <span class="hljs-number">0</span>, attachment);<br><br><span class="hljs-comment">// head -&gt; 初始化器 -&gt; ServerBootstrapAcceptor -&gt; tail，初始化器是一次性的，只为添加 acceptor</span><br><br><span class="hljs-comment">// 绑定端口</span><br>serverSocketChannel.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-number">8080</span>));<br><br><span class="hljs-comment">// 触发 channel active 事件，在 head 中关注 op_accept 事件</span><br>selectionKey.interestOps(SelectionKey.OP_ACCEPT);<br></code></pre></td></tr></table></figure><ul><li>获得选择器Selector，Netty中使用NioEventloopGroup中的NioEventloop封装了线程和选择器</li><li>创建<code>NioServerSocketChannel</code>，该Channel<strong>作为附件</strong>添加到<code>ServerSocketChannel</code>中</li><li>创建<code>ServerSocketChannel</code>，将其设置为非阻塞模式，并注册到Selector中，<strong>此时未关注事件，但是添加了附件</strong><code>NioServerSocketChannel</code></li><li>绑定端口</li><li>通过<code>interestOps</code>设置感兴趣的事件</li></ul><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p>选择器Selector的创建是在NioEventloopGroup中完成的。<strong>NioServerSocketChannel与ServerSocketChannel的创建，ServerSocketChannel注册到Selector中以及绑定操作都是由<code>bind</code>方法完成的</strong></p><p>所以服务器启动的<strong>入口</strong>便是<code>io.netty.bootstrap.ServerBootstrap.bind</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">bind</span><span class="hljs-params">(SocketAddress localAddress)</span> &#123;<br>validate();<br><span class="hljs-keyword">return</span> doBind(ObjectUtil.checkNotNull(localAddress, <span class="hljs-string">&quot;localAddress&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="doBind"><a href="#doBind" class="headerlink" title="doBind"></a>doBind</h3><p>真正完成初始化、注册以及绑定的<strong>方法是<code>io.netty.bootstrap.AbstractBootstrap.doBind</code></strong></p><p><strong>dobind方法在主线程中执行</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-title function_">doBind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress)</span> &#123;<br>    <span class="hljs-comment">// 负责NioServerSocketChannel和ServerSocketChannel的创建</span><br>    <span class="hljs-comment">// ServerSocketChannel的注册工作</span><br>    <span class="hljs-comment">// init由main线程完成，regisetr由NIO线程完成</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">regFuture</span> <span class="hljs-operator">=</span> initAndRegister();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> regFuture.channel();<br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> regFuture;<br>    &#125;<br><br>    <span class="hljs-comment">// 因为register操作是异步的</span><br>    <span class="hljs-comment">// 所以要判断主线程执行到这里时，register操作是否已经执行完毕</span><br>    <span class="hljs-keyword">if</span> (regFuture.isDone()) &#123;<br>        <span class="hljs-comment">// At this point we know that the registration was complete and successful.</span><br>        <span class="hljs-type">ChannelPromise</span> <span class="hljs-variable">promise</span> <span class="hljs-operator">=</span> channel.newPromise();<br>        <br>        <span class="hljs-comment">// 执行doBind0绑定操作</span><br>        doBind0(regFuture, channel, localAddress, promise);<br>        <span class="hljs-keyword">return</span> promise;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// Registration future is almost always fulfilled already, but just in case it&#x27;s not.</span><br>        <span class="hljs-comment">// 如果register操作还没执行完，就会到这个分支中来</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">PendingRegistrationPromise</span> <span class="hljs-variable">promise</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PendingRegistrationPromise</span>(channel);<br>        <br>        <span class="hljs-comment">// 添加监听器，NIO线程异步进行doBind0操作</span><br>        regFuture.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> future.cause();<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span><br>                    <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span><br>                    promise.setFailure(cause);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span><br>                    <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span><br>                    promise.registered();<br><br>                    doBind0(regFuture, channel, localAddress, promise);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> promise;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>doBind()中有两个重要方法<code>initAndRegister()</code>和<code>doBind0(regFuture, channel, localAddress, promise)</code></li><li><strong>initAndRegister</strong>主要负责NioServerSocketChannel和ServerSocketChannel的创建（主线程中完成）与ServerSocketChannel注册（NIO线程中完成）工作</li><li><strong>doBind0</strong>则负责连接的创建工作</li></ul><h3 id="initAndRegisterd"><a href="#initAndRegisterd" class="headerlink" title="initAndRegisterd"></a>initAndRegisterd</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title function_">initAndRegister</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        channel = channelFactory.newChannel();<br>        init(channel);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-keyword">if</span> (channel != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// channel can be null if newChannel crashed (eg SocketException(&quot;too many open files&quot;))</span><br>            channel.unsafe().closeForcibly();<br>            <span class="hljs-comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultChannelPromise</span>(channel, GlobalEventExecutor.INSTANCE).setFailure(t);<br>        &#125;<br>        <span class="hljs-comment">// as the Channel is not registered yet we need to force the usage of the GlobalEventExecutor</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultChannelPromise</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FailedChannel</span>(), GlobalEventExecutor.INSTANCE).setFailure(t);<br>    &#125;<br><br>    <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">regFuture</span> <span class="hljs-operator">=</span> config().group().register(channel);<br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (channel.isRegistered()) &#123;<br>            channel.close();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            channel.unsafe().closeForcibly();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// If we are here and the promise is not failed, it&#x27;s one of the following cases:</span><br>    <span class="hljs-comment">// 1) If we attempted registration from the event loop, the registration has been completed at this point.</span><br>    <span class="hljs-comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now because the channel has been registered.</span><br>    <span class="hljs-comment">// 2) If we attempted registration from the other thread, the registration request has been successfully</span><br>    <span class="hljs-comment">//    added to the event loop&#x27;s task queue for later execution.</span><br>    <span class="hljs-comment">//    i.e. It&#x27;s safe to attempt bind() or connect() now:</span><br>    <span class="hljs-comment">//         because bind() or connect() will be executed *after* the scheduled registration task is executed</span><br>    <span class="hljs-comment">//         because register(), bind(), and connect() are all bound to the same thread.</span><br><br>    <span class="hljs-keyword">return</span> regFuture;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="init"><a href="#init" class="headerlink" title="init"></a>init</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 通过反射初始化NioServerSocketChannel</span><br>    channel = channelFactory.newChannel();<br>    init(channel);<br>&#125;<br></code></pre></td></tr></table></figure><p>newChannel方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> T <span class="hljs-title function_">newChannel</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 通过反射调用NioServerSocketChannel的构造方法</span><br>        <span class="hljs-comment">// 创建NioServerSocketChannel对象</span><br>        <span class="hljs-keyword">return</span> constructor.newInstance();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelException</span>(<span class="hljs-string">&quot;Unable to create Channel from class &quot;</span> + constructor.getDeclaringClass(), t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>NioServerSocketChannel构造方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">NioServerSocketChannel</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建了ServerSocketChannel实例</span><br>    <span class="hljs-built_in">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));<br>&#125;<br></code></pre></td></tr></table></figure><p>newSocket方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ServerSocketChannel <span class="hljs-title function_">newSocket</span><span class="hljs-params">(SelectorProvider provider)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// ServerSocketChannel.open方法：</span><br>        <span class="hljs-comment">// SelectorProvider.provider().openServerSocketChannel()</span><br>    <span class="hljs-comment">// 所以此处相当于ServerSocketChannel.open()</span><br>        <span class="hljs-comment">// 创建了ServerSocketChannel实例</span><br>    <span class="hljs-keyword">return</span> provider.openServerSocketChannel();<br>&#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelException</span>(<span class="hljs-string">&quot;Failed to open a server socket.&quot;</span>, e);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>init方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(Channel channel)</span> &#123;<br>   ...<br><br>    <span class="hljs-comment">// NioSocketChannl的Pipeline    </span><br>    <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> channel.pipeline();<br><br>    ...<br><br>    <span class="hljs-comment">// 向Pipeline中添加了一个handler，该handler等待被调用</span><br>    p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-comment">// register之后才调用该方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>            <br>            <span class="hljs-comment">// 创建handler并加入到pipeline中</span><br>            <span class="hljs-type">ChannelHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> config.handler();<br>            <span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) &#123;<br>                pipeline.addLast(handler);<br>            &#125;<br><br>            ch.eventLoop().execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-comment">// 添加新的handler，在发生Accept事件后建立连接</span><br>                    pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrapAcceptor</span>(<br>                            ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>init主要完成了以下三个操作</strong></p><ul><li>创建NioServerSocketChannel</li><li>通过NioServerSocketChannel的构造器，创建了ServerSocketChannel</li><li>由<code>initChannel</code>方法向NioServerSocketChannel中添加了两个handler，添加操作在register之后被执行<ul><li>一个handler负责设置配置</li><li>一个handler负责发生Accepet事件后建立连接</li></ul></li></ul><h4 id="Register"><a href="#Register" class="headerlink" title="Register"></a>Register</h4><p>init执行完毕后，便执行<code>ChannelFuture regFuture = config().group().register(channel)</code>操作</p><p>该方法最终调用的是<code>promise.channel().unsafe().register(this, promise)</code>方法</p><p><strong>promise.channel().unsafe().register(this, promise)</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> &#123;<br>    ...<br><br>    <span class="hljs-comment">// 获取EventLoop</span><br>    AbstractChannel.<span class="hljs-built_in">this</span>.eventLoop = eventLoop;<br><br>   <span class="hljs-comment">// 此处完成了由 主线程 到 NIO线程 的切换</span><br>    <span class="hljs-comment">// eventLoop.inEventLoop()用于判断当前线程是否为NIO线程</span><br>    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;<br>        register0(promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 向NIO线程中添加任务</span><br>            eventLoop.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-comment">// 该方法中会执行doRegister</span><br>                    <span class="hljs-comment">// 执行真正的注册操作</span><br>                    register0(promise);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>           ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>register0方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register0</span><span class="hljs-params">(ChannelPromise promise)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>       ...<br>            <br>        <span class="hljs-comment">// 执行真正的注册操作</span><br>        doRegister();<br>        neverRegistered = <span class="hljs-literal">false</span>;<br>        registered = <span class="hljs-literal">true</span>;<br><br>        <span class="hljs-comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span><br>        <span class="hljs-comment">// user may already fire events through the pipeline in the ChannelFutureListener.</span><br>        <br>        <span class="hljs-comment">// 调用init中的initChannel方法</span><br>        pipeline.invokeHandlerAddedIfNeeded();<br><br>        ...<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>doRegister方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">selected</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// javaChannel()即为ServerSocketChannel</span><br>            <span class="hljs-comment">// eventLoop().unwrappedSelector()获取eventLoop中的Selector</span><br>            <span class="hljs-comment">// this为NIOServerSocketChannel，作为附件</span><br>            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;<br>            ...<br>           <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>回调initChannel</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>    <span class="hljs-type">ChannelHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> config.handler();<br>    <span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) &#123;<br>        pipeline.addLast(handler);<br>    &#125;<br><br>    <span class="hljs-comment">// 添加新任务，任务负责添加handler</span><br>    <span class="hljs-comment">// 该handler负责发生Accepet事件后建立连接</span><br>    ch.eventLoop().execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrapAcceptor</span>(<br>                    ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>Register主要完成了以下三个操作</p><ul><li><p>完成了主线程到NIO的<strong>线程切换</strong></p><ul><li>通过<code>eventLoop.inEventLoop()</code>进行线程判断，判断当前线程是否为NIO线程</li><li>切换的方式为让eventLoop执行register的操作</li><li><strong>register的操作在NIO线程中完成</strong></li></ul></li><li><p><strong>调用doRegister方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// javaChannel()即为ServerSocketChannel</span><br><span class="hljs-comment">// eventLoop().unwrappedSelector()获取eventLoop中的Selector</span><br><span class="hljs-comment">// this为NIOServerSocketChannel，作为附件</span><br>selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-built_in">this</span>);<br></code></pre></td></tr></table></figure></li><li><ul><li><strong>将ServerSocketChannel注册到EventLoop的Selector中</strong></li><li>此时还未关注事件</li><li>添加NioServerSocketChannel附件</li></ul></li><li><p>通过<code>invokeHandlerAddedIfNeeded</code>调用init中的<code>initChannel</code>方法</p><ul><li><p>initChannel方法主要创建了</p><p>两个handler</p><ul><li>一个handler负责设置配置</li><li>一个handler负责发生Accept事件后建立连接</li></ul></li></ul></li></ul><h3 id="doBind0"><a href="#doBind0" class="headerlink" title="doBind0"></a>doBind0</h3><h4 id="绑定端口"><a href="#绑定端口" class="headerlink" title="绑定端口"></a>绑定端口</h4><p>在<code>doRegister</code>和<code>invokeHandlerAddedIfNeeded</code>操作中的完成后，会调用<code>safeSetSuccess(promise)</code>方法，向Promise中设置执行成功的结果。此时<code>doBind</code>方法中由<code>initAndRegister</code>返回的ChannelFuture对象regFuture便会由NIO线程异步执行doBind0绑定操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// initAndRegister为异步方法，会返回ChannelFuture对象</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">regFuture</span> <span class="hljs-operator">=</span> initAndRegister();<br>regFuture.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">Throwable</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> future.cause();<br>        <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// Registration on the EventLoop failed so fail the ChannelPromise directly to not cause an</span><br>            <span class="hljs-comment">// IllegalStateException once we try to access the EventLoop of the Channel.</span><br>            promise.setFailure(cause);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Registration was successful, so set the correct executor to use.</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/2586</span><br>            promise.registered();<br>            <span class="hljs-comment">// 如果没有异常，则执行绑定操作</span><br>            doBind0(regFuture, channel, localAddress, promise);<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p><strong>doBind0最底层调用的是ServerSocketChannel的bind方法</strong></p><p>NioServerSocketChannel.doBind方法</p><p>通过该方法，绑定了对应的端口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SuppressJava6Requirement(reason = &quot;Usage guarded by java version check&quot;)</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBind</span><span class="hljs-params">(SocketAddress localAddress)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="hljs-number">7</span>) &#123;<br>        <span class="hljs-comment">// 调用ServerSocketChannel的bind方法，绑定端口</span><br>        javaChannel().bind(localAddress, config.getBacklog());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        javaChannel().socket().bind(localAddress, config.getBacklog());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="关注事件"><a href="#关注事件" class="headerlink" title="关注事件"></a>关注事件</h4><p>在绑定端口操作完成后，会判断各种所有初始化操作是否已经完成，若完成，则会添加ServerSocketChannel感兴趣的事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (!wasActive &amp;&amp; isActive()) &#123;<br>    invokeLater(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            pipeline.fireChannelActive();<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>最终在<code>AbstractNioChannel.doBeginRead</code>方法中，会添加ServerSocketChannel添加Accept事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.selectionKey;<br>    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    readPending = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">interestOps</span> <span class="hljs-operator">=</span> selectionKey.interestOps();<br>    <span class="hljs-comment">// 如果ServerSocketChannel没有关注Accept事件</span><br>    <span class="hljs-keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 则让其关注Accepet事件</span><br>        <span class="hljs-comment">// readInterestOp 取值是 16</span><br>        <span class="hljs-comment">// 在 NioServerSocketChannel 创建时初始化</span><br>        selectionKey.interestOps(interestOps | readInterestOp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：此处设置interestOps时使用的方法，<strong>避免覆盖关注的其他事件</strong></p><ul><li><p>首先获取Channel所有感兴趣的事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">interestOps</span> <span class="hljs-operator">=</span> selectionKey.interestOps();<br></code></pre></td></tr></table></figure></li><li><p>然后再设置其感兴趣的事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">selectionKey.interestOps(interestOps | readInterestOp);<br></code></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过上述步骤，完成了</p><ul><li>NioServerSocketChannel与ServerSocketChannel的创建</li><li>ServerSocketChannel绑定到EventLoop的Selecot中，并添加NioServerSocketChannel附件</li><li>绑定了对应的端口</li><li>关注了Accept事件</li></ul><h2 id="2-NioEventLoop剖析"><a href="#2-NioEventLoop剖析" class="headerlink" title="2.NioEventLoop剖析"></a>2.NioEventLoop剖析</h2><h3 id="组成-1"><a href="#组成-1" class="headerlink" title="组成"></a>组成</h3><p>NioEventLoop的重要组成部分有三个</p><ul><li><p><strong>Selector</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NioEventLoop</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SingleThreadEventLoop</span> &#123;<br>    <br>    ...<br>        <br>    <span class="hljs-comment">// selector中的selectedKeys是基于数组的</span><br>    <span class="hljs-comment">// unwrappedSelector中的selectedKeys是基于HashSet的    </span><br>    <span class="hljs-keyword">private</span> Selector selector;<br>    <span class="hljs-keyword">private</span> Selector unwrappedSelector;<br>    <span class="hljs-keyword">private</span> SelectedSelectionKeySet selectedKeys;<br>    <br>    ...<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>Thread与TaskQueue</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SingleThreadEventExecutor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractScheduledEventExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">OrderedEventExecutor</span> &#123;<br>    <span class="hljs-comment">// 任务队列</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Queue&lt;Runnable&gt; taskQueue;<br><br>    <span class="hljs-comment">// 线程</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> Thread thread;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h4 id="Selector的创建"><a href="#Selector的创建" class="headerlink" title="Selector的创建"></a>Selector的创建</h4><p>Selector是在NioEventLoop的构造方法中被创建的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">NioEventLoop(NioEventLoopGroup parent, Executor executor, SelectorProvider selectorProvider, SelectStrategy strategy, RejectedExecutionHandler rejectedExecutionHandler, EventLoopTaskQueueFactory queueFactory) &#123;<br>    <br>        ...<br>           <br>        <span class="hljs-comment">// 初始化selector，初始化过程在openSelector中</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">SelectorTuple</span> <span class="hljs-variable">selectorTuple</span> <span class="hljs-operator">=</span> openSelector();<br>        <span class="hljs-built_in">this</span>.selector = selectorTuple.selector;<br>        <span class="hljs-built_in">this</span>.unwrappedSelector = selectorTuple.unwrappedSelector;<br>&#125;<br><br><br><span class="hljs-keyword">private</span> SelectorTuple <span class="hljs-title function_">openSelector</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Selector unwrappedSelector;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 此处等同于 Selector.open()方法</span><br>        <span class="hljs-comment">// 创建了unwrappedSelector对象</span><br>        unwrappedSelector = provider.openSelector();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelException</span>(<span class="hljs-string">&quot;failed to open a new selector&quot;</span>, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>NioEventLoop的构造方法中，调用了<code>openSelector()</code>方法， 该方法会返回一个</p><p><strong>SelectorTuple</strong>对象，该方法<strong>是创建Selector的核心方法</strong>。<code>openSelector()</code>方法内部调用了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">unwrappedSelector = provider.openSelector();<br></code></pre></td></tr></table></figure><p>获得了Selector对象<code>unwrappedSelector</code></p><p>后面会通过反射，修改<code>unwrappedSelector</code>中SelectedKeys的实现，然后通过<code>SelectedSelectionKeySetSelector</code>方法获得selector。<strong>最后通过SelectorTuple的构造方法，将该Selector的值赋给SelectorTuple类中的selector与unwrappedSelector</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectorTuple</span> &#123;<br>    <span class="hljs-keyword">final</span> Selector unwrappedSelector;<br>    <span class="hljs-keyword">final</span> Selector selector;<br><br>    SelectorTuple(Selector unwrappedSelector) &#123;<br>        <span class="hljs-built_in">this</span>.unwrappedSelector = unwrappedSelector;<br>        <span class="hljs-built_in">this</span>.selector = unwrappedSelector;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 一般调用的是这个构造方法</span><br><span class="hljs-comment">    */</span><br>    SelectorTuple(Selector unwrappedSelector, Selector selector) &#123;<br>        <span class="hljs-built_in">this</span>.unwrappedSelector = unwrappedSelector;<br>        <span class="hljs-built_in">this</span>.selector = selector;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>再通过NioEventLoop的构造方法，将SelectorTuple中的Selector赋值给NioEventLoop中的Selector</strong></p><h4 id="两个Selector"><a href="#两个Selector" class="headerlink" title="两个Selector"></a>两个Selector</h4><p>NioEventLoop中有selector和unwrappedSelector两个Selector，<strong>它们的区别主要在于SelectedKeys的数据结构</strong></p><ul><li>selector中的SelectedKeys是<strong>基于数组</strong>的</li><li>unwrappedSelector中的是<strong>基于HashSet</strong>的</li></ul><p>这样做的主要目的是，<strong>数组的遍历效率要高于HashSet</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> SelectorTuple <span class="hljs-title function_">openSelector</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> Selector unwrappedSelector;<br>    <span class="hljs-keyword">try</span> &#123;<br>        unwrappedSelector = provider.openSelector();<br>    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelException</span>(<span class="hljs-string">&quot;failed to open a new selector&quot;</span>, e);<br>    &#125;<br><br>    ...<br>    <br>    <span class="hljs-comment">// 获得基于数组的selectedKeySet实现</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">SelectedSelectionKeySet</span> <span class="hljs-variable">selectedKeySet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectedSelectionKeySet</span>();<br><br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">maybeException</span> <span class="hljs-operator">=</span> AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Object&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 通过反射拿到unwrappedSelector中的selectedKeys属性</span><br>                <span class="hljs-type">Field</span> <span class="hljs-variable">selectedKeysField</span> <span class="hljs-operator">=</span> selectorImplClass.getDeclaredField(<span class="hljs-string">&quot;selectedKeys&quot;</span>);<br>                <span class="hljs-type">Field</span> <span class="hljs-variable">publicSelectedKeysField</span> <span class="hljs-operator">=</span> selectorImplClass.getDeclaredField(<span class="hljs-string">&quot;publicSelectedKeys&quot;</span>);<br><br>                ...<br><br>                <span class="hljs-comment">// 暴力反射，修改私有属性</span><br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> ReflectionUtil.trySetAccessible(selectedKeysField, <span class="hljs-literal">true</span>);<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> cause;<br>                &#125;<br>                cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField, <span class="hljs-literal">true</span>);<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-keyword">return</span> cause;<br>                &#125;<br><br>                <span class="hljs-comment">// 替换为基于数组的selectedKeys实现</span><br>                selectedKeysField.set(unwrappedSelector, selectedKeySet);<br>                publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>                <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                <span class="hljs-keyword">return</span> e;<br>            &#125;<br>        &#125;<br>    &#125;);<br><br>    selectedKeys = selectedKeySet;<br>    <br>    <span class="hljs-comment">// 调用构造函数，创建unwrappedSelector与selector</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectorTuple</span>(unwrappedSelector,<br>                             <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectedSelectionKeySetSelector</span>(unwrappedSelector, selectedKeySet));<br>&#125;<br></code></pre></td></tr></table></figure><p>获得数组实现SelectedKeys的Selector的原理是反射，主要步骤如下</p><ul><li><p>获得<strong>基于数组</strong>的selectedKeySet实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 获得基于数组的selectedKeySet实现</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">SelectedSelectionKeySet</span> <span class="hljs-variable">selectedKeySet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectedSelectionKeySet</span>();<br><br>SelectedSelectionKeySet() &#123;<br>keys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectionKey</span>[<span class="hljs-number">1024</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>通过<strong>反射</strong>拿到unwrappedSelector中的SelectedKeySet并将其<strong>替换为selectedKeySet</strong></p></li><li><p><strong>通过Selector的构造方法</strong>获得selector</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">new</span> <span class="hljs-constructor">SelectedSelectionKeySetSelector(<span class="hljs-params">unwrappedSelector</span>, <span class="hljs-params">selectedKeySet</span>)</span><br></code></pre></td></tr></table></figure></li><li><p><strong>通过SelectorTuple的构造方法</strong>获得拥有两种Selector的SelectorTuple对象，并返回给NioEventLoop</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 调用构造函数，创建unwrappedSelector与selector</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectorTuple</span>(unwrappedSelector, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectedSelectionKeySetSelector</span>(unwrappedSelector, selectedKeySet));<br></code></pre></td></tr></table></figure></li></ul><h3 id="NIO线程启动时机"><a href="#NIO线程启动时机" class="headerlink" title="NIO线程启动时机"></a>NIO线程启动时机</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>NioEventLoop中的线程，<strong>在首次执行任务时，才会被创建，且只会被创建一次</strong></p><p><strong>测试代码</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestNioEventLoop</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">EventLoop</span> <span class="hljs-variable">eventLoop</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>().next();<br>        <span class="hljs-comment">// 使用NioEventLoop执行任务</span><br>        eventLoop.execute(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;hello&quot;</span>);<br>        &#125;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入<code>execute</code>执行任务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task)</span> &#123;<br>    <span class="hljs-comment">// 检测传入的任务是否为空，为空会抛出NullPointerException</span><br>    ObjectUtil.checkNotNull(task, <span class="hljs-string">&quot;task&quot;</span>);<br>    <span class="hljs-comment">// 执行任务</span><br>    <span class="hljs-comment">// 此处判断了任务是否为懒加载任务，wakesUpForTask的返回值只会为true</span><br>    execute(task, !(task <span class="hljs-keyword">instanceof</span> LazyRunnable) &amp;&amp; wakesUpForTask(task));<br>&#125;<br></code></pre></td></tr></table></figure><p>进入上述代码的<code>execute</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span><span class="hljs-params">(Runnable task, <span class="hljs-type">boolean</span> immediate)</span> &#123;<br>    <span class="hljs-comment">// 判断当前线程是否为NIO线程</span><br>    <span class="hljs-comment">// 判断方法为 return thread == this.thread;</span><br>    <span class="hljs-comment">// this.thread即为NIO线程，首次执行任务时，其为null</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">inEventLoop</span> <span class="hljs-operator">=</span> inEventLoop();<br>    <br>    <span class="hljs-comment">// 向任务队列taskQueue中添加任务</span><br>    addTask(task);<br>    <br>    <span class="hljs-comment">// 当前线程不是NIO线程，则进入if语句</span><br>    <span class="hljs-keyword">if</span> (!inEventLoop) &#123;<br>        <span class="hljs-comment">// 启动NIO线程的核心方法</span><br>        startThread();<br>        <br>        ...<br>        <br>    &#125;<br><br>    <span class="hljs-comment">// 有任务需要被执行时，唤醒阻塞的NIO线程</span><br>    <span class="hljs-keyword">if</span> (!addTaskWakesUp &amp;&amp; immediate) &#123;<br>        wakeup(inEventLoop);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>进入<code>startThread</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">startThread</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 查看NIO线程状态是否为未启动</span><br>    <span class="hljs-comment">// 该if代码块只会执行一次</span><br>    <span class="hljs-comment">// state一开始的值就是ST_NOT_STARTED</span><br>    <span class="hljs-comment">// private volatile int state = ST_NOT_STARTED;</span><br>    <span class="hljs-keyword">if</span> (state == ST_NOT_STARTED) &#123;<br>        <span class="hljs-comment">// 通过原子属性更新器将状态更新为启动（ST_STARTED）</span><br>        <span class="hljs-keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="hljs-built_in">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 执行启动线程</span><br>                doStartThread();<br>                success = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (!success) &#123;<br>                    STATE_UPDATER.compareAndSet(<span class="hljs-built_in">this</span>, ST_STARTED, ST_NOT_STARTED);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>进入<code>doStartThread</code>，真正创建NIO线程并执行任务</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doStartThread</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">assert</span> thread == <span class="hljs-literal">null</span>;<br>    <span class="hljs-comment">// 创建NIO线程并执行任务</span><br>    executor.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// thread即为NIO线程</span><br>            thread = Thread.currentThread();<br>            <span class="hljs-keyword">if</span> (interrupted) &#123;<br>                thread.interrupt();<br>            &#125;<br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            updateLastExecutionTime();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 执行内部run方法</span><br>                SingleThreadEventExecutor.<span class="hljs-built_in">this</span>.run();<br>                success = <span class="hljs-literal">true</span>;<br>            &#125; <br>            <br>            ...<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>SingleThreadEventExecutor.this.run()</code>执行传入的任务（task）</p><p>该run方法是<strong>NioEvnetLoop的run方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">selectCnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 死循环，不断地从任务队列中获取各种任务来执行</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-comment">// 执行各种任务</span><br>   <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">int</span> strategy;<br>            <span class="hljs-keyword">try</span> &#123;<br>                strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());<br>                <span class="hljs-keyword">switch</span> (strategy) &#123;<br>                <span class="hljs-keyword">case</span> SelectStrategy.CONTINUE:<br>                    <span class="hljs-keyword">continue</span>;<br><br>                <span class="hljs-keyword">case</span> SelectStrategy.BUSY_WAIT:<br>                    <span class="hljs-comment">// fall-through to SELECT since the busy-wait is not supported with NIO</span><br><br>                <span class="hljs-keyword">case</span> SelectStrategy.SELECT:<br>                    <span class="hljs-type">long</span> <span class="hljs-variable">curDeadlineNanos</span> <span class="hljs-operator">=</span> nextScheduledTaskDeadlineNanos();<br>                    <span class="hljs-keyword">if</span> (curDeadlineNanos == -<span class="hljs-number">1L</span>) &#123;<br>                        curDeadlineNanos = NONE; <span class="hljs-comment">// nothing on the calendar</span><br>                    &#125;<br>                    nextWakeupNanos.set(curDeadlineNanos);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">if</span> (!hasTasks()) &#123;<br>                            strategy = select(curDeadlineNanos);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        <span class="hljs-comment">// This update is just to help block unnecessary selector wakeups</span><br>                        <span class="hljs-comment">// so use of lazySet is ok (no race condition)</span><br>                        nextWakeupNanos.lazySet(AWAKE);<br>                    &#125;<br>                    <span class="hljs-comment">// fall through</span><br>                <span class="hljs-keyword">default</span>:<br>                &#125;<br>       &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h4><p>NioEvnetLoop需要IO事件、普通任务以及定时任务，任务在run方法的for循环中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">selectCnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">// 死循环，不断地从任务队列中获取各种任务来执行</span><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>      <span class="hljs-comment">// 执行各种任务</span><br>   ...<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>中被执行，但<strong>该循环不会空转，执行到某些代码时，会被阻塞</strong></p><p>run方法中有SELECT分支</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">case</span> SelectStrategy.SELECT:<br><span class="hljs-type">long</span> <span class="hljs-variable">curDeadlineNanos</span> <span class="hljs-operator">=</span> nextScheduledTaskDeadlineNanos();<br><span class="hljs-keyword">if</span> (curDeadlineNanos == -<span class="hljs-number">1L</span>) &#123;<br>        curDeadlineNanos = NONE; <span class="hljs-comment">// nothing on the calendar</span><br>    &#125;<br>nextWakeupNanos.set(curDeadlineNanos);<br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">if</span> (!hasTasks()) &#123;<br>            <span class="hljs-comment">// 执行select方法</span><br>            strategy = select(curDeadlineNanos);<br>        &#125;<br>    &#125;<br>...<br></code></pre></td></tr></table></figure><p>会执行NioEvnetLoop的<code>select</code>方法，<strong>该方法内部会根据情况，执行selector的有参和无参的select方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">select</span><span class="hljs-params">(<span class="hljs-type">long</span> deadlineNanos)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-comment">// 如果没有指定阻塞事件，就调用select()</span><br>    <span class="hljs-keyword">if</span> (deadlineNanos == NONE) &#123;<br>        <span class="hljs-keyword">return</span> selector.select();<br>    &#125;<br>    <span class="hljs-comment">// 否则调用select(timeoutMillis)，指定时间内未发生事件就停止阻塞</span><br>    <span class="hljs-comment">// Timeout will only be 0 if deadline is within 5 microsecs</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">timeoutMillis</span> <span class="hljs-operator">=</span> deadlineToDelayNanos(deadlineNanos + <span class="hljs-number">995000L</span>) / <span class="hljs-number">1000000L</span>;<br>    <span class="hljs-keyword">return</span> timeoutMillis &lt;= <span class="hljs-number">0</span> ? selector.selectNow() : selector.select(timeoutMillis);<br>&#125;<br></code></pre></td></tr></table></figure><p>但需要注意的是，**<code>select</code>方法是会阻塞线程的，当没有IO事件，但有其他任务需要执行时，需要唤醒线程**</p><p>唤醒是通过execute最后的if代码块来完成的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 有任务需要被执行时，唤醒阻塞的NIO线程</span><br><span class="hljs-keyword">if</span> (!addTaskWakesUp &amp;&amp; immediate) &#123;<br>    wakeup(inEventLoop);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>NioEventLoop.wakeup</code>唤醒被selector.select方法阻塞的NIO线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wakeup</span><span class="hljs-params">(<span class="hljs-type">boolean</span> inEventLoop)</span> &#123;<br>    <span class="hljs-comment">// 只有当其他线程给当前NIO线程提交任务时（如执行execute），才会被唤醒</span><br>    <span class="hljs-comment">// 通过AtomicLong进行更新，保证每次只能有一个线程唤醒成功</span><br>    <span class="hljs-keyword">if</span> (!inEventLoop &amp;&amp; nextWakeupNanos.getAndSet(AWAKE) != AWAKE) &#123;<br>        <span class="hljs-comment">// 唤醒被selector.select方法阻塞的NIO线程</span><br>        selector.wakeup();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>唤醒时需要进行两个判断</p><ul><li><p>判断提交任务的</p><p>是否为NIO线程</p><ul><li>若是其他线程，才能唤醒NIO线程</li><li>若是NIO线程自己，则不能唤醒</li></ul></li><li><p>通过<strong>AtomicLong</strong>保证有多个线程同时提交任务时，只有一个线程能够唤醒NIO线程</p></li></ul><h4 id="SELECT分支"><a href="#SELECT分支" class="headerlink" title="SELECT分支"></a>SELECT分支</h4><p>run方法的switch语句有多条分支，具体执行分支的代码由strategy变量控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">int</span> <span class="hljs-variable">strategy</span> <span class="hljs-operator">=</span> selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());<br><span class="hljs-keyword">switch</span> (strategy) &#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>strategy的值由<code>calculateStrategy</code>方法确定</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">calculateStrategy</span><span class="hljs-params">(IntSupplier selectSupplier, <span class="hljs-keyword">boolean</span> hasTasks)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">// selectSupplier.get() 底层是 selector.selectNow();</span><br>    <span class="hljs-keyword">return</span> hasTasks ? selectSupplier.get() : SelectStrategy.SELECT;<br>&#125;该方法会根据hasTaks变量判断任务队列中是否有任务<br></code></pre></td></tr></table></figure><ul><li><p>若有任务，则<strong>通过selectSupplier获得strategy的值</strong></p><ul><li><p><strong>get方法会selectNow方法，顺便拿到IO事件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">IntSupplier</span> <span class="hljs-variable">selectNowSupplier</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntSupplier</span>() &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">get</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">return</span> NioEventLoop.<span class="hljs-built_in">this</span>.selectNow();<br>    &#125;<br>&#125;;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">selectNow</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.selector.selectNow();<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>若没有任务，就会进入SELECT分支</p></li></ul><p>也就说，<strong>当任务队列中没有任务时，才会进入SELECT分支，让NIO线程阻塞，而不是空转。若有任务，则会通过<code>get</code>方法调用<code>selector.selectNow</code>方法，顺便拿到IO事件</strong></p><h3 id="Java-NIO空轮询BUG"><a href="#Java-NIO空轮询BUG" class="headerlink" title="Java NIO空轮询BUG"></a>Java NIO空轮询BUG</h3><p>Java NIO空轮询BUG也就是JavaNIO在Linux系统下的epoll空轮询问题</p><p><strong>在NioEventLoop中，因为run方法中存在一个死循环，需要通过selector.select方法来阻塞线程。但是select方法因为BUG，可能无法阻塞线程，导致循环一直执行，使得CPU负载升高</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    ...<br>    <span class="hljs-keyword">for</span>(;;)&#123;<br>        ...<br>        <span class="hljs-comment">// 可能发生空轮询，无法阻塞NIO线程</span><br>        strategy = select(curDeadlineNanos);  <br>        ...     <br>    <br>     <span class="hljs-keyword">if</span>(...) &#123;<br>...<br>     &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unexpectedSelectorWakeup(selectCnt) )&#123;<br>            <span class="hljs-comment">// 通过unexpectedSelectorWakeup方法中的rebuildSelector重建selector</span><br>            <span class="hljs-comment">// 并将selectCnt重置为0</span><br>            selectCnt = <span class="hljs-number">0</span>;<br>        &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Netty中通过<code>selectCnt</code>变量来检测<code>select</code>方法是否发生空轮询BUG</strong></p><p>若发生空轮询BUG，那么selectCnt的值会<strong>增长是十分迅速</strong>。当<code>selectCnt</code>的值大于等于<code>SELECTOR_AUTO_REBUILD_THRESHOLD</code>（默认512）时，Netty则判断其出现了空轮询BUG，进行如下处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="hljs-number">0</span> &amp;&amp; selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;<br>    <span class="hljs-comment">// The selector returned prematurely many times in a row.</span><br>    <span class="hljs-comment">// Rebuild the selector to work around the problem.</span><br>    logger.warn(<span class="hljs-string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;</span>,selectCnt, selector);<br>    <span class="hljs-comment">// 重建selector，将原selector的配置信息传给新selector</span><br>    <span class="hljs-comment">// 再用新selector覆盖旧selector</span><br>    rebuildSelector();<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通过<code>rebuildSelector</code>方法重建selector，将原selector的配置信息传给新selector，再用新selector覆盖旧selector。同时将selectCnt的值设置为0</strong></p><h3 id="ioRatio"><a href="#ioRatio" class="headerlink" title="ioRatio"></a>ioRatio</h3><p>NioEventLoop可以处理IO事件和其他任务。不同的操作所耗费的时间是不同的，<strong>想要控制NioEventLoop处理IO事件花费时间占执行所有操作的总时间的比例，需要通过ioRatio来控制</strong></p><p><strong>NioEventLoop.run方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 处理IO事件时间比例，默认为50%</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ioRatio</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.ioRatio;<br><br><span class="hljs-comment">// 如果IO事件时间比例设置为100%</span><br><span class="hljs-keyword">if</span> (ioRatio == <span class="hljs-number">100</span>) &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 如果需要去处理IO事件</span><br>        <span class="hljs-keyword">if</span> (strategy &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 先处理IO事件</span><br>            processSelectedKeys();<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// Ensure we always run tasks.</span><br>        <span class="hljs-comment">// 剩下的时间都去处理普通任务和定时任务</span><br>        ranTasks = runAllTasks();<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strategy &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 如果需要去处理IO事件</span><br>    <span class="hljs-comment">// 记录处理IO事件前的时间</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ioStartTime</span> <span class="hljs-operator">=</span> System.nanoTime();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 去处理IO事件</span><br>        processSelectedKeys();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// Ensure we always run tasks.</span><br>        <span class="hljs-comment">// ioTime为处理IO事件耗费的事件</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ioTime</span> <span class="hljs-operator">=</span> System.nanoTime() - ioStartTime;<br>        <span class="hljs-comment">// 计算出处理其他任务的事件</span><br>        <span class="hljs-comment">// 超过设定的时间后，将会停止任务的执行，会在下一次循环中再继续执行</span><br>        ranTasks = runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);<br>    &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 没有IO事件需要处理</span><br>    <span class="hljs-comment">// This will run the minimum number of tasks</span><br>    <span class="hljs-comment">// 直接处理普通和定时任务</span><br>    ranTasks = runAllTasks(<span class="hljs-number">0</span>); <br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通过ioRatio控制各个任务执行的过程如下</strong></p><ul><li><p>判断ioRatio是否为100</p><ul><li><p>若是，判断是否需要处理IO事件（strategy&gt;0）</p><ul><li>若需要处理IO事件，则先处理IO事件</li></ul></li><li><p>若否（或IO事件已经处理完毕），<strong>接下来去执行所有的普通任务和定时任务，直到所有任务都被处理完</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 没有指定执行任务的时间</span><br>ranTasks = runAllTasks();<br></code></pre></td></tr></table></figure></li></ul></li></ul><p>若ioRatio不为100</p><ul><li><p>先去处理IO事件，<strong>记录处理IO事件所花费的事件保存在ioTime中</strong></p></li><li><p>接下来去处理其他任务，<strong>根据ioTime与ioRatio计算执行其他任务可用的时间</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 比如ioTime为10s，ioRatio为50</span><br><span class="hljs-comment">// 那么通过 10*(100-50)/50=10 计算出其他任务可用的时间为 10s</span><br><span class="hljs-comment">// 处理IO事件占用的事件总比例为50%</span><br>ranTasks = runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);<br></code></pre></td></tr></table></figure><ul><li>执行其他任务一旦超过可用时间，则会停止执行，在下一次循环中再继续执行</li></ul></li><li><p>若没有IO事件需要处理，则去执行<strong>最少数量</strong>的普通任务和定时任务</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 运行最少数量的任务<br><span class="hljs-attribute">ranTasks</span> <span class="hljs-operator">=</span> runAllTasks(<span class="hljs-number">0</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="处理事件"><a href="#处理事件" class="headerlink" title="处理事件"></a>处理事件</h3><p>IO事件是通过<code>NioEventLoop.processSelectedKeys()</code>方法处理的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processSelectedKeys</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 如果selectedKeys是基于数组的</span><br>    <span class="hljs-comment">// 一般情况下都走这个分支</span><br>    <span class="hljs-keyword">if</span> (selectedKeys != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 处理各种IO事件</span><br>        processSelectedKeysOptimized();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        processSelectedKeysPlain(selector.selectedKeys());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>processSelectedKeysOptimized方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processSelectedKeysOptimized</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; selectedKeys.size; ++i) &#123;<br>        <span class="hljs-comment">// 拿到SelectionKeyec</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">k</span> <span class="hljs-operator">=</span> selectedKeys.keys[i];<br>        <span class="hljs-comment">// null out entry in the array to allow to have it GC&#x27;ed once the Channel close</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/2363</span><br>        selectedKeys.keys[i] = <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">// 获取SelectionKey上的附件，即NioServerSocketChannel</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> k.attachment();<br><br>        <span class="hljs-keyword">if</span> (a <span class="hljs-keyword">instanceof</span> AbstractNioChannel) &#123;<br>            <span class="hljs-comment">// 处理事件，传入附件NioServerSocketChannel</span><br>            processSelectedKey(k, (AbstractNioChannel) a);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>            NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;<br>            processSelectedKey(k, task);<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (needsToSelectAgain) &#123;<br>            <span class="hljs-comment">// null out entries in the array to allow to have it GC&#x27;ed once the Channel close</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/2363</span><br>            selectedKeys.reset(i + <span class="hljs-number">1</span>);<br><br>            selectAgain();<br>            i = -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>&#96;&#96;</strong></p><p><strong><code>该方法中通过fori的方法，遍历基于数组的SelectedKey，通过</code></strong></p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">final SelectionKey k <span class="hljs-operator">=</span> selectedKeys.keys[i]<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>获取到SelectionKey，<strong>然后获取其再Register时添加的附件<code>NioServerSocketChannel</code></strong></p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 获取SelectionKey上的附件，即NioServerSocketChannel<br><br></code></pre></td></tr></table></figure><p>final Object a &#x3D; k.attachment();如果附件继承自AbstractNioChannel，则会调用</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 处理事件，传入附件NioServerSocketChannel</span><br>process<span class="hljs-constructor">SelectedKey(<span class="hljs-params">k</span>, (AbstractNioChannel)</span> a);<br></code></pre></td></tr></table></figure><p>去处理各个事件</p><p><strong>真正处理各种事件的方法<code>processSelectedKey</code></strong></p><p>获取SelectionKey的事件，然后进行相应处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processSelectedKey</span><span class="hljs-params">(SelectionKey k, AbstractNioChannel ch)</span> &#123;<br>    <span class="hljs-keyword">final</span> AbstractNioChannel.<span class="hljs-type">NioUnsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> ch.unsafe();<br>    <span class="hljs-keyword">if</span> (!k.isValid()) &#123;<br>        <span class="hljs-keyword">final</span> EventLoop eventLoop;<br>        <span class="hljs-keyword">try</span> &#123;<br>            eventLoop = ch.eventLoop();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable ignored) &#123;<br>            <span class="hljs-comment">// If the channel implementation throws an exception because there is no event loop, we ignore this</span><br>            <span class="hljs-comment">// because we are only trying to determine if ch is registered to this event loop and thus has authority</span><br>            <span class="hljs-comment">// to close ch.</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// Only close ch if ch is still registered to this EventLoop. ch could have deregistered from the event loop</span><br>        <span class="hljs-comment">// and thus the SelectionKey could be cancelled as part of the deregistration process, but the channel is</span><br>        <span class="hljs-comment">// still healthy and should not be closed.</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/5125</span><br>        <span class="hljs-keyword">if</span> (eventLoop == <span class="hljs-built_in">this</span>) &#123;<br>            <span class="hljs-comment">// close the channel if the key is not valid anymore</span><br>            unsafe.close(unsafe.voidPromise());<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">readyOps</span> <span class="hljs-operator">=</span> k.readyOps();<br>        <span class="hljs-comment">// We first need to call finishConnect() before try to trigger a read(...) or write(...) as otherwise</span><br>        <span class="hljs-comment">// the NIO JDK channel implementation may throw a NotYetConnectedException.</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// remove OP_CONNECT as otherwise Selector.select(..) will always return without blocking</span><br>            <span class="hljs-comment">// See https://github.com/netty/netty/issues/924</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">ops</span> <span class="hljs-operator">=</span> k.interestOps();<br>            ops &amp;= ~SelectionKey.OP_CONNECT;<br>            k.interestOps(ops);<br><br>            unsafe.finishConnect();<br>        &#125;<br><br>        <span class="hljs-comment">// Process OP_WRITE first as we may be able to write some queued buffers and so free memory.</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// Call forceFlush which will also take care of clear the OP_WRITE once there is nothing left to write</span><br>            ch.unsafe().forceFlush();<br>        &#125;<br><br>        <span class="hljs-comment">// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead</span><br>        <span class="hljs-comment">// to a spin loop</span><br>        <span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;<br>            unsafe.read();<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException ignored) &#123;<br>        unsafe.close(unsafe.voidPromise());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-Accept剖析"><a href="#3-Accept剖析" class="headerlink" title="3.Accept剖析"></a>3.Accept剖析</h2><h3 id="NIO中处理Accept事件流程"><a href="#NIO中处理Accept事件流程" class="headerlink" title="NIO中处理Accept事件流程"></a>NIO中处理Accept事件流程</h3><p>NIO中处理Accept事件主要有以下六步</p><ul><li><p>selector.select()阻塞线程，直到事件发生</p></li><li><p>遍历selectionKeys</p></li><li><p>获取一个key，判断事件类型是否为Accept</p></li><li><p>创建SocketChannel，设置为非阻塞</p></li><li><p>将SocketChannel注册到selector中</p></li><li><p>关注selectionKeys的read事件</p></li></ul><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 阻塞直到事件发生</span><br>selector.select();<br><br>Iterator&lt;SelectionKey&gt; iter = selector.selectionKeys().iterator();<br><span class="hljs-keyword">while</span> (iter.hasNext()) &#123;    <br>    <span class="hljs-comment">// 拿到一个事件</span><br>    <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();<br>    <br>    <span class="hljs-comment">// 如果是 accept 事件</span><br>    <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;<br>        <br>        <span class="hljs-comment">// 执行accept，获得SocketChannel</span><br>        <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> serverSocketChannel.accept();<br>        channel.configureBlocking(<span class="hljs-literal">false</span>);<br>        <br>        <span class="hljs-comment">// 将SocketChannel注册到selector中，并关注read事件</span><br>        channel.register(selector, SelectionKey.OP_READ);<br>    &#125;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>其中前三步，在NioEventLoop剖析中已经分析过了，所以接下来主要分析后三步</strong></p><h3 id="SocketChannel的创建与注册"><a href="#SocketChannel的创建与注册" class="headerlink" title="SocketChannel的创建与注册"></a>SocketChannel的创建与注册</h3><p>发生Accept事件后，会执行<code>NioEventLoop.run</code>方法的如下if分支</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;<br>unsafe.read();<br>&#125;<br></code></pre></td></tr></table></figure><p><code>NioMessageUnsafe.read</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br><br>    ...<br>    <br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">// doReadMessages中执行了accept获得了SocketChannel</span><br>                <span class="hljs-comment">// 并创建NioSocketChannel作为消息放入readBuf</span><br>                <span class="hljs-comment">// readBuf是一个ArrayList用来缓存消息</span><br>                <span class="hljs-comment">// private final List&lt;Object&gt; readBuf = new ArrayList&lt;Object&gt;();</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">localRead</span> <span class="hljs-operator">=</span> doReadMessages(readBuf);<br>                <br>                ...<br>                <br><span class="hljs-comment">// localRead值为1，就一条消息，即接收一个客户端连接</span><br>                allocHandle.incMessagesRead(localRead);<br>            &#125; <span class="hljs-keyword">while</span> (allocHandle.continueReading());<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            exception = t;<br>        &#125;<br><br>        <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> readBuf.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i ++) &#123;<br>            readPending = <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 触发read事件，让pipeline上的handler处理</span><br>            <span class="hljs-comment">// ServerBootstrapAcceptor.channelRead</span><br>            pipeline.fireChannelRead(readBuf.get(i));<br>        &#125;<br>        <br>        ...<br>        <br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;<br>            removeReadOp();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>NioSocketChannel.doReadMessages</code>方法</p><p>该方法中处理accpet事件，<strong>获得SocketChannel</strong>，同时<strong>创建了NioSocketChannel</strong>，作为消息放在了readBuf中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">doReadMessages</span><span class="hljs-params">(List&lt;Object&gt; buf)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// 处理accpet事件，获得SocketChannel</span><br>    <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">ch</span> <span class="hljs-operator">=</span> SocketUtils.accept(javaChannel());<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">if</span> (ch != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 创建了NioSocketChannel，作为消息放在了readBuf中</span><br>            buf.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioSocketChannel</span>(<span class="hljs-built_in">this</span>, ch));<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>       ...<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">ServerBootstrapAcceptor.channelRead<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> &#123;<br>    <span class="hljs-comment">// 这时的msg是NioSocketChannel</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> (Channel) msg;<br><br>    <span class="hljs-comment">// NioSocketChannel添加childHandler，即初始化器</span><br>    child.pipeline().addLast(childHandler);<br><br>    <span class="hljs-comment">// 设置选项</span><br>    setChannelOptions(child, childOptions, logger);<br><br>    <span class="hljs-keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;<br>        child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 注册 NioSocketChannel到nio worker线程，接下来的处理也移交至nio worker线程</span><br>        childGroup.register(child).addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-keyword">if</span> (!future.isSuccess()) &#123;<br>                    forceClose(child, future.cause());<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        forceClose(child, t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过<code>AbstractUnsafe.register</code> 方法，将SocketChannel注册到了Selector中，<strong>过程与启动流程中的Register过程类似</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> &#123;<br>    <br>    ...<br><br>    AbstractChannel.<span class="hljs-built_in">this</span>.eventLoop = eventLoop;<br><br>    <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;<br>        register0(promise);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 这行代码完成的是nio boss -&gt; nio worker线程的切换</span><br>            eventLoop.execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                    <span class="hljs-comment">// 真正的注册操作</span><br>                    register0(promise);<br>                &#125;<br>            &#125;);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">AbstractChannel.AbstractUnsafe.register0<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register0</span><span class="hljs-params">(ChannelPromise promise)</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <br>        ...<br>            <br>        <span class="hljs-comment">// 该方法将SocketChannel注册到Selector中</span><br>        doRegister();<br>        <br>        <span class="hljs-comment">// 执行初始化器，执行前 pipeline 中只有 head -&gt; 初始化器 -&gt; tail</span><br>        pipeline.invokeHandlerAddedIfNeeded();<br>        <span class="hljs-comment">// 执行后就是 head -&gt; logging handler -&gt; my handler -&gt; tail</span><br><br>        safeSetSuccess(promise);<br>        pipeline.fireChannelRegistered();<br>        <br>        <span class="hljs-keyword">if</span> (isActive()) &#123;<br>            <span class="hljs-keyword">if</span> (firstRegistration) &#123;<br>                <span class="hljs-comment">// 触发pipeline上active事件</span><br>                pipeline.fireChannelActive();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (config().isAutoRead()) &#123;<br>                beginRead();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        closeForcibly();<br>        closeFuture.setClosed();<br>        safeSetFailure(promise, t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>AbstractNioChannel.doRegister</code>将SocketChannel注册到Selector中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">selected</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 将Selector注册到Selector中</span><br>            selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-built_in">this</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;<br>            ...<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>AbstractNioChannel.doBeginRead</code>，通过该方法，SocketChannel关注了read事件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doBeginRead</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-comment">// Channel.read() or ChannelHandlerContext.read() was called</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">selectionKey</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.selectionKey;<br>    <span class="hljs-keyword">if</span> (!selectionKey.isValid()) &#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    readPending = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 这时候 interestOps是0</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">interestOps</span> <span class="hljs-operator">=</span> selectionKey.interestOps();<br>    <span class="hljs-keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 关注read事件</span><br>        selectionKey.interestOps(interestOps | readInterestOp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-Read剖析"><a href="#4-Read剖析" class="headerlink" title="4.Read剖析"></a>4.Read剖析</h2><p>read事件的处理也是在</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="hljs-number">0</span> || readyOps == <span class="hljs-number">0</span>) &#123;<br>unsafe.read();<br>&#125;<br></code></pre></td></tr></table></figure><p>分支中，通过<code>unsafe.read()</code>方法处理的，<strong>不过此处调用的方法在AbstractNioByteChannel.NioByteUnsafe类中</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 获得Channel的配置</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> config();<br>    <span class="hljs-keyword">if</span> (shouldBreakReadReady(config)) &#123;<br>        clearReadPending();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> pipeline();<br><span class="hljs-comment">// 根据配置创建ByteBufAllocator（池化非池化、直接非直接内存）</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">ByteBufAllocator</span> <span class="hljs-variable">allocator</span> <span class="hljs-operator">=</span> config.getAllocator();<br>    <span class="hljs-comment">// 用来分配 byteBuf，确定单次读取大小</span><br>    <span class="hljs-keyword">final</span> RecvByteBufAllocator.<span class="hljs-type">Handle</span> <span class="hljs-variable">allocHandle</span> <span class="hljs-operator">=</span> recvBufAllocHandle();<br>    allocHandle.reset(config);<br><br>    <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">close</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-comment">// 创建ByteBuf</span><br>            byteBuf = allocHandle.allocate(allocator);<br>            <span class="hljs-comment">// 读取内容，放入ByteBUf中</span><br>            allocHandle.lastBytesRead(doReadBytes(byteBuf));<br>            <span class="hljs-keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="hljs-number">0</span>) &#123;<br>                byteBuf.release();<br>                byteBuf = <span class="hljs-literal">null</span>;<br>                close = allocHandle.lastBytesRead() &lt; <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (close) &#123;<br>                    readPending = <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            allocHandle.incMessagesRead(<span class="hljs-number">1</span>);<br>            readPending = <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 触发read 事件，让pipeline上的handler处理</span><br>            <span class="hljs-comment">// 这时是处理NioSocketChannel上的handler</span><br>            pipeline.fireChannelRead(byteBuf);<br>            byteBuf = <span class="hljs-literal">null</span>;<br>        &#125; <br>        <span class="hljs-comment">// 是否要继续循环</span><br>        <span class="hljs-keyword">while</span> (allocHandle.continueReading());<br><br>        allocHandle.readComplete();<br>        <span class="hljs-comment">// 触发 read complete事件</span><br>        pipeline.fireChannelReadComplete();<br><br>        <span class="hljs-keyword">if</span> (close) &#123;<br>            closeOnRead(pipeline);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        handleReadException(pipeline, byteBuf, t, close, allocHandle);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>         <span class="hljs-comment">// Check if there is a readPending which was not processed yet.</span><br>         <span class="hljs-comment">// This could be for two reasons:</span><br>         <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span><br>         <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span><br>         <span class="hljs-comment">//</span><br>         <span class="hljs-comment">// See https://github.com/netty/netty/issues/2254</span><br>        <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;<br>            removeReadOp();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>DefaultMaxMessagesRecvByteBufAllocator.MaxMessageHandle.continueReading(io.netty.util.UncheckedBooleanSupplier)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">continueReading</span><span class="hljs-params">(UncheckedBooleanSupplier maybeMoreDataSupplier)</span> &#123;<br>    <span class="hljs-keyword">return</span> <br>           <span class="hljs-comment">// 一般为true</span><br>           config.isAutoRead() &amp;&amp;<br>           <span class="hljs-comment">// respectMaybeMoreData默认为true</span><br>           <span class="hljs-comment">// maybeMoreDataSupplier的逻辑是如果预期读取字节与实际读取字节相等，返回true</span><br>           (!respectMaybeMoreData || maybeMoreDataSupplier.get()) &amp;&amp;<br>           <span class="hljs-comment">// 小于最大次数，maxMessagePerRead默认16</span><br>           totalMessages &lt; maxMessagePerRead &amp;&amp;<br>           <span class="hljs-comment">// 实际读到了数据</span><br>           totalBytesRead &gt; <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>参考：</p><p>https:&#x2F;&#x2F;<span></span>www.<span></span>bilibili.com&#x2F;video&#x2F;BV1py4y1E7oA<br>https:&#x2F;&#x2F;<span></span>nyimac.gitee.io&#x2F;2021&#x2F;04&#x2F;25&#x2F;Netty%E5%9F%BA%E7%A1%80&#x2F;</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>分布式</category>
      
      <category>组件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高性能</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper</title>
    <link href="/3089741418/"/>
    <url>/3089741418/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>分布式</category>
      
      <category>组件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Redis的应用方案</title>
    <link href="/2929358551/"/>
    <url>/2929358551/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高性能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL的分布式方案</title>
    <link href="/4039200879/"/>
    <url>/4039200879/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cannl</title>
    <link href="/1712973718/"/>
    <url>/1712973718/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高性能</tag>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>线程池</title>
    <link href="/3732689918/"/>
    <url>/3732689918/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>并发工具</title>
    <link href="/2647378141/"/>
    <url>/2647378141/</url>
    
    <content type="html"><![CDATA[<h1 id="锁基础"><a href="#锁基础" class="headerlink" title="锁基础"></a>锁基础</h1><h1 id="并发工具"><a href="#并发工具" class="headerlink" title="并发工具"></a>并发工具</h1>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
      <category>JUC</category>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>IO总结</title>
    <link href="/2076844110/"/>
    <url>/2076844110/</url>
    
    <content type="html"><![CDATA[<h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>IO是Input&#x2F;Output的缩写，指的是输入和输出操作。在计算机中，IO通常与外部设备进行交互，包括硬盘、网络、键盘、鼠标、打印机等。计算机通过IO操作来读取外部设备中的数据，或者将计算机中的数据写入到外部设备中。IO操作通常是计算机程序中最耗时的操作之一，因为与计算相比，IO操作需要等待外部设备的响应和数据的传输，这会导致程序的性能瓶颈。为了提高程序的性能，通常采用异步IO、多线程、缓存等技术来优化IO操作。</p><p>IO模型指的是计算机在进行输入输出操作时所采用的方式或者策略，在Unix中， IO 模型一共有 5 种：<strong>同步阻塞 I&#x2F;O</strong>、<strong>同步非阻塞 I&#x2F;O</strong>、<strong>I&#x2F;O 多路复用</strong>、<strong>信号驱动 I&#x2F;O</strong> 和<strong>异步 I&#x2F;O</strong>。</p><h2 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h2><h3 id="同步与阻塞"><a href="#同步与阻塞" class="headerlink" title="同步与阻塞"></a>同步与阻塞</h3><ul><li><strong>同步（Synchronous）</strong>：同步指的是程序进行输入输出操作时，需要等待操作完成并返回结果后才能继续进行其他操作。即线程自己去获取结果（<code>一个线程</code>）。</li><li><strong>异步（Asynchronous）</strong>：异步指的是程序进行输入输出操作时，不需要等待操作完成并返回结果就能继续进行其他操作。线程自己不去获取结果，而是由其它线程返回结果（<code>至少两个线程</code>）。</li><li><strong>阻塞（Blocking）</strong>：阻塞指的是程序进行输入输出操作时，需要等待操作完成并返回结果后才能继续进行其他操作。</li><li><strong>非阻塞（No-Blocking）</strong>:非阻塞指的是程序进行输入输出操作时，不需要等待操作完成并返回结果就能继续进行其他操作。</li></ul><h3 id="内核态与用户态"><a href="#内核态与用户态" class="headerlink" title="内核态与用户态"></a>内核态与用户态</h3><ul><li>内核态：内核态是操作系统运行的一种特权级别，也称为特权模式。在内核态下，<strong>操作系统拥有对计算机硬件的完全控制权</strong>，可以执行所有指令，访问所有的内存地址和硬件资源，包括对CPU、内存、I&#x2F;O设备等的控制和管理。内核态下的程序可以执行特权指令，访问受保护的资源，并且可以直接调用系统调用接口，进行操作系统相关的功能调用。</li><li>用户态：用户态是操作系统运行的另一种特权级别，也称为非特权模式。在用户态下，<strong>程序只能访问受操作系统所限制的资源</strong>，不能直接访问受保护的硬件资源，包括CPU、内存、I&#x2F;O设备等。用户态下的程序不能执行特权指令，也不能直接调用系统调用接口，只能通过操作系统提供的API进行操作系统相关的功能调用。</li></ul><p>在操作系统中，用户态和内核态之间的切换是通过系统调用（syscalls）、中断（interrupts）、异常（exceptions）等机制实现的。当程序需要访问受保护的资源或进行操作系统相关的功能调用时，就需要从用户态切换到内核态，这需要通过硬件的支持来实现。在内核态下完成相关操作后，程序会再次切换到用户态，继续执行自己的任务。</p><p>IO操作会涉及到<strong>用户空间</strong>和<strong>内核空间</strong>的转换，先来理解以下规则：</p><ul><li><p>内存空间分为用户空间和内核空间，也称为用户缓冲区和内核缓存区</p></li><li><p>用户的应用程序不能直接操作内核空间，需要将数据从内核空间拷贝到用户空间才能使用；</p></li><li><p>无论是read操作，还是write操作，都只能在内核空间里执行；</p></li><li><p>磁盘IO和网络IO请求加载到内存的数据都是先放在内核空间的；</p></li></ul><h3 id="读写操作"><a href="#读写操作" class="headerlink" title="读写操作"></a>读写操作</h3><p><strong>读操作</strong>：操作系统检查内核缓冲区有没有需要的数据，如果内核缓冲区已经有需要的数据了，那么就直接把内核空间的数据copy到用户空间，供用户的应用程序使用。</p><p>如果内核缓冲区没有需要的数据，对于磁盘IO，直接从磁盘中读取到内核缓冲区（这个过程可以不需要cpu参与）。而对于网络IO，应用程序需要等待客户端发送数据，如果客户端还没有发送数据，对应的应用程序将会被阻塞，直到客户端发送了数据，该应用程序才会被唤醒，从Socket协议找中读取客户端发送的数据到内核空间，然后把内核空间的数据copy到用户空间，供应用程序使用。</p><p><strong>写操作</strong>：用户的应用程序将数据从用户空间copy到内核空间的缓冲区中（如果用户空间没有相应的数据，则需要从磁盘—&gt;内核缓冲区—&gt;用户缓冲区依次读取），这时对用户程序来说写操作就已经完成，至于什么时候再写到磁盘或通过网络发送出去，由操作系统决定。除非应用程序显示地调用了sync 命令，立即把数据写入磁盘，或执行flush()方法，通过网络把数据发送出去。</p><p>绝大多数磁盘IO和网络IO的读写操作都是上述过程，除了后面要讲到的零拷贝IO。</p><h3 id="IO调用之后"><a href="#IO调用之后" class="headerlink" title="IO调用之后"></a>IO调用之后</h3><p>当应用程序发起 I&#x2F;O 调用后，会由用户态切换至操作系统内核态来完成真正数据读取，而读取又分为两个阶段，分别为：</p><ul><li>等待数据阶段</li><li>复制数据阶段</li></ul><p><img src="https://s2.loli.net/2023/04/16/bXzcVErkg5MSWvN.png"></p><h2 id="IO模型-1"><a href="#IO模型-1" class="headerlink" title="IO模型"></a>IO模型</h2><h3 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h3><p><img src="https://s2.loli.net/2023/04/16/MfEY5pNle6PdKHB.png"></p><p>同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到内核把数据拷贝到用户空间。</p><h3 id="同步非阻塞IO"><a href="#同步非阻塞IO" class="headerlink" title="同步非阻塞IO"></a>同步非阻塞IO</h3><p><img src="https://s2.loli.net/2023/04/16/5fiGv4RmAbkO1Mn.png"></p><ul><li><p>用户线程在一个循环中一直调用read方法，若内核空间中还没有数据可读，立即返回。</p><p><code>只是在等待阶段非阻塞</code></p></li><li><p>用户线程发现内核空间中有数据后，等待内核空间执行复制数据，待复制结束后返回结果</p></li></ul><p>相比于同步阻塞 IO 模型，同步非阻塞 IO 模型确实有了很大改进。通过轮询操作，避免了一直阻塞。但是，这种 IO 模型同样存在问题：<strong>应用程序不断进行 I&#x2F;O 系统调用轮询数据是否已经准备好的过程是十分消耗 CPU 资源的。</strong></p><p>通过<a href="#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8">IO多路</a>复用来解决这个问题</p><h3 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h3><p>IO多路复用技术是指一种同时监控多个IO流的技术，主要用于提高程序处理多个IO流的效率。IO多路复用技术通过将多个IO流注册到同一个事件轮询器上，等待事件的发生，从而避免了程序在等待IO操作完成时阻塞，提高了程序的效率。</p><p>引入了IO多路复用模型:利用单个线程来同时监听多个FD,并在某个FD可读、可写时得到通知,从而避免无效的等待，充分利用CPU资源。</p><blockquote><p>文件描述符( File Descriptor) :简称FD,是一个从0开始递增的无符号整数，用来关联Linux中的一一个文件。</p></blockquote><p>常用的IO多路复用技术包括<code>select、poll和epoll</code>，我们来看看他们的优缺点。</p><h4 id="Select"><a href="#Select" class="headerlink" title="Select"></a>Select</h4><p>select 是操作系统提供的系统调用函数，通过它，我们可以把一个文件描述符的数组发给操作系统， 让操作系统去遍历，确定哪个文件描述符可以读写，然后告诉我们去处理</p><blockquote><p>select是Linux中最早的I&#x2F;O多路复用实现方案，并且windows操作系统上只支持select。这就是为啥window发挥不出redis的最大性能的一个原因。</p></blockquote><p><img src="https://s2.loli.net/2023/04/18/b2V3ctwxGyH1agi.gif"></p><p>可以看出几个细节：</p><ul><li><p>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p></li><li><p>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知)</p></li><li><p>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p></li></ul><p>整体流程如下：</p><img src="https://s2.loli.net/2023/04/18/eUWj8SlLVNuxfDT.jpg" style="zoom:50%;" /><p>这种方式，既做到了一个线程处理多个客户端连接（文件描述符），又减少了系统调用的开销（多个文件描述符只有一次 select 的系统调用 + n 次就绪状态的文件描述符的 read 系统调用）。</p><p><strong>多路复用与阻塞IO的区别</strong></p><ul><li>阻塞IO模式下，<strong>若线程因accept事件被阻塞，发生read事件后，仍需等待accept事件执行完成后</strong>，才能去处理read事件</li><li>多路复用模式下，一个事件发生后，若另一个事件处于阻塞状态，不会影响该事件的执行（复用器是通过轮询或事件驱动的方式来处理多个文件描述符上的I&#x2F;O事件）</li></ul><h4 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h4><p>poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的</p><p>与select对比</p><ul><li>select模式中的fd_ set大小固定为1024,而pollfd在内核中采用链表，理论上无上限</li><li>监听FD越多，每次遍历消耗时间也越久，性能反而会下降</li></ul><h4 id="epoll"><a href="#epoll" class="headerlink" title="epoll"></a>epoll</h4><p>优化上面说的 select 的三个细节</p><ul><li><p>select 调用需要传入 fd 数组，需要拷贝一份到内核，高并发场景下这样的拷贝消耗的资源是惊人的。（可优化为不复制）</p></li><li><p>select 在内核层仍然是通过遍历的方式检查文件描述符的就绪状态，是个同步过程，只不过无系统调用切换上下文的开销。（内核层可优化为异步事件通知）</p></li><li><p>select 仅仅返回可读文件描述符的个数，具体哪个可读还是要用户自己遍历。（可优化为只返回给用户就绪的文件描述符，无需用户做无效的遍历）</p></li></ul><p>所以 epoll 主要就是针对这三点进行了改进。</p><ul><li><p>内核中保存一份文件描述符集合，无需用户每次都重新传入，只需告诉内核修改的部分即可。</p></li><li><p>内核不再通过轮询的方式找到就绪的文件描述符，而是通过异步 IO 事件唤醒。</p></li><li><p>内核仅会将有 IO 事件的文件描述符返回给用户，用户也无需遍历整个文件描述符集合。</p></li></ul><p>内部原理如下所示：</p><p><img src="https://s2.loli.net/2023/04/18/vnzNEuLX28hltby.gif"></p><h3 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h3><p><img src="https://s2.loli.net/2023/04/16/iHqEcaOjJFYMRIm.png"></p><ul><li>线程1调用方法后理解返回，<strong>不会被阻塞也不需要立即获取结果</strong></li><li>当方法的运行结果出来以后，由线程2将结果返回给线程1</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>一切的开始，都起源于这个 read 函数是操作系统提供的，而且是阻塞的，我们叫它 <strong>阻塞 IO</strong>。</p><p>为了破这个局，程序员在用户态通过多线程来防止主线程卡死。</p><p>后来操作系统发现这个需求比较大，于是在操作系统层面提供了非阻塞的 read 函数，这样程序员就可以在一个线程内完成多个文件描述符的读取，这就是 <strong>非阻塞 IO</strong>。</p><p>但多个文件描述符的读取就需要遍历，当高并发场景越来越多时，用户态遍历的文件描述符也越来越多，相当于在 while 循环里进行了越来越多的系统调用。</p><p>后来操作系统又发现这个场景需求量较大，于是又在操作系统层面提供了这样的遍历文件描述符的机制，这就是 <strong>IO 多路复用</strong>。</p><p>多路复用有三个函数，最开始是 select，然后又发明了 poll 解决了 select 文件描述符的限制，然后又发明了 epoll 解决 select 的三个不足。多路复用就是一个<code>批量执行</code>的思想</p><h1 id="IO多路复用-1"><a href="#IO多路复用-1" class="headerlink" title="IO多路复用"></a>IO多路复用</h1><h2 id="Redis的IO多路复用"><a href="#Redis的IO多路复用" class="headerlink" title="Redis的IO多路复用"></a>Redis的IO多路复用</h2><p>Redis 服务器是一个事件驱动程序， 服务器处理的事件分为时间事件和文件事件两类。</p><ul><li><strong>文件事件</strong>：Redis主进程中，主要处理客户端的连接请求与相应。</li><li><strong>时间事件</strong>：fork出的子进程中，处理如 AOF 持久化任务等。</li></ul><p>由于Redis的文件事件是单进程，单线程模型，但是确保持着优秀的吞吐量，IO多路复用起到了主要作用。</p><p><img src="https://www.freesion.com/images/960/4b67aecab5f402b50abee78400cfdaa0.png"></p><p>Redis把所有连接与读写事件、还有我们没提到的时间事件一起集中管理，并对底层IO多路复用机制进行了封装，最终实现了单进程能够处理多个连接以及读写事件。这就是IO多路复用在 redis 中的应用。</p><h3 id="为什么引入多线程？"><a href="#为什么引入多线程？" class="headerlink" title="为什么引入多线程？"></a>为什么引入多线程？</h3><p>redis 执行命令是用的单线程，然后其他的功能有用到多进程和多线程。像 RDB 持久化用了子进程，unlink的异步删除用到了多线程，还有6.0之后为了增加IO的速度，把IO的读写和命令的解析也都交给多线程了。</p><p>Redis 选择使用单线程模型处理客户端的请求主要还是因为 CPU 不是 Redis 服务器的瓶颈，使用多线程模型带来的性能提升并不能抵消它带来的开发成本和维护成本，系统的性能瓶颈也主要在网络 I&#x2F;O 操作上；而 Redis 引入多线程操作也是出于性能上的考虑，对于一些大键值对的删除操作，通过多线程非阻塞地释放内存空间也能减少对 Redis 主线程阻塞的时间，提高执行的效率。</p><p>需要注意的是，Redis 6.0 的多线程模型并不是完全的并行处理，而是采用了协程的方式，即在单个线程中运行多个协程，在协程之间切换执行，以此来提高并发性能。</p><h2 id="JavaNIO"><a href="#JavaNIO" class="headerlink" title="JavaNIO"></a>JavaNIO</h2><p>Java 中的 NIO ，有一个非常重要的<strong>选择器 ( Selector )</strong> 的概念，也可以被称为 <strong>多路复用器</strong>。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。</p><ul><li>当没有事件是，调用select方法会被阻塞住</li><li>一旦有一个或多个事件发生后，就会处理对应的事件，从而实现多路复用</li></ul><p><img src="https://s2.loli.net/2023/04/18/vEweBxJpm58csHL.png"></p><h2 id="Netty的IO多路复用"><a href="#Netty的IO多路复用" class="headerlink" title="Netty的IO多路复用"></a>Netty的IO多路复用</h2><p>在Netty中IO多路复用实现依赖于Reactor线程模型</p><p><img src="https://s2.loli.net/2023/04/18/gdpJ5Ra8OQ6scwI.png"></p><ul><li><strong>单线程 Reactor</strong> 的优点是对系统资源消耗特别小，但是，没办法支撑大量请求的应用场景并且处理请求的时间可能非常慢，毕竟只有一个线程在工作嘛！所以，一般实际项目中不会使用单线程 Reactor 。</li><li><strong>多线程 Reactor</strong> 一个线程负责接受请求,一组 NIO 线程处理 IO 操作，大部分场景下多线程 Reactor 模型是没有问题的，但是在一些并发连接数比较多（如百万并发）的场景下，一个线程负责接受客户端请求就存在性能问题了。</li><li><strong>主从多线程 Reactor</strong> 一组 NIO 线程<code>EventLoop boos</code>负责接受请求，多组 NIO 线程<code>Event workers</code>处理 IO 操作。</li></ul><blockquote><p>参考:</p><p>https:<span></span>&#x2F;&#x2F;www.<span></span>zhihu.com&#x2F;question&#x2F;59975081</p><p>https:<span></span>&#x2F;&#x2F;javaguide.cn&#x2F;java&#x2F;io&#x2F;io-model.html#nio-non-blocking-new-i-o</p><p>https:<span></span>&#x2F;&#x2F;www.<span></span>yuque.com&#x2F;snab&#x2F;java&#x2F;oyni7r#tTiHP</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
      <category>IO</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java容器</title>
    <link href="/1488394154/"/>
    <url>/1488394154/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM调优</title>
    <link href="/374569311/"/>
    <url>/374569311/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高性能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis的分布式方案</title>
    <link href="/1876276682/"/>
    <url>/1876276682/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高并发</tag>
      
      <tag>高可用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编程思想</title>
    <link href="/2724880937/"/>
    <url>/2724880937/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式总结</title>
    <link href="/3045125929/"/>
    <url>/3045125929/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>其他</category>
      
    </categories>
    
    
    <tags>
      
      <tag>理论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式特性总结</title>
    <link href="/3362007385/"/>
    <url>/3362007385/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>分布式</category>
      
      <category>特性</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高并发</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo</title>
    <link href="/4129633176/"/>
    <url>/4129633176/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>分布式</category>
      
      <category>组件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>SSM架构总结</title>
    <link href="/816871270/"/>
    <url>/816871270/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础</title>
    <link href="/4159564061/"/>
    <url>/4159564061/</url>
    
    <content type="html"><![CDATA[<h1 id="基础概念与常识"><a href="#基础概念与常识" class="headerlink" title="基础概念与常识"></a>基础概念与常识</h1><h2 id="JAVA语言特点"><a href="#JAVA语言特点" class="headerlink" title="JAVA语言特点"></a>JAVA语言特点</h2><ul><li><p>简单易学；</p></li><li><p>面向对象（封装，继承，多态）；</p></li><li><p>平台无关性（ Java 虚拟机实现平台无关性）；</p></li><li><p>支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；</p></li><li><p>可靠性；</p></li><li><p>安全性；</p></li><li><p>支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；</p></li><li><p>编译与解释并存；</p></li></ul><blockquote><p>Write Once, Run Anywhere（一次编写，随处运行）这句宣传口号，真心经典，流传了好多年！以至于，直到今天，依然有很多人觉得跨平台是 Java 语言最大的优势。现在来说，比起跨平台JAVA的生态才是最强大的</p></blockquote><h2 id="JVM-vs-JDK-vs-JRE"><a href="#JVM-vs-JDK-vs-JRE" class="headerlink" title="JVM vs JDK vs JRE"></a>JVM vs JDK vs JRE</h2><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。<strong>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong> </p><p>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p><p>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。</p><h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>在JAVA中，JVM能理解的代码就是字节码，即扩展名为 <code>.class</code> 的文件。</p><p>JAVA程序从源代码到运行的过程如下：</p><img src="https://s2.loli.net/2023/04/18/xQVHeTf75pLyAli.png" alt="image-20230418171049115" style="zoom:50%;" /><p><code>.class-&gt;机器码</code> 这一步。在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。这也是说 <strong>Java 是编译与解释共存的语言</strong> 的原因</p><blockquote><p>HotSpot 采用了惰性评估(Lazy Evaluation)的做法，根据二八定律，消耗大部分系统资源的只有那一小部分的代码（热点代码），而这也就是 JIT 所需要编译的部分。JVM 会根据代码每次被执行的情况收集信息并相应地做出一些优化，因此执行的次数越多，它的速度就越快</p></blockquote><h2 id="JAVA与C-的区别"><a href="#JAVA与C-的区别" class="headerlink" title="JAVA与C++的区别"></a>JAVA与C++的区别</h2><ul><li><p>Java 不提供指针来直接访问内存，程序内存更加安全</p></li><li><p>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</p></li><li><p>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</p></li><li><p>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。</p></li></ul><p>…..</p><h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="标识符和关键字"><a href="#标识符和关键字" class="headerlink" title="标识符和关键字"></a>标识符和关键字</h3><p>为程序、类、变量、方法等取名字，于是就有了 <strong>标识符</strong> 。简单来说， <strong>标识符就是一个名字</strong> 。有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这些特殊的标识符就是 <strong>关键字</strong> 。简单来说，<strong>关键字是被赋予特殊含义的标识</strong>符 。</p><p><img src="https://s2.loli.net/2023/04/18/My4cERBgNStY79w.png"></p><blockquote><p><code>default</code> 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。</p><ul><li>在程序控制中，当在 <code>switch</code> 中匹配不到任何情况时，可以使用 <code>default</code> 来编写默认匹配的情况。</li><li>在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 <code>default</code> 关键字来定义一个方法的默认实现。</li><li>在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 <code>default</code>，但是这个修饰符加上了就会报错。</li></ul></blockquote><div class="note note-warning">            <p>注意 ：虽然 <code>true</code>, <code>false</code>, 和 <code>null</code> 看起来像关键字但实际上他们是字面值，同时你也不可以作为标识符来使用。</p>          </div><h3 id="自增自减运算符"><a href="#自增自减运算符" class="headerlink" title="自增自减运算符"></a>自增自减运算符</h3><p>在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（–）。</p><blockquote><p>++ 和 – 运算符可以放在变量之前，也可以放在变量之后，当运算符放在变量之前时(前缀)，先自增&#x2F;减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增&#x2F;减。<code>符号在前就先加/减，符号在后就后加/减</code></p></blockquote><h3 id="位移运算符"><a href="#位移运算符" class="headerlink" title="位移运算符"></a>位移运算符</h3><p>移位运算符是最基本的运算符之一，几乎每种编程语言都包含这一运算符。移位操作中，被操作的数据被视为二进制数，移位就是将其向左或向右移动若干位的运算。</p><p>Java 中有三种移位运算符：</p><ul><li><code>&lt;&lt;</code> :左移运算符，向左移若干位，高位丢弃，低位补零。<code>x &lt;&lt; 1</code>,相当于 x 乘以 2(不溢出的情况下)。</li><li><code>&gt;&gt;</code> :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。<code>x &gt;&gt; 1</code>,相当于 x 除以 2。</li><li><code>&gt;&gt;&gt;</code> :无符号右移，忽略符号位，空位都以 0 补齐。</li></ul><p>由于 <code>double</code>，<code>float</code> 在二进制中的表现比较特殊，因此不能来进行移位操作。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><blockquote><p>代码就是最好的注释，<strong>我们要尽量规范和美化自己的代码来减少不必要的注释。若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述。</strong></p></blockquote><p>Java 中的注释有三种：</p><ol><li><strong>单行注释</strong> ：通常用于解释方法内某单行代码的作用。</li><li><strong>多行注释</strong> ：通常用于解释一段代码的作用。</li><li><strong>文档注释</strong> ：通常用于生成 Java 开发文档</li></ol><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li><strong>语法形式</strong> ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 <code>public</code>,<code>private</code>,<code>static</code> 等修饰符所修饰，而局部变量不能被访问控制修饰符及 <code>static</code> 所修饰；但是，成员变量和局部变量都能被 <code>final</code> 所修饰。</li><li><strong>存储方式</strong> ：从变量在内存中的存储方式来看,如果成员变量是使用 <code>static</code> 修饰的，那么这个成员变量是属于类的，如果没有使用 <code>static</code> 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li><li><strong>生存时间</strong> ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。</li><li><strong>默认值</strong> ：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 <code>final</code> 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。</li></ul><blockquote><p>静态变量的作用：静态变量可以被类的所有实例共享。无论一个类创建了多少个对象，它们都共享同一份静态变量。</p><p>通常情况下，静态变量会被 <code>final</code> 关键字修饰成为常量。</p></blockquote><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="静态方法和实例方法区别"><a href="#静态方法和实例方法区别" class="headerlink" title="静态方法和实例方法区别"></a>静态方法和实例方法区别</h4><ul><li>调用方式不一样，静态方法调用<code>类名.方法</code>，实例方法调用：<code>实例名.方法</code>；</li><li>静态方法访问类成员存在限制，只能访问静态成员变量。</li></ul><p><strong>重载与重写的区别</strong></p><ul><li>重载：重载就是同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</li><li>重写：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></li></ul><p>重写遵循“2同2大1小”：</p><ul><li><p>“两同”即方法名相同、形参列表相同；</p></li><li><p>“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</p></li><li><p>“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</p></li></ul><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>Java 中有 8 种基本数据类型，分别为：</p><ul><li>6 种数字类型： <ul><li>4 种整数型：<code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code></li><li>2 种浮点型：<code>float</code>、<code>double</code></li></ul></li><li>1 种字符类型：<code>char</code></li><li>1 种布尔型：<code>boolean</code></li></ul><p>这 8 种基本数据类型的默认值以及所占空间的大小如下：</p><img src="https://s2.loli.net/2023/04/18/JbKRUt4YCFSg2Zx.png" style="zoom:50%;" /><p>这八种基本类型都有对应的包装类分别为：<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Float</code>、<code>Double</code>、<code>Character</code>、<code>Boolean</code> </p><h3 id="基本类型和包装类型的区别？"><a href="#基本类型和包装类型的区别？" class="headerlink" title="基本类型和包装类型的区别？"></a>基本类型和包装类型的区别？</h3><ul><li>成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li>包装类型可用于泛型，而基本类型不可以。</li><li>基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li><li>相比于对象类型， 基本数据类型占用的空间非常小。</li></ul><h3 id="包装类型的缓存机制"><a href="#包装类型的缓存机制" class="headerlink" title="包装类型的缓存机制"></a>包装类型的缓存机制</h3><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><div class="note note-success">            <p><strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p>          </div><img src="https://oscimg.oschina.net/oscnet/up-1ae0425ce8646adfb768b5374951eeb820d.png" style="zoom:50%;" /><h3 id="自动拆箱与装箱"><a href="#自动拆箱与装箱" class="headerlink" title="自动拆箱与装箱"></a><strong>自动拆箱与装箱</strong></h3><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><p>装箱其实就是调用了 包装类的<code>valueOf()</code>方法，拆箱其实就是调用了 <code>xxxValue()</code>方法</p><div class="note note-warning">            <p>注意：<strong>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</strong></p>          </div><h3 id="浮点数运算"><a href="#浮点数运算" class="headerlink" title="浮点数运算"></a>浮点数运算</h3><p><strong>浮点数运算会有丢失精度的风险</strong>：这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。</p><p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的</p><h3 id="超过-long-整型的数据"><a href="#超过-long-整型的数据" class="headerlink" title="超过 long 整型的数据"></a>超过 long 整型的数据</h3><p>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。</p><p>在 Java 中，64 位 long 整型是最大的整数类型。</p><p><code>BigInteger</code> 内部使用 <code>int[]</code> 数组来存储任意大小的整形数据。</p><p>相对于常规整数类型的运算来说，<code>BigInteger</code> 运算的效率会相对较低。</p><h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><p>两者的主要区别在于解决问题的方式不同：</p><ul><li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><p>另外，面向对象开发的程序一般更易维护、易复用、易扩展。</p><h3 id="创建一个对象用什么运算符-对象实体与对象引用有何不同"><a href="#创建一个对象用什么运算符-对象实体与对象引用有何不同" class="headerlink" title="创建一个对象用什么运算符?对象实体与对象引用有何不同?"></a>创建一个对象用什么运算符?对象实体与对象引用有何不同?</h3><p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p><p>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p><h3 id="对象的相等和引用相等的区别"><a href="#对象的相等和引用相等的区别" class="headerlink" title="对象的相等和引用相等的区别"></a>对象的相等和引用相等的区别</h3><ul><li>对象的相等一般比较的是内存中存放的内容是否相等。</li><li>引用相等一般比较的是他们指向的内存地址是否相等。</li></ul><h3 id="类的构造方法的作用是什么"><a href="#类的构造方法的作用是什么" class="headerlink" title="类的构造方法的作用是什么?"></a>类的构造方法的作用是什么?</h3><p>构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。</p><h3 id="构造方法有哪些特点？是否可被-override"><a href="#构造方法有哪些特点？是否可被-override" class="headerlink" title="构造方法有哪些特点？是否可被 override?"></a>构造方法有哪些特点？是否可被 override?</h3><p>构造方法特点如下：</p><ul><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ul><p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况</p><h3 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h3><ul><li><p><strong>封装</strong>：是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。</p></li><li><p><strong>继承</strong>：继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能</p><ul><li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ul></li><li><p><strong>多态</strong>：表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p><p>多态的特点：</p><ul><li>对象类型和引用类型之间具有继承（类）&#x2F;实现（接口）的关系；</li><li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；</li><li>多态不能调用“只在子类存在但在父类不存在”的方法；</li><li>如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li></ul></li></ul><h3 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h3><p><strong>共同点</strong> ：</p><ul><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li></ul><p><strong>区别</strong> ：</p><ul><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口中的成员变量只能是 <code>public static final</code> 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li></ul><h3 id="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h3><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li><li><strong>引用拷贝</strong>：简单来说，引用拷贝就是两个不同的引用指向同一个对象。</li></ul><img src="https://s2.loli.net/2023/04/18/7dvcbZu8XkmzKHt.png" style="zoom:50%;" /><p>除了Clone()，还能实现对象深拷贝的方法有：</p><ul><li>使用序列化和反序列化：将对象序列化为字节流，然后再反序列化为新的对象。这种方法需要确保对象及其成员变量都是可序列化的。</li><li>使用第三方库：例如 Apache Commons 和 Google Guava 等第三方库提供了一些实用工具来帮助实现深拷贝。</li><li>手动实现深拷贝：手动复制对象及其成员变量。这种方法需要手动遍历对象图并复制每个对象的属性。</li></ul><h2 id="常见类"><a href="#常见类" class="headerlink" title="常见类"></a>常见类</h2><h3 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h3><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; getClass()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * naitive 方法，用于创建并返回当前对象的一份拷贝。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> Object <span class="hljs-title function_">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span><span class="hljs-params">()</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos)</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实例被垃圾回收器回收的时候触发的操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br></code></pre></td></tr></table></figure><h4 id="equals-的作用"><a href="#equals-的作用" class="headerlink" title="equals()的作用"></a>equals()的作用</h4><p><strong>&#x3D;&#x3D; 和 equals() 的区别</strong></p><p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p><ul><li>对于基本数据类型来说，<code>==</code> 比较的是值。</li><li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li></ul><div class="note note-warning">            <p>因为 Java 只有值传递，所以，对于 &#x3D;&#x3D; 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>          </div><p><strong><code>equals()</code></strong> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类，因此所有的类都有<code>equals()</code>方法。</p><p><code>Object</code> 类 <code>equals()</code> 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span><span class="hljs-params">(Object obj)</span> &#123;<br>     <span class="hljs-keyword">return</span> (<span class="hljs-built_in">this</span> == obj);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>equals()</code> 方法存在两种使用情况：</p><ul><li><strong>类没有重写 <code>equals()</code>方法</strong> ：通过<code>equals()</code>比较该类的两个对象时，等价于通过“&#x3D;&#x3D;”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li><li><strong>类重写了 <code>equals()</code>方法</strong> ：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</li></ul><h4 id="hashCode-的作用"><a href="#hashCode-的作用" class="headerlink" title="hashCode()的作用"></a>hashCode()的作用</h4><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p><p><code>hashCode()</code>定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是： <code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure><p>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p><p>其实， <code>hashCode()</code> 和 <code>equals()</code>都是用于比较两个对象是否相等。</p><p>因为在一些容器（比如 <code>HashMap</code>、<code>HashSet</code>）中，有了 <code>hashCode()</code> 之后，判断元素是否在对应容器中的效率会更高（参考添加元素进<code>HashSet</code>的过程）</p><p>所以，有以下结论：</p><ul><li><p>两个对象equals()为true，那么它们的hashCode()一定也相等；</p></li><li><p>它们的hashCode()相等，equals()不一定为ture</p></li><li><p>它们的hashCode()不相等，equals()一定为false</p></li></ul><p>这也是为什么我们重写equals()也必须重写hashCode()。</p><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><h4 id="String、StringBuffer、StringBuilder-的区别"><a href="#String、StringBuffer、StringBuilder-的区别" class="headerlink" title="String、StringBuffer、StringBuilder 的区别"></a>String、StringBuffer、StringBuilder 的区别</h4><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><blockquote><p>参考</p><ul><li>https:&#x2F;&#x2F;<span></span>javaguide.cn&#x2F;java&#x2F;basis&#x2F;java-basic-questions-01.html</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM</title>
    <link href="/1723864827/"/>
    <url>/1723864827/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="1-为什么要学习JVM？"><a href="#1-为什么要学习JVM？" class="headerlink" title="1.为什么要学习JVM？"></a>1.为什么要学习JVM？</h2><p>JVM（Java虚拟机）是Java语言的核心组成部分，它是一个虚拟计算机，可以将Java代码编译成字节码并在不同的平台上运行。学习JVM可以给我们带来以下优点：</p><ol><li>理解Java程序的运行机制：学习JVM可以帮助开发人员深入理解Java程序的内部运行机制，包括Java程序的编译、装载、链接、初始化、执行等各个阶段。</li><li>排查和解决Java程序的性能问题：由于JVM是Java程序的执行环境，学习JVM可以帮助开发人员诊断和解决Java程序的性能问题，如内存泄漏、GC性能等。</li><li>编写高效的Java程序：JVM提供了许多高级特性和优化技术，如JIT编译、垃圾回收、线程管理等，学习JVM可以帮助开发人员编写更高效、更可靠的Java程序。</li><li>深入理解Java语言：学习JVM需要涉及到Java语言的许多概念和特性，例如类、对象、继承、多态、异常处理等，这有助于开发人员深入理解Java语言的本质。</li><li>掌握Java虚拟机的调优技巧：学习JVM可以帮助开发人员掌握Java虚拟机的调优技巧，优化Java程序的性能和资源占用情况，提高应用程序的响应速度和稳定性。</li></ol><h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><h1 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h1><h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL优化总结</title>
    <link href="/3416063915/"/>
    <url>/3416063915/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高性能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka</title>
    <link href="/2591906323/"/>
    <url>/2591906323/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>分布式</category>
      
      <category>MQ</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JUC</title>
    <link href="/2857723967/"/>
    <url>/2857723967/</url>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="1-为什么要学习并发编程"><a href="#1-为什么要学习并发编程" class="headerlink" title="1.为什么要学习并发编程"></a>1.为什么要学习并发编程</h2><p>Java是一种广泛使用的编程语言，常用于开发大型、分布式、高并发的应用程序。在这样的应用中，多个线程同时执行任务是很常见的情况。因此，学习并发编程可以帮助Java开发人员更好地理解和处理多线程环境下的并发问题，提高程序的性能和可靠性。</p><p>具体来说，以下是Java学习并发编程的一些重要原因：</p><ol><li>提高程序性能：并发编程可以使多个线程同时执行任务，从而提高程序的处理能力和执行效率。</li><li>充分利用多核CPU：现代计算机通常具有多个CPU核心，使用并发编程可以充分利用这些核心，提高程序的并行处理能力。</li><li>避免死锁和竞态条件：多线程环境下，由于资源的共享和竞争，可能会出现死锁和竞态条件等问题。学习并发编程可以帮助开发人员避免这些问题。</li><li>实现更复杂的应用程序：并发编程可以使应用程序支持更复杂的功能，如实时数据处理、多用户交互、分布式计算等</li></ol><h2 id="2-概念解析"><a href="#2-概念解析" class="headerlink" title="2.概念解析"></a>2.概念解析</h2><h1 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h1><h1 id="锁基础"><a href="#锁基础" class="headerlink" title="锁基础"></a>锁基础</h1><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
    <categories>
      
      <category>基础</category>
      
      <category>JUC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis基础</title>
    <link href="/4264158992/"/>
    <url>/4264158992/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL</title>
    <link href="/3259397556/"/>
    <url>/3259397556/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
